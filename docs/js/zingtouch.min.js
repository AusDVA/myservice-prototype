/*!
 * 
 * ZingTouch v1.0.5
 * Author: ZingChart http://zingchart.com
 * License: MIT
 */
! function(e) {
    function t(r) { if (n[r]) return n[r].exports; var i = n[r] = { exports: {}, id: r, loaded: !1 }; return e[r].call(i.exports, i, i.exports, t), i.loaded = !0, i.exports } var n = {}; return t.m = e, t.c = n, t.p = "", t(0) }([function(e, t, n) { "use strict";

    function r(e) { return e && e.__esModule ? e : { default: e } } var i = n(1),
        u = r(i);
    window.ZingTouch = u.default }, function(e, t, n) { "use strict";

    function r(e) { return e && e.__esModule ? e : { default: e } } Object.defineProperty(t, "__esModule", { value: !0 }); var i = n(2),
        u = r(i),
        o = n(4),
        a = r(o),
        s = n(10),
        c = r(s),
        f = n(12),
        l = r(f),
        d = n(13),
        p = r(d),
        h = n(14),
        y = r(h),
        v = n(15),
        g = r(v),
        m = n(16),
        b = r(m),
        w = { _regions: [], Gesture: a.default, Expand: c.default, Pan: l.default, Pinch: p.default, Rotate: y.default, Swipe: g.default, Tap: b.default, Region: function(e, t, n) { var r = w._regions.length,
                    i = new u.default(e, t, n, r); return w._regions.push(i), i } };
    t.default = w }, function(e, t, n) { "use strict";

    function r(e) { return e && e.__esModule ? e : { default: e } }

    function i(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } Object.defineProperty(t, "__esModule", { value: !0 }); var u = function() {
            function e(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t } }(),
        o = n(3),
        a = r(o),
        s = n(4),
        c = r(s),
        f = n(6),
        l = r(f),
        d = n(9),
        p = r(d),
        h = function() {
            function e(t, n, r, u) { var o = this;
                i(this, e), this.id = u, this.element = t, this.capture = "undefined" != typeof n && n, this.preventDefault = "undefined" == typeof r || r, this.state = new p.default(u); var a = [];
                a = window.PointerEvent && !window.TouchEvent ? ["pointerdown", "pointermove", "pointerup"] : ["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend"], a.map(function(e) { t.addEventListener(e, function(e) {
                        (0, l.default)(e, o) }, o.capture) }) } return u(e, [{ key: "bind", value: function(e, t, n, r, i) { if (!e || e && !e.tagName) throw "Bind must contain an element"; return i = "undefined" != typeof i && i, t ? void this.state.addBinding(e, t, n, r, i) : new a.default(e, i, this.state) } }, { key: "bindOnce", value: function(e, t, n, r) { this.bind(e, t, n, r, !0) } }, { key: "unbind", value: function(e, t) { var n = this,
                        r = this.state.retrieveBindingsByElement(e),
                        i = []; return r.forEach(function(r) { if (t) { if ("string" == typeof t && n.state.registeredGestures[t]) { var u = n.state.registeredGestures[t];
                                u.id === r.gesture.id && (e.removeEventListener(r.gesture.getId(), r.handler, r.capture), i.push(r)) } } else e.removeEventListener(r.gesture.getId(), r.handler, r.capture), i.push(r) }), i } }, { key: "register", value: function(e, t) { if ("string" != typeof e) throw new Error("Parameter key is an invalid string"); if (!t instanceof c.default) throw new Error("Parameter gesture is an invalid Gesture object");
                    t.setType(e), this.state.registerGesture(t, e) } }, { key: "unregister", value: function(e) { this.state.bindings.forEach(function(t) { t.gesture.getType() === e && t.element.removeEventListener(t.gesture.getId(), t.handler, t.capture) }); var t = this.state.registeredGestures[e]; return delete this.state.registeredGestures[e], t } }]), e }();
    t.default = h }, function(e, t) { "use strict";

    function n(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } Object.defineProperty(t, "__esModule", { value: !0 }); var r = function e(t, r, i) { var u = this;
        n(this, e), this.element = t, Object.keys(i.registeredGestures).forEach(function(e) { u[e] = function(t, n) { return i.addBinding(u.element, e, t, n, r), u } }) };
    t.default = r }, function(e, t, n) { "use strict";

    function r(e) { return e && e.__esModule ? e : { default: e } }

    function i(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } Object.defineProperty(t, "__esModule", { value: !0 }); var u = function() {
            function e(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t } }(),
        o = n(5),
        a = r(o),
        s = function() {
            function e() { i(this, e), this.type = null, this.id = null } return u(e, [{ key: "setType", value: function(e) { this.type = e } }, { key: "getType", value: function() { return this.type } }, { key: "setId", value: function(e) { this.id = e } }, { key: "getId", value: function() { return null !== this.id ? this.id : this.type } }, { key: "update", value: function(e) { for (var t in e) this[t] && (this[t] = e[t]) } }, { key: "start", value: function(e, t, n) { return null } }, { key: "move", value: function(e, t, n) { return null } }, { key: "end", value: function(e) { return null } }, { key: "isValid", value: function(e, t, n) { var r = !0; return e.length > 1 && e.forEach(function(e) { a.default.isInside(e.initial.x, e.initial.y, n) || (r = !1) }), r } }]), e }();
    t.default = s }, function(e, t) { "use strict";
    Object.defineProperty(t, "__esModule", { value: !0 }); var n = 360,
        r = 180,
        i = { normalizeEvent: function(e) { switch (e) {
                    case "mousedown":
                    case "touchstart":
                    case "pointerdown":
                        return "start";
                    case "mousemove":
                    case "touchmove":
                    case "pointermove":
                        return "move";
                    case "mouseup":
                    case "touchend":
                    case "pointerup":
                        return "end";
                    default:
                        return null } }, isWithin: function(e, t, n, r, i) { return Math.abs(t - r) <= i && Math.abs(e - n) <= i }, distanceBetweenTwoPoints: function(e, t, n, r) { var i = Math.sqrt((t - e) * (t - e) + (r - n) * (r - n)); return Math.round(100 * i) / 100 }, getMidpoint: function(e, t, n, r) { return { x: (e + t) / 2, y: (n + r) / 2 } }, getAngle: function(e, t, i, u) { var o = Math.atan2(u - t, i - e) * (r / Math.PI); return n - (o < 0 ? n + o : o) }, getAngularDistance: function(e, t) { var i = (t - e) % n,
                    u = i < 0 ? 1 : -1; return i = Math.abs(i), i > r ? u * (n - i) : u * i }, getVelocity: function(e, t, n, r, i, u) { var o = this.distanceBetweenTwoPoints(e, r, t, i); return o / (u - n) }, getRightMostInput: function(e) { var t = null,
                    n = Number.MIN_VALUE; return e.forEach(function(e) { e.initial.x > n && (t = e) }), t }, isInteger: function(e) { return "number" == typeof e && e % 1 === 0 }, isInside: function(e, t, n) { var r = n.getBoundingClientRect(); return e > r.left && e < r.left + r.width && t > r.top && t < r.top + r.height }, getPropagationPath: function(e) { if (e.path) return e.path; for (var t = [], n = e.target; n != document;) t.push(n), n = n.parentNode; return t }, getPathIndex: function(e, t) { var n = e.length; return e.forEach(function(e, r) { e === t && (n = r) }), n }, setMSPreventDefault: function(e) { e.style["-ms-content-zooming"] = "none", e.style["touch-action"] = "none" }, removeMSPreventDefault: function(e) { e.style["-ms-content-zooming"] = "", e.style["touch-action"] = "" } };
    t.default = i }, function(e, t, n) { "use strict";

    function r(e) { return e && e.__esModule ? e : { default: e } }

    function i(e, t) { var n = t.state; if (0 !== n.inputs.length || "start" === f.default.normalizeEvent(e.type)) { if ("undefined" != typeof e.buttons && "end" !== f.default.normalizeEvent(e.type) && 0 === e.buttons) return void n.resetInputs(); if (n.updateInputs(e, t.element)) { var r = n.retrieveBindingsByInitialPos();
                r.length > 0 && ! function() { t.preventDefault ? (f.default.setMSPreventDefault(t.element), e.preventDefault ? e.preventDefault() : e.returnValue = !1) : f.default.removeMSPreventDefault(t.element); var i = {},
                        u = (0, s.default)(r, e, n);
                    u.forEach(function(t) { var n = t.binding.gesture.id; if (i[n]) { var r = f.default.getPropagationPath(e);
                            f.default.getPathIndex(r, t.binding.element) < f.default.getPathIndex(r, i[n].binding.element) && (i[n] = t) } else i[n] = t }), Object.keys(i).forEach(function(e) { var t = i[e];
                        (0, o.default)(t.binding, t.data, t.events) }) }(); var i = 0;
                n.inputs.forEach(function(e) { "end" === e.getCurrentEventType() && i++ }), i === n.inputs.length && n.resetInputs() } } } Object.defineProperty(t, "__esModule", { value: !0 }); var u = n(7),
        o = r(u),
        a = n(8),
        s = r(a),
        c = n(5),
        f = r(c);
    t.default = i }, function(e, t) { "use strict";

    function n(e, t, n) { t.events = n; var i = new CustomEvent(e.gesture.getId(), { detail: t, bubbles: !0, cancelable: !0 });
        r(e.element, i, e) }

    function r(e, t, n) { e.dispatchEvent(t), n.bindOnce && ZingTouch.unbind(n.element, n.gesture.getType()) } Object.defineProperty(t, "__esModule", { value: !0 }), t.default = n }, function(e, t, n) { "use strict";

    function r(e) { return e && e.__esModule ? e : { default: e } }

    function i(e, t, n) { var r = o.default.normalizeEvent(t.type),
            i = []; return e.forEach(function(e) { var t = e.gesture[r](n.inputs, n, e.element);
            t && ! function() { var r = [];
                n.inputs.forEach(function(e) { r.push(e.current) }), i.push({ binding: e, data: t, events: r }) }() }), i } Object.defineProperty(t, "__esModule", { value: !0 }); var u = n(5),
        o = r(u);
    t.default = i }, function(e, t, n) { "use strict";

    function r(e) { return e && e.__esModule ? e : { default: e } }

    function i(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }

    function u(e, t) { for (var n = 0; n < e.length; n++)
            if (e[n].identifier === t) return e[n]; return null } Object.defineProperty(t, "__esModule", { value: !0 }); var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) { return typeof e } : function(e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e },
        a = function() {
            function e(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t } }(),
        s = n(4),
        c = r(s),
        f = n(10),
        l = r(f),
        d = n(12),
        p = r(d),
        h = n(13),
        y = r(h),
        v = n(14),
        g = r(v),
        m = n(15),
        b = r(m),
        w = n(16),
        _ = r(w),
        P = n(17),
        E = r(P),
        O = n(18),
        x = r(O),
        j = n(5),
        I = r(j),
        k = 0,
        M = function() {
            function e(t) { i(this, e), this.regionId = t, this.inputs = [], this.bindings = [], this.numGestures = 0, this.registeredGestures = {}, this.registerGesture(new l.default, "expand"), this.registerGesture(new p.default, "pan"), this.registerGesture(new g.default, "rotate"), this.registerGesture(new y.default, "pinch"), this.registerGesture(new b.default, "swipe"), this.registerGesture(new _.default, "tap") } return a(e, [{ key: "addBinding", value: function(e, t, n, r, i) { var u = void 0; if (e && "undefined" == typeof e.tagName) throw new Error("Parameter element is an invalid object."); if ("function" != typeof n) throw new Error("Parameter handler is invalid."); if ("string" == typeof t && Object.keys(this.registeredGestures).indexOf(t) === -1) throw new Error("Parameter " + t + " is not a registered gesture"); if ("object" === ("undefined" == typeof t ? "undefined" : o(t)) && !(t instanceof c.default)) throw new Error("Parameter for the gesture is not of a Gesture type"); "string" == typeof t ? u = this.registeredGestures[t] : (u = t, "" === u.id && this.assignGestureId(u)), this.bindings.push(new E.default(e, u, n, r, i)), e.addEventListener(u.getId(), n, r) } }, { key: "retrieveBindingsByElement", value: function(e) { var t = []; return this.bindings.map(function(n) { n.element === e && t.push(n) }), t } }, { key: "retrieveBindingsByInitialPos", value: function() { var e = this,
                        t = []; return this.bindings.forEach(function(n) { var r = e.inputs.filter(function(e) { return I.default.isInside(e.initial.x, e.initial.y, n.element) });
                        r.length > 0 && t.push(n) }), t } }, { key: "updateInputs", value: function(e, t) {
                    function n(e, t, n, r) { var i = I.default.normalizeEvent(e.type),
                            o = u(t.inputs, n); return "start" === i && o ? void t.resetInputs() : "start" !== i && o && !I.default.isInside(o.current.x, o.current.y, r) ? void t.resetInputs() : "start" === i || o ? void("start" === i ? t.inputs.push(new x.default(e, n)) : o.update(e, n)) : void t.resetInputs() } var r = k,
                        i = e.touches ? "TouchEvent" : e.pointerType ? "PointerEvent" : "MouseEvent"; switch (i) {
                        case "TouchEvent":
                            for (var o in e.changedTouches) e.changedTouches.hasOwnProperty(o) && I.default.isInteger(parseInt(o)) && (r = e.changedTouches[o].identifier, n(e, this, r, t)); break;
                        case "PointerEvent":
                            r = e.pointerId, n(e, this, r, t); break;
                        case "MouseEvent":
                        default:
                            n(e, this, k, t) } return !0 } }, { key: "resetInputs", value: function() { this.inputs = [] } }, { key: "numActiveInputs", value: function() { var e = this.inputs.filter(function(e) { return "end" !== e.current.type }); return e.length } }, { key: "registerGesture", value: function(e, t) { this.assignGestureId(e), this.registeredGestures[t] = e } }, { key: "assignGestureId", value: function(e) { e.setId(this.regionId + "-" + this.numGestures++) } }]), e }();
    t.default = M }, function(e, t, n) { "use strict";

    function r(e) { return e && e.__esModule ? e : { default: e } }

    function i(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }

    function u(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }

    function o(e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t) } Object.defineProperty(t, "__esModule", { value: !0 }); var a = n(11),
        s = r(a),
        c = function(e) {
            function t(e) { i(this, t); var n = u(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.type = "expand", n } return o(t, e), t }(s.default);
    t.default = c }, function(e, t, n) { "use strict";

    function r(e) { return e && e.__esModule ? e : { default: e } }

    function i(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }

    function u(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }

    function o(e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t) } Object.defineProperty(t, "__esModule", { value: !0 }); var a = function() {
            function e(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t } }(),
        s = n(4),
        c = r(s),
        f = n(5),
        l = r(f),
        d = 2,
        p = 1,
        h = function(e) {
            function t(e) { i(this, t); var n = u(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this)); return n.type = "distance", n.threshold = e && e.threshold ? e.threshold : p, n } return o(t, e), a(t, [{ key: "start", value: function(e, t, n) { if (!this.isValid(e, t, n)) return null; if (e.length === d) { var r = e[0].getGestureProgress(this.type);
                        r.lastEmittedDistance = l.default.distanceBetweenTwoPoints(e[0].current.x, e[1].current.x, e[0].current.y, e[1].current.y) } } }, { key: "move", value: function(e, t, n) { if (t.numActiveInputs() === d) { var r = l.default.distanceBetweenTwoPoints(e[0].current.x, e[1].current.x, e[0].current.y, e[1].current.y),
                            i = l.default.distanceBetweenTwoPoints(e[0].previous.x, e[1].previous.x, e[0].previous.y, e[1].previous.y),
                            u = l.default.getMidpoint(e[0].current.x, e[1].current.x, e[0].current.y, e[1].current.y),
                            o = e[0].getGestureProgress(this.type); if ("expand" === this.type) { if (r < i) o.lastEmittedDistance = r;
                            else if (r - o.lastEmittedDistance >= this.threshold) return o.lastEmittedDistance = r, { distance: r, center: u } } else if (r > i) o.lastEmittedDistance = r;
                        else if (r < i && o.lastEmittedDistance - r >= this.threshold) return o.lastEmittedDistance = r, { distance: r, center: u }; return null } } }]), t }(c.default);
    t.default = h }, function(e, t, n) { "use strict";

    function r(e) { return e && e.__esModule ? e : { default: e } }

    function i(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }

    function u(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }

    function o(e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t) } Object.defineProperty(t, "__esModule", { value: !0 }); var a = function() {
            function e(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t } }(),
        s = n(4),
        c = r(s),
        f = n(5),
        l = r(f),
        d = 1,
        p = 1,
        h = function(e) {
            function t(e) { i(this, t); var n = u(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this)); return n.type = "pan", n.numInputs = e && e.numInputs ? e.numInputs : d, n.threshold = e && e.threshold ? e.threshold : p, n } return o(t, e), a(t, [{ key: "start", value: function(e) { var t = this;
                    e.forEach(function(e) { var n = e.getGestureProgress(t.getId());
                        n.active = !0, n.lastEmitted = { x: e.current.x, y: e.current.y } }) } }, { key: "move", value: function(e, t, n) { if (this.numInputs === e.length)
                        for (var r = { data: [] }, i = 0; i < e.length; i++) { var u = e[i].getGestureProgress(this.getId()),
                                o = !1,
                                a = Math.abs(e[i].current.y - u.lastEmitted.y) > this.threshold,
                                s = Math.abs(e[i].current.x - u.lastEmitted.x) > this.threshold; if (o = a || s, !u.active || !o) return null;
                            r.data[i] = { distanceFromOrigin: l.default.distanceBetweenTwoPoints(e[i].initial.x, e[i].current.x, e[i].initial.y, e[i].current.y), directionFromOrigin: l.default.getAngle(e[i].initial.x, e[i].initial.y, e[i].current.x, e[i].current.y), currentDirection: l.default.getAngle(u.lastEmitted.x, u.lastEmitted.y, e[i].current.x, e[i].current.y) }, u.lastEmitted.x = e[i].current.x, u.lastEmitted.y = e[i].current.y }
                    return r } }, { key: "end", value: function(e) { var t = this; return e.forEach(function(e) { var n = e.getGestureProgress(t.getId());
                        n.active = !1 }), null } }]), t }(c.default);
    t.default = h }, function(e, t, n) { "use strict";

    function r(e) { return e && e.__esModule ? e : { default: e } }

    function i(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }

    function u(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }

    function o(e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t) } Object.defineProperty(t, "__esModule", { value: !0 }); var a = n(11),
        s = r(a),
        c = n(5),
        f = (r(c), function(e) {
            function t(e) { i(this, t); var n = u(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)); return n.type = "pinch", n } return o(t, e), t }(s.default));
    t.default = f }, function(e, t, n) { "use strict";

    function r(e) { return e && e.__esModule ? e : { default: e } }

    function i(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }

    function u(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }

    function o(e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t) } Object.defineProperty(t, "__esModule", { value: !0 }); var a = function() {
            function e(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t } }(),
        s = n(4),
        c = r(s),
        f = n(5),
        l = r(f),
        d = 2,
        p = function(e) {
            function t() { i(this, t); var e = u(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this)); return e.type = "rotate", e } return o(t, e), a(t, [{ key: "move", value: function(e, t, n) { if (t.numActiveInputs() <= d) { var r = void 0,
                            i = void 0,
                            u = void 0,
                            o = void 0; if (1 === t.numActiveInputs()) { var a = n.getBoundingClientRect();
                            r = { x: a.left + a.width / 2, y: a.top + a.height / 2 }, o = e[0], i = u = 0 } else { r = l.default.getMidpoint(e[0].initial.x, e[1].initial.x, e[0].initial.y, e[1].initial.y); var s = l.default.getMidpoint(e[0].current.x, e[1].current.x, e[0].current.y, e[1].current.y);
                            i = r.x - s.x, u = r.y - s.y, o = l.default.getRightMostInput(e) } var c = l.default.getAngle(r.x, r.y, o.current.x + i, o.current.y + u),
                            f = o.getGestureProgress(this.getId()); return f.initialAngle ? (f.change = l.default.getAngularDistance(f.previousAngle, c), f.distance = f.distance + f.change) : (f.initialAngle = f.previousAngle = c, f.distance = f.change = 0), f.previousAngle = c, { angle: c, distanceFromOrigin: f.distance, distanceFromLast: f.change } } return null } }]), t }(c.default);
    t.default = p }, function(e, t, n) { "use strict";

    function r(e) { return e && e.__esModule ? e : { default: e } }

    function i(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }

    function u(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }

    function o(e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t) } Object.defineProperty(t, "__esModule", { value: !0 }); var a = function() {
            function e(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t } }(),
        s = n(4),
        c = r(s),
        f = n(5),
        l = r(f),
        d = 1,
        p = 100,
        h = .2,
        y = 100,
        v = 10,
        g = function(e) {
            function t(e) { i(this, t); var n = u(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this)); return n.type = "swipe", n.numInputs = e && e.numInputs ? e.numInputs : d, n.maxRestTime = e && e.maxRestTime ? e.maxRestTime : p, n.escapeVelocity = e && e.escapeVelocity ? e.escapeVelocity : h, n.timeDistortion = e && e.timeDistortion ? e.timeDistortion : y, n.maxProgressStack = e && e.maxProgressStack ? e.maxProgressStack : v, n } return o(t, e), a(t, [{ key: "move", value: function(e, t, n) { if (this.numInputs === e.length)
                        for (var r = 0; r < e.length; r++) { var i = e[r].getGestureProgress(this.getId());
                            i.moves || (i.moves = []), i.moves.push({ time: (new Date).getTime(), x: e[r].current.x, y: e[r].current.y }), i.length > this.maxProgressStack && i.moves.shift() }
                    return null } }, { key: "end", value: function(e) { if (this.numInputs === e.length) { for (var t = { data: [] }, n = 0; n < e.length; n++) { if ("end" !== e[n].current.type) return; var r = e[n].getGestureProgress(this.getId()); if (r.moves && r.moves.length > 2) { var i = r.moves.pop(); if ((new Date).getTime() - i.time > this.maxRestTime) return null; for (var u = void 0, o = r.moves.length - 1; o !== -1;) { if (r.moves[o].time !== i.time) { u = r.moves[o]; break } o-- } u || (u = r.moves.pop(), u.time += this.timeDistortion); var a = l.default.getVelocity(u.x, u.y, u.time, i.x, i.y, i.time);
                                t.data[n] = { velocity: a, currentDirection: l.default.getAngle(u.x, u.y, i.x, i.y) } } } for (var n = 0; n < t.data.length; n++)
                            if (a < this.escapeVelocity) return null; if (t.data.length > 0) return t } return null } }]), t }(c.default);
    t.default = g }, function(e, t, n) { "use strict";

    function r(e) { return e && e.__esModule ? e : { default: e } }

    function i(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }

    function u(e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }

    function o(e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
        e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t) } Object.defineProperty(t, "__esModule", { value: !0 }); var a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) { return typeof e } : function(e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e },
        s = function() {
            function e(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t } }(),
        c = n(4),
        f = r(c),
        l = n(5),
        d = r(l),
        p = 0,
        h = 300,
        y = 1,
        v = 10,
        g = function(e) {
            function t(e) { i(this, t); var n = u(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this)); return n.type = "tap", n.minDelay = e && e.minDelay ? e.minDelay : p, n.maxDelay = e && e.maxDelay ? e.maxDelay : h, n.numInputs = e && e.numInputs ? e.numInputs : y, n.tolerance = e && e.tolerance ? e.tolerance : v, n } return o(t, e), s(t, [{ key: "start", value: function(e) { var t = this; return e.length === this.numInputs && e.forEach(function(e) { var n = e.getGestureProgress(t.type);
                        n.start = (new Date).getTime() }), null } }, { key: "move", value: function(e, t, n) { for (var r = this, i = 0; i < e.length; i++)
                        if ("move" === e[i].getCurrentEventType()) { var u = e[i].current,
                                o = e[i].previous; if (!d.default.isWithin(u.x, u.y, o.x, o.y, this.tolerance)) { var s = function() { var t = r.type; return e.forEach(function(e) { e.resetProgress(t) }), { v: null } }(); if ("object" === ("undefined" == typeof s ? "undefined" : a(s))) return s.v } } return null } }, { key: "end", value: function(e) { var t = this; if (e.length !== this.numInputs) return null; for (var n = Number.MAX_VALUE, r = 0; r < e.length; r++) { if ("end" !== e[r].getCurrentEventType()) return null; var i = e[r].getGestureProgress(this.type); if (!i.start) return null;
                        i.start < n && (n = i.start) } var u = (new Date).getTime() - n; if (this.minDelay <= u && this.maxDelay >= u) return { interval: u }; var o = function() { var n = t.type; return e.forEach(function(e) { e.resetProgress(n) }), { v: null } }(); return "object" === ("undefined" == typeof o ? "undefined" : a(o)) ? o.v : void 0 } }]), t }(f.default);
    t.default = g }, function(e, t) { "use strict";

    function n(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } Object.defineProperty(t, "__esModule", { value: !0 }); var r = function e(t, r, i, u, o) { n(this, e), this.element = t, this.gesture = r, this.handler = i, this.capture = "undefined" != typeof u && u, this.bindOnce = "undefined" != typeof o && o };
    t.default = r }, function(e, t, n) { "use strict";

    function r(e) { return e && e.__esModule ? e : { default: e } }

    function i(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } Object.defineProperty(t, "__esModule", { value: !0 }); var u = function() {
            function e(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n];
                    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } return function(t, n, r) { return n && e(t.prototype, n), r && e(t, r), t } }(),
        o = n(19),
        a = r(o),
        s = function() {
            function e(t, n) { i(this, e); var r = new a.default(t, n);
                this.initial = r, this.current = r, this.previous = r, this.identifier = "undefined" != typeof n ? n : 0, this.progress = {} } return u(e, [{ key: "update", value: function(e, t) { this.previous = this.current, this.current = new a.default(e, t) } }, { key: "getGestureProgress", value: function(e) { return this.progress[e] || (this.progress[e] = {}), this.progress[e] } }, { key: "getCurrentEventType", value: function() { return this.current.type } }, { key: "resetProgress", value: function(e) { this.progress[e] = {} } }]), e }();
    t.default = s }, function(e, t, n) { "use strict";

    function r(e) { return e && e.__esModule ? e : { default: e } }

    function i(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } Object.defineProperty(t, "__esModule", { value: !0 }); var u = n(5),
        o = r(u),
        a = 0,
        s = function e(t, n) { i(this, e), this.originalEvent = t, this.type = o.default.normalizeEvent(t.type), this.x = a, this.y = a; var r = void 0; if (t.touches && t.changedTouches) { for (var u = 0; u < t.changedTouches.length; u++)
                    if (t.changedTouches[u].identifier === n) { r = t.changedTouches[u]; break } } else r = t;
            this.x = this.clientX = r.clientX, this.y = this.clientY = r.clientY, this.pageX = r.pageX, this.pageY = r.pageY, this.screenX = r.screenX, this.screenY = r.screenY };
    t.default = s }]);
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJ6aW5ndG91Y2gubWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogXG4gKiBaaW5nVG91Y2ggdjEuMC41XG4gKiBBdXRob3I6IFppbmdDaGFydCBodHRwOi8vemluZ2NoYXJ0LmNvbVxuICogTGljZW5zZTogTUlUXG4gKi9cbiEgZnVuY3Rpb24oZSkge1xuICAgIGZ1bmN0aW9uIHQocikgeyBpZiAobltyXSkgcmV0dXJuIG5bcl0uZXhwb3J0czsgdmFyIGkgPSBuW3JdID0geyBleHBvcnRzOiB7fSwgaWQ6IHIsIGxvYWRlZDogITEgfTsgcmV0dXJuIGVbcl0uY2FsbChpLmV4cG9ydHMsIGksIGkuZXhwb3J0cywgdCksIGkubG9hZGVkID0gITAsIGkuZXhwb3J0cyB9IHZhciBuID0ge307IHJldHVybiB0Lm0gPSBlLCB0LmMgPSBuLCB0LnAgPSBcIlwiLCB0KDApIH0oW2Z1bmN0aW9uKGUsIHQsIG4pIHsgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiByKGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9IH0gdmFyIGkgPSBuKDEpLFxuICAgICAgICB1ID0gcihpKTtcbiAgICB3aW5kb3cuWmluZ1RvdWNoID0gdS5kZWZhdWx0IH0sIGZ1bmN0aW9uKGUsIHQsIG4pIHsgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiByKGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9IH0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTsgdmFyIGkgPSBuKDIpLFxuICAgICAgICB1ID0gcihpKSxcbiAgICAgICAgbyA9IG4oNCksXG4gICAgICAgIGEgPSByKG8pLFxuICAgICAgICBzID0gbigxMCksXG4gICAgICAgIGMgPSByKHMpLFxuICAgICAgICBmID0gbigxMiksXG4gICAgICAgIGwgPSByKGYpLFxuICAgICAgICBkID0gbigxMyksXG4gICAgICAgIHAgPSByKGQpLFxuICAgICAgICBoID0gbigxNCksXG4gICAgICAgIHkgPSByKGgpLFxuICAgICAgICB2ID0gbigxNSksXG4gICAgICAgIGcgPSByKHYpLFxuICAgICAgICBtID0gbigxNiksXG4gICAgICAgIGIgPSByKG0pLFxuICAgICAgICB3ID0geyBfcmVnaW9uczogW10sIEdlc3R1cmU6IGEuZGVmYXVsdCwgRXhwYW5kOiBjLmRlZmF1bHQsIFBhbjogbC5kZWZhdWx0LCBQaW5jaDogcC5kZWZhdWx0LCBSb3RhdGU6IHkuZGVmYXVsdCwgU3dpcGU6IGcuZGVmYXVsdCwgVGFwOiBiLmRlZmF1bHQsIFJlZ2lvbjogZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgciA9IHcuX3JlZ2lvbnMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBpID0gbmV3IHUuZGVmYXVsdChlLCB0LCBuLCByKTsgcmV0dXJuIHcuX3JlZ2lvbnMucHVzaChpKSwgaSB9IH07XG4gICAgdC5kZWZhdWx0ID0gdyB9LCBmdW5jdGlvbihlLCB0LCBuKSB7IFwidXNlIHN0cmljdFwiO1xuXG4gICAgZnVuY3Rpb24gcihlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfSB9XG5cbiAgICBmdW5jdGlvbiBpKGUsIHQpIHsgaWYgKCEoZSBpbnN0YW5jZW9mIHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpIH0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTsgdmFyIHUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGUoZSwgdCkgeyBmb3IgKHZhciBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHsgdmFyIHIgPSB0W25dO1xuICAgICAgICAgICAgICAgICAgICByLmVudW1lcmFibGUgPSByLmVudW1lcmFibGUgfHwgITEsIHIuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiByICYmIChyLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgci5rZXksIHIpIH0gfSByZXR1cm4gZnVuY3Rpb24odCwgbiwgcikgeyByZXR1cm4gbiAmJiBlKHQucHJvdG90eXBlLCBuKSwgciAmJiBlKHQsIHIpLCB0IH0gfSgpLFxuICAgICAgICBvID0gbigzKSxcbiAgICAgICAgYSA9IHIobyksXG4gICAgICAgIHMgPSBuKDQpLFxuICAgICAgICBjID0gcihzKSxcbiAgICAgICAgZiA9IG4oNiksXG4gICAgICAgIGwgPSByKGYpLFxuICAgICAgICBkID0gbig5KSxcbiAgICAgICAgcCA9IHIoZCksXG4gICAgICAgIGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGUodCwgbiwgciwgdSkgeyB2YXIgbyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaSh0aGlzLCBlKSwgdGhpcy5pZCA9IHUsIHRoaXMuZWxlbWVudCA9IHQsIHRoaXMuY2FwdHVyZSA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIG4gJiYgbiwgdGhpcy5wcmV2ZW50RGVmYXVsdCA9IFwidW5kZWZpbmVkXCIgPT0gdHlwZW9mIHIgfHwgciwgdGhpcy5zdGF0ZSA9IG5ldyBwLmRlZmF1bHQodSk7IHZhciBhID0gW107XG4gICAgICAgICAgICAgICAgYSA9IHdpbmRvdy5Qb2ludGVyRXZlbnQgJiYgIXdpbmRvdy5Ub3VjaEV2ZW50ID8gW1wicG9pbnRlcmRvd25cIiwgXCJwb2ludGVybW92ZVwiLCBcInBvaW50ZXJ1cFwiXSA6IFtcIm1vdXNlZG93blwiLCBcIm1vdXNlbW92ZVwiLCBcIm1vdXNldXBcIiwgXCJ0b3VjaHN0YXJ0XCIsIFwidG91Y2htb3ZlXCIsIFwidG91Y2hlbmRcIl0sIGEubWFwKGZ1bmN0aW9uKGUpIHsgdC5hZGRFdmVudExpc3RlbmVyKGUsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBsLmRlZmF1bHQpKGUsIG8pIH0sIG8uY2FwdHVyZSkgfSkgfSByZXR1cm4gdShlLCBbeyBrZXk6IFwiYmluZFwiLCB2YWx1ZTogZnVuY3Rpb24oZSwgdCwgbiwgciwgaSkgeyBpZiAoIWUgfHwgZSAmJiAhZS50YWdOYW1lKSB0aHJvdyBcIkJpbmQgbXVzdCBjb250YWluIGFuIGVsZW1lbnRcIjsgcmV0dXJuIGkgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBpICYmIGksIHQgPyB2b2lkIHRoaXMuc3RhdGUuYWRkQmluZGluZyhlLCB0LCBuLCByLCBpKSA6IG5ldyBhLmRlZmF1bHQoZSwgaSwgdGhpcy5zdGF0ZSkgfSB9LCB7IGtleTogXCJiaW5kT25jZVwiLCB2YWx1ZTogZnVuY3Rpb24oZSwgdCwgbiwgcikgeyB0aGlzLmJpbmQoZSwgdCwgbiwgciwgITApIH0gfSwgeyBrZXk6IFwidW5iaW5kXCIsIHZhbHVlOiBmdW5jdGlvbihlLCB0KSB7IHZhciBuID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSB0aGlzLnN0YXRlLnJldHJpZXZlQmluZGluZ3NCeUVsZW1lbnQoZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gW107IHJldHVybiByLmZvckVhY2goZnVuY3Rpb24ocikgeyBpZiAodCkgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCAmJiBuLnN0YXRlLnJlZ2lzdGVyZWRHZXN0dXJlc1t0XSkgeyB2YXIgdSA9IG4uc3RhdGUucmVnaXN0ZXJlZEdlc3R1cmVzW3RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1LmlkID09PSByLmdlc3R1cmUuaWQgJiYgKGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihyLmdlc3R1cmUuZ2V0SWQoKSwgci5oYW5kbGVyLCByLmNhcHR1cmUpLCBpLnB1c2gocikpIH0gfSBlbHNlIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihyLmdlc3R1cmUuZ2V0SWQoKSwgci5oYW5kbGVyLCByLmNhcHR1cmUpLCBpLnB1c2gocikgfSksIGkgfSB9LCB7IGtleTogXCJyZWdpc3RlclwiLCB2YWx1ZTogZnVuY3Rpb24oZSwgdCkgeyBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSkgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIGtleSBpcyBhbiBpbnZhbGlkIHN0cmluZ1wiKTsgaWYgKCF0IGluc3RhbmNlb2YgYy5kZWZhdWx0KSB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgZ2VzdHVyZSBpcyBhbiBpbnZhbGlkIEdlc3R1cmUgb2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgICAgICB0LnNldFR5cGUoZSksIHRoaXMuc3RhdGUucmVnaXN0ZXJHZXN0dXJlKHQsIGUpIH0gfSwgeyBrZXk6IFwidW5yZWdpc3RlclwiLCB2YWx1ZTogZnVuY3Rpb24oZSkgeyB0aGlzLnN0YXRlLmJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24odCkgeyB0Lmdlc3R1cmUuZ2V0VHlwZSgpID09PSBlICYmIHQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHQuZ2VzdHVyZS5nZXRJZCgpLCB0LmhhbmRsZXIsIHQuY2FwdHVyZSkgfSk7IHZhciB0ID0gdGhpcy5zdGF0ZS5yZWdpc3RlcmVkR2VzdHVyZXNbZV07IHJldHVybiBkZWxldGUgdGhpcy5zdGF0ZS5yZWdpc3RlcmVkR2VzdHVyZXNbZV0sIHQgfSB9XSksIGUgfSgpO1xuICAgIHQuZGVmYXVsdCA9IGggfSwgZnVuY3Rpb24oZSwgdCkgeyBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIG4oZSwgdCkgeyBpZiAoIShlIGluc3RhbmNlb2YgdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIikgfSBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pOyB2YXIgciA9IGZ1bmN0aW9uIGUodCwgciwgaSkgeyB2YXIgdSA9IHRoaXM7XG4gICAgICAgIG4odGhpcywgZSksIHRoaXMuZWxlbWVudCA9IHQsIE9iamVjdC5rZXlzKGkucmVnaXN0ZXJlZEdlc3R1cmVzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHsgdVtlXSA9IGZ1bmN0aW9uKHQsIG4pIHsgcmV0dXJuIGkuYWRkQmluZGluZyh1LmVsZW1lbnQsIGUsIHQsIG4sIHIpLCB1IH0gfSkgfTtcbiAgICB0LmRlZmF1bHQgPSByIH0sIGZ1bmN0aW9uKGUsIHQsIG4pIHsgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiByKGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9IH1cblxuICAgIGZ1bmN0aW9uIGkoZSwgdCkgeyBpZiAoIShlIGluc3RhbmNlb2YgdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIikgfSBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pOyB2YXIgdSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZShlLCB0KSB7IGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykgeyB2YXIgciA9IHRbbl07XG4gICAgICAgICAgICAgICAgICAgIHIuZW51bWVyYWJsZSA9IHIuZW51bWVyYWJsZSB8fCAhMSwgci5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIHIgJiYgKHIud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLmtleSwgcikgfSB9IHJldHVybiBmdW5jdGlvbih0LCBuLCByKSB7IHJldHVybiBuICYmIGUodC5wcm90b3R5cGUsIG4pLCByICYmIGUodCwgciksIHQgfSB9KCksXG4gICAgICAgIG8gPSBuKDUpLFxuICAgICAgICBhID0gcihvKSxcbiAgICAgICAgcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZSgpIHsgaSh0aGlzLCBlKSwgdGhpcy50eXBlID0gbnVsbCwgdGhpcy5pZCA9IG51bGwgfSByZXR1cm4gdShlLCBbeyBrZXk6IFwic2V0VHlwZVwiLCB2YWx1ZTogZnVuY3Rpb24oZSkgeyB0aGlzLnR5cGUgPSBlIH0gfSwgeyBrZXk6IFwiZ2V0VHlwZVwiLCB2YWx1ZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnR5cGUgfSB9LCB7IGtleTogXCJzZXRJZFwiLCB2YWx1ZTogZnVuY3Rpb24oZSkgeyB0aGlzLmlkID0gZSB9IH0sIHsga2V5OiBcImdldElkXCIsIHZhbHVlOiBmdW5jdGlvbigpIHsgcmV0dXJuIG51bGwgIT09IHRoaXMuaWQgPyB0aGlzLmlkIDogdGhpcy50eXBlIH0gfSwgeyBrZXk6IFwidXBkYXRlXCIsIHZhbHVlOiBmdW5jdGlvbihlKSB7IGZvciAodmFyIHQgaW4gZSkgdGhpc1t0XSAmJiAodGhpc1t0XSA9IGVbdF0pIH0gfSwgeyBrZXk6IFwic3RhcnRcIiwgdmFsdWU6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgcmV0dXJuIG51bGwgfSB9LCB7IGtleTogXCJtb3ZlXCIsIHZhbHVlOiBmdW5jdGlvbihlLCB0LCBuKSB7IHJldHVybiBudWxsIH0gfSwgeyBrZXk6IFwiZW5kXCIsIHZhbHVlOiBmdW5jdGlvbihlKSB7IHJldHVybiBudWxsIH0gfSwgeyBrZXk6IFwiaXNWYWxpZFwiLCB2YWx1ZTogZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgciA9ICEwOyByZXR1cm4gZS5sZW5ndGggPiAxICYmIGUuZm9yRWFjaChmdW5jdGlvbihlKSB7IGEuZGVmYXVsdC5pc0luc2lkZShlLmluaXRpYWwueCwgZS5pbml0aWFsLnksIG4pIHx8IChyID0gITEpIH0pLCByIH0gfV0pLCBlIH0oKTtcbiAgICB0LmRlZmF1bHQgPSBzIH0sIGZ1bmN0aW9uKGUsIHQpIHsgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTsgdmFyIG4gPSAzNjAsXG4gICAgICAgIHIgPSAxODAsXG4gICAgICAgIGkgPSB7IG5vcm1hbGl6ZUV2ZW50OiBmdW5jdGlvbihlKSB7IHN3aXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibW91c2Vkb3duXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b3VjaHN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwb2ludGVyZG93blwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RhcnRcIjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1vdXNlbW92ZVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG91Y2htb3ZlXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwb2ludGVybW92ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibW92ZVwiO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibW91c2V1cFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG91Y2hlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBvaW50ZXJ1cFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZW5kXCI7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbCB9IH0sIGlzV2l0aGluOiBmdW5jdGlvbihlLCB0LCBuLCByLCBpKSB7IHJldHVybiBNYXRoLmFicyh0IC0gcikgPD0gaSAmJiBNYXRoLmFicyhlIC0gbikgPD0gaSB9LCBkaXN0YW5jZUJldHdlZW5Ud29Qb2ludHM6IGZ1bmN0aW9uKGUsIHQsIG4sIHIpIHsgdmFyIGkgPSBNYXRoLnNxcnQoKHQgLSBlKSAqICh0IC0gZSkgKyAociAtIG4pICogKHIgLSBuKSk7IHJldHVybiBNYXRoLnJvdW5kKDEwMCAqIGkpIC8gMTAwIH0sIGdldE1pZHBvaW50OiBmdW5jdGlvbihlLCB0LCBuLCByKSB7IHJldHVybiB7IHg6IChlICsgdCkgLyAyLCB5OiAobiArIHIpIC8gMiB9IH0sIGdldEFuZ2xlOiBmdW5jdGlvbihlLCB0LCBpLCB1KSB7IHZhciBvID0gTWF0aC5hdGFuMih1IC0gdCwgaSAtIGUpICogKHIgLyBNYXRoLlBJKTsgcmV0dXJuIG4gLSAobyA8IDAgPyBuICsgbyA6IG8pIH0sIGdldEFuZ3VsYXJEaXN0YW5jZTogZnVuY3Rpb24oZSwgdCkgeyB2YXIgaSA9ICh0IC0gZSkgJSBuLFxuICAgICAgICAgICAgICAgICAgICB1ID0gaSA8IDAgPyAxIDogLTE7IHJldHVybiBpID0gTWF0aC5hYnMoaSksIGkgPiByID8gdSAqIChuIC0gaSkgOiB1ICogaSB9LCBnZXRWZWxvY2l0eTogZnVuY3Rpb24oZSwgdCwgbiwgciwgaSwgdSkgeyB2YXIgbyA9IHRoaXMuZGlzdGFuY2VCZXR3ZWVuVHdvUG9pbnRzKGUsIHIsIHQsIGkpOyByZXR1cm4gbyAvICh1IC0gbikgfSwgZ2V0UmlnaHRNb3N0SW5wdXQ6IGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBuID0gTnVtYmVyLk1JTl9WQUxVRTsgcmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihlKSB7IGUuaW5pdGlhbC54ID4gbiAmJiAodCA9IGUpIH0pLCB0IH0sIGlzSW50ZWdlcjogZnVuY3Rpb24oZSkgeyByZXR1cm4gXCJudW1iZXJcIiA9PSB0eXBlb2YgZSAmJiBlICUgMSA9PT0gMCB9LCBpc0luc2lkZTogZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgciA9IG4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IHJldHVybiBlID4gci5sZWZ0ICYmIGUgPCByLmxlZnQgKyByLndpZHRoICYmIHQgPiByLnRvcCAmJiB0IDwgci50b3AgKyByLmhlaWdodCB9LCBnZXRQcm9wYWdhdGlvblBhdGg6IGZ1bmN0aW9uKGUpIHsgaWYgKGUucGF0aCkgcmV0dXJuIGUucGF0aDsgZm9yICh2YXIgdCA9IFtdLCBuID0gZS50YXJnZXQ7IG4gIT0gZG9jdW1lbnQ7KSB0LnB1c2gobiksIG4gPSBuLnBhcmVudE5vZGU7IHJldHVybiB0IH0sIGdldFBhdGhJbmRleDogZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiA9IGUubGVuZ3RoOyByZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUsIHIpIHsgZSA9PT0gdCAmJiAobiA9IHIpIH0pLCBuIH0sIHNldE1TUHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKGUpIHsgZS5zdHlsZVtcIi1tcy1jb250ZW50LXpvb21pbmdcIl0gPSBcIm5vbmVcIiwgZS5zdHlsZVtcInRvdWNoLWFjdGlvblwiXSA9IFwibm9uZVwiIH0sIHJlbW92ZU1TUHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKGUpIHsgZS5zdHlsZVtcIi1tcy1jb250ZW50LXpvb21pbmdcIl0gPSBcIlwiLCBlLnN0eWxlW1widG91Y2gtYWN0aW9uXCJdID0gXCJcIiB9IH07XG4gICAgdC5kZWZhdWx0ID0gaSB9LCBmdW5jdGlvbihlLCB0LCBuKSB7IFwidXNlIHN0cmljdFwiO1xuXG4gICAgZnVuY3Rpb24gcihlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfSB9XG5cbiAgICBmdW5jdGlvbiBpKGUsIHQpIHsgdmFyIG4gPSB0LnN0YXRlOyBpZiAoMCAhPT0gbi5pbnB1dHMubGVuZ3RoIHx8IFwic3RhcnRcIiA9PT0gZi5kZWZhdWx0Lm5vcm1hbGl6ZUV2ZW50KGUudHlwZSkpIHsgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGUuYnV0dG9ucyAmJiBcImVuZFwiICE9PSBmLmRlZmF1bHQubm9ybWFsaXplRXZlbnQoZS50eXBlKSAmJiAwID09PSBlLmJ1dHRvbnMpIHJldHVybiB2b2lkIG4ucmVzZXRJbnB1dHMoKTsgaWYgKG4udXBkYXRlSW5wdXRzKGUsIHQuZWxlbWVudCkpIHsgdmFyIHIgPSBuLnJldHJpZXZlQmluZGluZ3NCeUluaXRpYWxQb3MoKTtcbiAgICAgICAgICAgICAgICByLmxlbmd0aCA+IDAgJiYgISBmdW5jdGlvbigpIHsgdC5wcmV2ZW50RGVmYXVsdCA/IChmLmRlZmF1bHQuc2V0TVNQcmV2ZW50RGVmYXVsdCh0LmVsZW1lbnQpLCBlLnByZXZlbnREZWZhdWx0ID8gZS5wcmV2ZW50RGVmYXVsdCgpIDogZS5yZXR1cm5WYWx1ZSA9ICExKSA6IGYuZGVmYXVsdC5yZW1vdmVNU1ByZXZlbnREZWZhdWx0KHQuZWxlbWVudCk7IHZhciBpID0ge30sXG4gICAgICAgICAgICAgICAgICAgICAgICB1ID0gKDAsIHMuZGVmYXVsdCkociwgZSwgbik7XG4gICAgICAgICAgICAgICAgICAgIHUuZm9yRWFjaChmdW5jdGlvbih0KSB7IHZhciBuID0gdC5iaW5kaW5nLmdlc3R1cmUuaWQ7IGlmIChpW25dKSB7IHZhciByID0gZi5kZWZhdWx0LmdldFByb3BhZ2F0aW9uUGF0aChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLmRlZmF1bHQuZ2V0UGF0aEluZGV4KHIsIHQuYmluZGluZy5lbGVtZW50KSA8IGYuZGVmYXVsdC5nZXRQYXRoSW5kZXgociwgaVtuXS5iaW5kaW5nLmVsZW1lbnQpICYmIChpW25dID0gdCkgfSBlbHNlIGlbbl0gPSB0IH0pLCBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSBpW2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIG8uZGVmYXVsdCkodC5iaW5kaW5nLCB0LmRhdGEsIHQuZXZlbnRzKSB9KSB9KCk7IHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICBuLmlucHV0cy5mb3JFYWNoKGZ1bmN0aW9uKGUpIHsgXCJlbmRcIiA9PT0gZS5nZXRDdXJyZW50RXZlbnRUeXBlKCkgJiYgaSsrIH0pLCBpID09PSBuLmlucHV0cy5sZW5ndGggJiYgbi5yZXNldElucHV0cygpIH0gfSB9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7IHZhciB1ID0gbig3KSxcbiAgICAgICAgbyA9IHIodSksXG4gICAgICAgIGEgPSBuKDgpLFxuICAgICAgICBzID0gcihhKSxcbiAgICAgICAgYyA9IG4oNSksXG4gICAgICAgIGYgPSByKGMpO1xuICAgIHQuZGVmYXVsdCA9IGkgfSwgZnVuY3Rpb24oZSwgdCkgeyBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIG4oZSwgdCwgbikgeyB0LmV2ZW50cyA9IG47IHZhciBpID0gbmV3IEN1c3RvbUV2ZW50KGUuZ2VzdHVyZS5nZXRJZCgpLCB7IGRldGFpbDogdCwgYnViYmxlczogITAsIGNhbmNlbGFibGU6ICEwIH0pO1xuICAgICAgICByKGUuZWxlbWVudCwgaSwgZSkgfVxuXG4gICAgZnVuY3Rpb24gcihlLCB0LCBuKSB7IGUuZGlzcGF0Y2hFdmVudCh0KSwgbi5iaW5kT25jZSAmJiBaaW5nVG91Y2gudW5iaW5kKG4uZWxlbWVudCwgbi5nZXN0dXJlLmdldFR5cGUoKSkgfSBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCB0LmRlZmF1bHQgPSBuIH0sIGZ1bmN0aW9uKGUsIHQsIG4pIHsgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiByKGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9IH1cblxuICAgIGZ1bmN0aW9uIGkoZSwgdCwgbikgeyB2YXIgciA9IG8uZGVmYXVsdC5ub3JtYWxpemVFdmVudCh0LnR5cGUpLFxuICAgICAgICAgICAgaSA9IFtdOyByZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSBlLmdlc3R1cmVbcl0obi5pbnB1dHMsIG4sIGUuZWxlbWVudCk7XG4gICAgICAgICAgICB0ICYmICEgZnVuY3Rpb24oKSB7IHZhciByID0gW107XG4gICAgICAgICAgICAgICAgbi5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbihlKSB7IHIucHVzaChlLmN1cnJlbnQpIH0pLCBpLnB1c2goeyBiaW5kaW5nOiBlLCBkYXRhOiB0LCBldmVudHM6IHIgfSkgfSgpIH0pLCBpIH0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTsgdmFyIHUgPSBuKDUpLFxuICAgICAgICBvID0gcih1KTtcbiAgICB0LmRlZmF1bHQgPSBpIH0sIGZ1bmN0aW9uKGUsIHQsIG4pIHsgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiByKGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9IH1cblxuICAgIGZ1bmN0aW9uIGkoZSwgdCkgeyBpZiAoIShlIGluc3RhbmNlb2YgdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIikgfVxuXG4gICAgZnVuY3Rpb24gdShlLCB0KSB7IGZvciAodmFyIG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKylcbiAgICAgICAgICAgIGlmIChlW25dLmlkZW50aWZpZXIgPT09IHQpIHJldHVybiBlW25dOyByZXR1cm4gbnVsbCB9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7IHZhciBvID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24oZSkgeyByZXR1cm4gdHlwZW9mIGUgfSA6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgZS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIGUgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIGUgfSxcbiAgICAgICAgYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZShlLCB0KSB7IGZvciAodmFyIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykgeyB2YXIgciA9IHRbbl07XG4gICAgICAgICAgICAgICAgICAgIHIuZW51bWVyYWJsZSA9IHIuZW51bWVyYWJsZSB8fCAhMSwgci5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIHIgJiYgKHIud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLmtleSwgcikgfSB9IHJldHVybiBmdW5jdGlvbih0LCBuLCByKSB7IHJldHVybiBuICYmIGUodC5wcm90b3R5cGUsIG4pLCByICYmIGUodCwgciksIHQgfSB9KCksXG4gICAgICAgIHMgPSBuKDQpLFxuICAgICAgICBjID0gcihzKSxcbiAgICAgICAgZiA9IG4oMTApLFxuICAgICAgICBsID0gcihmKSxcbiAgICAgICAgZCA9IG4oMTIpLFxuICAgICAgICBwID0gcihkKSxcbiAgICAgICAgaCA9IG4oMTMpLFxuICAgICAgICB5ID0gcihoKSxcbiAgICAgICAgdiA9IG4oMTQpLFxuICAgICAgICBnID0gcih2KSxcbiAgICAgICAgbSA9IG4oMTUpLFxuICAgICAgICBiID0gcihtKSxcbiAgICAgICAgdyA9IG4oMTYpLFxuICAgICAgICBfID0gcih3KSxcbiAgICAgICAgUCA9IG4oMTcpLFxuICAgICAgICBFID0gcihQKSxcbiAgICAgICAgTyA9IG4oMTgpLFxuICAgICAgICB4ID0gcihPKSxcbiAgICAgICAgaiA9IG4oNSksXG4gICAgICAgIEkgPSByKGopLFxuICAgICAgICBrID0gMCxcbiAgICAgICAgTSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZSh0KSB7IGkodGhpcywgZSksIHRoaXMucmVnaW9uSWQgPSB0LCB0aGlzLmlucHV0cyA9IFtdLCB0aGlzLmJpbmRpbmdzID0gW10sIHRoaXMubnVtR2VzdHVyZXMgPSAwLCB0aGlzLnJlZ2lzdGVyZWRHZXN0dXJlcyA9IHt9LCB0aGlzLnJlZ2lzdGVyR2VzdHVyZShuZXcgbC5kZWZhdWx0LCBcImV4cGFuZFwiKSwgdGhpcy5yZWdpc3Rlckdlc3R1cmUobmV3IHAuZGVmYXVsdCwgXCJwYW5cIiksIHRoaXMucmVnaXN0ZXJHZXN0dXJlKG5ldyBnLmRlZmF1bHQsIFwicm90YXRlXCIpLCB0aGlzLnJlZ2lzdGVyR2VzdHVyZShuZXcgeS5kZWZhdWx0LCBcInBpbmNoXCIpLCB0aGlzLnJlZ2lzdGVyR2VzdHVyZShuZXcgYi5kZWZhdWx0LCBcInN3aXBlXCIpLCB0aGlzLnJlZ2lzdGVyR2VzdHVyZShuZXcgXy5kZWZhdWx0LCBcInRhcFwiKSB9IHJldHVybiBhKGUsIFt7IGtleTogXCJhZGRCaW5kaW5nXCIsIHZhbHVlOiBmdW5jdGlvbihlLCB0LCBuLCByLCBpKSB7IHZhciB1ID0gdm9pZCAwOyBpZiAoZSAmJiBcInVuZGVmaW5lZFwiID09IHR5cGVvZiBlLnRhZ05hbWUpIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBlbGVtZW50IGlzIGFuIGludmFsaWQgb2JqZWN0LlwiKTsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgbikgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIGhhbmRsZXIgaXMgaW52YWxpZC5cIik7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiB0ICYmIE9iamVjdC5rZXlzKHRoaXMucmVnaXN0ZXJlZEdlc3R1cmVzKS5pbmRleE9mKHQpID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIFwiICsgdCArIFwiIGlzIG5vdCBhIHJlZ2lzdGVyZWQgZ2VzdHVyZVwiKTsgaWYgKFwib2JqZWN0XCIgPT09IChcInVuZGVmaW5lZFwiID09IHR5cGVvZiB0ID8gXCJ1bmRlZmluZWRcIiA6IG8odCkpICYmICEodCBpbnN0YW5jZW9mIGMuZGVmYXVsdCkpIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBmb3IgdGhlIGdlc3R1cmUgaXMgbm90IG9mIGEgR2VzdHVyZSB0eXBlXCIpOyBcInN0cmluZ1wiID09IHR5cGVvZiB0ID8gdSA9IHRoaXMucmVnaXN0ZXJlZEdlc3R1cmVzW3RdIDogKHUgPSB0LCBcIlwiID09PSB1LmlkICYmIHRoaXMuYXNzaWduR2VzdHVyZUlkKHUpKSwgdGhpcy5iaW5kaW5ncy5wdXNoKG5ldyBFLmRlZmF1bHQoZSwgdSwgbiwgciwgaSkpLCBlLmFkZEV2ZW50TGlzdGVuZXIodS5nZXRJZCgpLCBuLCByKSB9IH0sIHsga2V5OiBcInJldHJpZXZlQmluZGluZ3NCeUVsZW1lbnRcIiwgdmFsdWU6IGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSBbXTsgcmV0dXJuIHRoaXMuYmluZGluZ3MubWFwKGZ1bmN0aW9uKG4pIHsgbi5lbGVtZW50ID09PSBlICYmIHQucHVzaChuKSB9KSwgdCB9IH0sIHsga2V5OiBcInJldHJpZXZlQmluZGluZ3NCeUluaXRpYWxQb3NcIiwgdmFsdWU6IGZ1bmN0aW9uKCkgeyB2YXIgZSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gW107IHJldHVybiB0aGlzLmJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24obikgeyB2YXIgciA9IGUuaW5wdXRzLmZpbHRlcihmdW5jdGlvbihlKSB7IHJldHVybiBJLmRlZmF1bHQuaXNJbnNpZGUoZS5pbml0aWFsLngsIGUuaW5pdGlhbC55LCBuLmVsZW1lbnQpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgci5sZW5ndGggPiAwICYmIHQucHVzaChuKSB9KSwgdCB9IH0sIHsga2V5OiBcInVwZGF0ZUlucHV0c1wiLCB2YWx1ZTogZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBuKGUsIHQsIG4sIHIpIHsgdmFyIGkgPSBJLmRlZmF1bHQubm9ybWFsaXplRXZlbnQoZS50eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gdSh0LmlucHV0cywgbik7IHJldHVybiBcInN0YXJ0XCIgPT09IGkgJiYgbyA/IHZvaWQgdC5yZXNldElucHV0cygpIDogXCJzdGFydFwiICE9PSBpICYmIG8gJiYgIUkuZGVmYXVsdC5pc0luc2lkZShvLmN1cnJlbnQueCwgby5jdXJyZW50LnksIHIpID8gdm9pZCB0LnJlc2V0SW5wdXRzKCkgOiBcInN0YXJ0XCIgPT09IGkgfHwgbyA/IHZvaWQoXCJzdGFydFwiID09PSBpID8gdC5pbnB1dHMucHVzaChuZXcgeC5kZWZhdWx0KGUsIG4pKSA6IG8udXBkYXRlKGUsIG4pKSA6IHZvaWQgdC5yZXNldElucHV0cygpIH0gdmFyIHIgPSBrLFxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGUudG91Y2hlcyA/IFwiVG91Y2hFdmVudFwiIDogZS5wb2ludGVyVHlwZSA/IFwiUG9pbnRlckV2ZW50XCIgOiBcIk1vdXNlRXZlbnRcIjsgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiVG91Y2hFdmVudFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG8gaW4gZS5jaGFuZ2VkVG91Y2hlcykgZS5jaGFuZ2VkVG91Y2hlcy5oYXNPd25Qcm9wZXJ0eShvKSAmJiBJLmRlZmF1bHQuaXNJbnRlZ2VyKHBhcnNlSW50KG8pKSAmJiAociA9IGUuY2hhbmdlZFRvdWNoZXNbb10uaWRlbnRpZmllciwgbihlLCB0aGlzLCByLCB0KSk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlBvaW50ZXJFdmVudFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBlLnBvaW50ZXJJZCwgbihlLCB0aGlzLCByLCB0KTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiTW91c2VFdmVudFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuKGUsIHRoaXMsIGssIHQpIH0gcmV0dXJuICEwIH0gfSwgeyBrZXk6IFwicmVzZXRJbnB1dHNcIiwgdmFsdWU6IGZ1bmN0aW9uKCkgeyB0aGlzLmlucHV0cyA9IFtdIH0gfSwgeyBrZXk6IFwibnVtQWN0aXZlSW5wdXRzXCIsIHZhbHVlOiBmdW5jdGlvbigpIHsgdmFyIGUgPSB0aGlzLmlucHV0cy5maWx0ZXIoZnVuY3Rpb24oZSkgeyByZXR1cm4gXCJlbmRcIiAhPT0gZS5jdXJyZW50LnR5cGUgfSk7IHJldHVybiBlLmxlbmd0aCB9IH0sIHsga2V5OiBcInJlZ2lzdGVyR2VzdHVyZVwiLCB2YWx1ZTogZnVuY3Rpb24oZSwgdCkgeyB0aGlzLmFzc2lnbkdlc3R1cmVJZChlKSwgdGhpcy5yZWdpc3RlcmVkR2VzdHVyZXNbdF0gPSBlIH0gfSwgeyBrZXk6IFwiYXNzaWduR2VzdHVyZUlkXCIsIHZhbHVlOiBmdW5jdGlvbihlKSB7IGUuc2V0SWQodGhpcy5yZWdpb25JZCArIFwiLVwiICsgdGhpcy5udW1HZXN0dXJlcysrKSB9IH1dKSwgZSB9KCk7XG4gICAgdC5kZWZhdWx0ID0gTSB9LCBmdW5jdGlvbihlLCB0LCBuKSB7IFwidXNlIHN0cmljdFwiO1xuXG4gICAgZnVuY3Rpb24gcihlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfSB9XG5cbiAgICBmdW5jdGlvbiBpKGUsIHQpIHsgaWYgKCEoZSBpbnN0YW5jZW9mIHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpIH1cblxuICAgIGZ1bmN0aW9uIHUoZSwgdCkgeyBpZiAoIWUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgcmV0dXJuICF0IHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0ID8gZSA6IHQgfVxuXG4gICAgZnVuY3Rpb24gbyhlLCB0KSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgJiYgbnVsbCAhPT0gdCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2YgdCk7XG4gICAgICAgIGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBlLCBlbnVtZXJhYmxlOiAhMSwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0gfSksIHQgJiYgKE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihlLCB0KSA6IGUuX19wcm90b19fID0gdCkgfSBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pOyB2YXIgYSA9IG4oMTEpLFxuICAgICAgICBzID0gcihhKSxcbiAgICAgICAgYyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHQoZSkgeyBpKHRoaXMsIHQpOyB2YXIgbiA9IHUodGhpcywgKHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSkuY2FsbCh0aGlzLCBlKSk7IHJldHVybiBuLnR5cGUgPSBcImV4cGFuZFwiLCBuIH0gcmV0dXJuIG8odCwgZSksIHQgfShzLmRlZmF1bHQpO1xuICAgIHQuZGVmYXVsdCA9IGMgfSwgZnVuY3Rpb24oZSwgdCwgbikgeyBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIHIoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH0gfVxuXG4gICAgZnVuY3Rpb24gaShlLCB0KSB7IGlmICghKGUgaW5zdGFuY2VvZiB0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKSB9XG5cbiAgICBmdW5jdGlvbiB1KGUsIHQpIHsgaWYgKCFlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IHJldHVybiAhdCB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiB0ICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCA/IGUgOiB0IH1cblxuICAgIGZ1bmN0aW9uIG8oZSwgdCkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0ICYmIG51bGwgIT09IHQpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHQpO1xuICAgICAgICBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogZSwgZW51bWVyYWJsZTogITEsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9IH0pLCB0ICYmIChPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZSwgdCkgOiBlLl9fcHJvdG9fXyA9IHQpIH0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTsgdmFyIGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGUoZSwgdCkgeyBmb3IgKHZhciBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHsgdmFyIHIgPSB0W25dO1xuICAgICAgICAgICAgICAgICAgICByLmVudW1lcmFibGUgPSByLmVudW1lcmFibGUgfHwgITEsIHIuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiByICYmIChyLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgci5rZXksIHIpIH0gfSByZXR1cm4gZnVuY3Rpb24odCwgbiwgcikgeyByZXR1cm4gbiAmJiBlKHQucHJvdG90eXBlLCBuKSwgciAmJiBlKHQsIHIpLCB0IH0gfSgpLFxuICAgICAgICBzID0gbig0KSxcbiAgICAgICAgYyA9IHIocyksXG4gICAgICAgIGYgPSBuKDUpLFxuICAgICAgICBsID0gcihmKSxcbiAgICAgICAgZCA9IDIsXG4gICAgICAgIHAgPSAxLFxuICAgICAgICBoID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gdChlKSB7IGkodGhpcywgdCk7IHZhciBuID0gdSh0aGlzLCAodC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsKHRoaXMpKTsgcmV0dXJuIG4udHlwZSA9IFwiZGlzdGFuY2VcIiwgbi50aHJlc2hvbGQgPSBlICYmIGUudGhyZXNob2xkID8gZS50aHJlc2hvbGQgOiBwLCBuIH0gcmV0dXJuIG8odCwgZSksIGEodCwgW3sga2V5OiBcInN0YXJ0XCIsIHZhbHVlOiBmdW5jdGlvbihlLCB0LCBuKSB7IGlmICghdGhpcy5pc1ZhbGlkKGUsIHQsIG4pKSByZXR1cm4gbnVsbDsgaWYgKGUubGVuZ3RoID09PSBkKSB7IHZhciByID0gZVswXS5nZXRHZXN0dXJlUHJvZ3Jlc3ModGhpcy50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIubGFzdEVtaXR0ZWREaXN0YW5jZSA9IGwuZGVmYXVsdC5kaXN0YW5jZUJldHdlZW5Ud29Qb2ludHMoZVswXS5jdXJyZW50LngsIGVbMV0uY3VycmVudC54LCBlWzBdLmN1cnJlbnQueSwgZVsxXS5jdXJyZW50LnkpIH0gfSB9LCB7IGtleTogXCJtb3ZlXCIsIHZhbHVlOiBmdW5jdGlvbihlLCB0LCBuKSB7IGlmICh0Lm51bUFjdGl2ZUlucHV0cygpID09PSBkKSB7IHZhciByID0gbC5kZWZhdWx0LmRpc3RhbmNlQmV0d2VlblR3b1BvaW50cyhlWzBdLmN1cnJlbnQueCwgZVsxXS5jdXJyZW50LngsIGVbMF0uY3VycmVudC55LCBlWzFdLmN1cnJlbnQueSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGwuZGVmYXVsdC5kaXN0YW5jZUJldHdlZW5Ud29Qb2ludHMoZVswXS5wcmV2aW91cy54LCBlWzFdLnByZXZpb3VzLngsIGVbMF0ucHJldmlvdXMueSwgZVsxXS5wcmV2aW91cy55KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gbC5kZWZhdWx0LmdldE1pZHBvaW50KGVbMF0uY3VycmVudC54LCBlWzFdLmN1cnJlbnQueCwgZVswXS5jdXJyZW50LnksIGVbMV0uY3VycmVudC55KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gZVswXS5nZXRHZXN0dXJlUHJvZ3Jlc3ModGhpcy50eXBlKTsgaWYgKFwiZXhwYW5kXCIgPT09IHRoaXMudHlwZSkgeyBpZiAociA8IGkpIG8ubGFzdEVtaXR0ZWREaXN0YW5jZSA9IHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAociAtIG8ubGFzdEVtaXR0ZWREaXN0YW5jZSA+PSB0aGlzLnRocmVzaG9sZCkgcmV0dXJuIG8ubGFzdEVtaXR0ZWREaXN0YW5jZSA9IHIsIHsgZGlzdGFuY2U6IHIsIGNlbnRlcjogdSB9IH0gZWxzZSBpZiAociA+IGkpIG8ubGFzdEVtaXR0ZWREaXN0YW5jZSA9IHI7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyIDwgaSAmJiBvLmxhc3RFbWl0dGVkRGlzdGFuY2UgLSByID49IHRoaXMudGhyZXNob2xkKSByZXR1cm4gby5sYXN0RW1pdHRlZERpc3RhbmNlID0gciwgeyBkaXN0YW5jZTogciwgY2VudGVyOiB1IH07IHJldHVybiBudWxsIH0gfSB9XSksIHQgfShjLmRlZmF1bHQpO1xuICAgIHQuZGVmYXVsdCA9IGggfSwgZnVuY3Rpb24oZSwgdCwgbikgeyBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIHIoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH0gfVxuXG4gICAgZnVuY3Rpb24gaShlLCB0KSB7IGlmICghKGUgaW5zdGFuY2VvZiB0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKSB9XG5cbiAgICBmdW5jdGlvbiB1KGUsIHQpIHsgaWYgKCFlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IHJldHVybiAhdCB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiB0ICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCA/IGUgOiB0IH1cblxuICAgIGZ1bmN0aW9uIG8oZSwgdCkgeyBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0ICYmIG51bGwgIT09IHQpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHQpO1xuICAgICAgICBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodCAmJiB0LnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogZSwgZW51bWVyYWJsZTogITEsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9IH0pLCB0ICYmIChPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZSwgdCkgOiBlLl9fcHJvdG9fXyA9IHQpIH0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTsgdmFyIGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGUoZSwgdCkgeyBmb3IgKHZhciBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHsgdmFyIHIgPSB0W25dO1xuICAgICAgICAgICAgICAgICAgICByLmVudW1lcmFibGUgPSByLmVudW1lcmFibGUgfHwgITEsIHIuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiByICYmIChyLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgci5rZXksIHIpIH0gfSByZXR1cm4gZnVuY3Rpb24odCwgbiwgcikgeyByZXR1cm4gbiAmJiBlKHQucHJvdG90eXBlLCBuKSwgciAmJiBlKHQsIHIpLCB0IH0gfSgpLFxuICAgICAgICBzID0gbig0KSxcbiAgICAgICAgYyA9IHIocyksXG4gICAgICAgIGYgPSBuKDUpLFxuICAgICAgICBsID0gcihmKSxcbiAgICAgICAgZCA9IDEsXG4gICAgICAgIHAgPSAxLFxuICAgICAgICBoID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gdChlKSB7IGkodGhpcywgdCk7IHZhciBuID0gdSh0aGlzLCAodC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpKS5jYWxsKHRoaXMpKTsgcmV0dXJuIG4udHlwZSA9IFwicGFuXCIsIG4ubnVtSW5wdXRzID0gZSAmJiBlLm51bUlucHV0cyA/IGUubnVtSW5wdXRzIDogZCwgbi50aHJlc2hvbGQgPSBlICYmIGUudGhyZXNob2xkID8gZS50aHJlc2hvbGQgOiBwLCBuIH0gcmV0dXJuIG8odCwgZSksIGEodCwgW3sga2V5OiBcInN0YXJ0XCIsIHZhbHVlOiBmdW5jdGlvbihlKSB7IHZhciB0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgZS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHsgdmFyIG4gPSBlLmdldEdlc3R1cmVQcm9ncmVzcyh0LmdldElkKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbi5hY3RpdmUgPSAhMCwgbi5sYXN0RW1pdHRlZCA9IHsgeDogZS5jdXJyZW50LngsIHk6IGUuY3VycmVudC55IH0gfSkgfSB9LCB7IGtleTogXCJtb3ZlXCIsIHZhbHVlOiBmdW5jdGlvbihlLCB0LCBuKSB7IGlmICh0aGlzLm51bUlucHV0cyA9PT0gZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByID0geyBkYXRhOiBbXSB9LCBpID0gMDsgaSA8IGUubGVuZ3RoOyBpKyspIHsgdmFyIHUgPSBlW2ldLmdldEdlc3R1cmVQcm9ncmVzcyh0aGlzLmdldElkKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gITEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBNYXRoLmFicyhlW2ldLmN1cnJlbnQueSAtIHUubGFzdEVtaXR0ZWQueSkgPiB0aGlzLnRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IE1hdGguYWJzKGVbaV0uY3VycmVudC54IC0gdS5sYXN0RW1pdHRlZC54KSA+IHRoaXMudGhyZXNob2xkOyBpZiAobyA9IGEgfHwgcywgIXUuYWN0aXZlIHx8ICFvKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLmRhdGFbaV0gPSB7IGRpc3RhbmNlRnJvbU9yaWdpbjogbC5kZWZhdWx0LmRpc3RhbmNlQmV0d2VlblR3b1BvaW50cyhlW2ldLmluaXRpYWwueCwgZVtpXS5jdXJyZW50LngsIGVbaV0uaW5pdGlhbC55LCBlW2ldLmN1cnJlbnQueSksIGRpcmVjdGlvbkZyb21PcmlnaW46IGwuZGVmYXVsdC5nZXRBbmdsZShlW2ldLmluaXRpYWwueCwgZVtpXS5pbml0aWFsLnksIGVbaV0uY3VycmVudC54LCBlW2ldLmN1cnJlbnQueSksIGN1cnJlbnREaXJlY3Rpb246IGwuZGVmYXVsdC5nZXRBbmdsZSh1Lmxhc3RFbWl0dGVkLngsIHUubGFzdEVtaXR0ZWQueSwgZVtpXS5jdXJyZW50LngsIGVbaV0uY3VycmVudC55KSB9LCB1Lmxhc3RFbWl0dGVkLnggPSBlW2ldLmN1cnJlbnQueCwgdS5sYXN0RW1pdHRlZC55ID0gZVtpXS5jdXJyZW50LnkgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gciB9IH0sIHsga2V5OiBcImVuZFwiLCB2YWx1ZTogZnVuY3Rpb24oZSkgeyB2YXIgdCA9IHRoaXM7IHJldHVybiBlLmZvckVhY2goZnVuY3Rpb24oZSkgeyB2YXIgbiA9IGUuZ2V0R2VzdHVyZVByb2dyZXNzKHQuZ2V0SWQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLmFjdGl2ZSA9ICExIH0pLCBudWxsIH0gfV0pLCB0IH0oYy5kZWZhdWx0KTtcbiAgICB0LmRlZmF1bHQgPSBoIH0sIGZ1bmN0aW9uKGUsIHQsIG4pIHsgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiByKGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9IH1cblxuICAgIGZ1bmN0aW9uIGkoZSwgdCkgeyBpZiAoIShlIGluc3RhbmNlb2YgdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIikgfVxuXG4gICAgZnVuY3Rpb24gdShlLCB0KSB7IGlmICghZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyByZXR1cm4gIXQgfHwgXCJvYmplY3RcIiAhPSB0eXBlb2YgdCAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgPyBlIDogdCB9XG5cbiAgICBmdW5jdGlvbiBvKGUsIHQpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCAmJiBudWxsICE9PSB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiB0KTtcbiAgICAgICAgZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IGUsIGVudW1lcmFibGU6ICExLCB3cml0YWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAgfSB9KSwgdCAmJiAoT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKGUsIHQpIDogZS5fX3Byb3RvX18gPSB0KSB9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7IHZhciBhID0gbigxMSksXG4gICAgICAgIHMgPSByKGEpLFxuICAgICAgICBjID0gbig1KSxcbiAgICAgICAgZiA9IChyKGMpLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiB0KGUpIHsgaSh0aGlzLCB0KTsgdmFyIG4gPSB1KHRoaXMsICh0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwodGhpcywgZSkpOyByZXR1cm4gbi50eXBlID0gXCJwaW5jaFwiLCBuIH0gcmV0dXJuIG8odCwgZSksIHQgfShzLmRlZmF1bHQpKTtcbiAgICB0LmRlZmF1bHQgPSBmIH0sIGZ1bmN0aW9uKGUsIHQsIG4pIHsgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiByKGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9IH1cblxuICAgIGZ1bmN0aW9uIGkoZSwgdCkgeyBpZiAoIShlIGluc3RhbmNlb2YgdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIikgfVxuXG4gICAgZnVuY3Rpb24gdShlLCB0KSB7IGlmICghZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyByZXR1cm4gIXQgfHwgXCJvYmplY3RcIiAhPSB0eXBlb2YgdCAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgPyBlIDogdCB9XG5cbiAgICBmdW5jdGlvbiBvKGUsIHQpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCAmJiBudWxsICE9PSB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiB0KTtcbiAgICAgICAgZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IGUsIGVudW1lcmFibGU6ICExLCB3cml0YWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAgfSB9KSwgdCAmJiAoT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKGUsIHQpIDogZS5fX3Byb3RvX18gPSB0KSB9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7IHZhciBhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBlKGUsIHQpIHsgZm9yICh2YXIgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7IHZhciByID0gdFtuXTtcbiAgICAgICAgICAgICAgICAgICAgci5lbnVtZXJhYmxlID0gci5lbnVtZXJhYmxlIHx8ICExLCByLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gciAmJiAoci53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIua2V5LCByKSB9IH0gcmV0dXJuIGZ1bmN0aW9uKHQsIG4sIHIpIHsgcmV0dXJuIG4gJiYgZSh0LnByb3RvdHlwZSwgbiksIHIgJiYgZSh0LCByKSwgdCB9IH0oKSxcbiAgICAgICAgcyA9IG4oNCksXG4gICAgICAgIGMgPSByKHMpLFxuICAgICAgICBmID0gbig1KSxcbiAgICAgICAgbCA9IHIoZiksXG4gICAgICAgIGQgPSAyLFxuICAgICAgICBwID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gdCgpIHsgaSh0aGlzLCB0KTsgdmFyIGUgPSB1KHRoaXMsICh0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwodGhpcykpOyByZXR1cm4gZS50eXBlID0gXCJyb3RhdGVcIiwgZSB9IHJldHVybiBvKHQsIGUpLCBhKHQsIFt7IGtleTogXCJtb3ZlXCIsIHZhbHVlOiBmdW5jdGlvbihlLCB0LCBuKSB7IGlmICh0Lm51bUFjdGl2ZUlucHV0cygpIDw9IGQpIHsgdmFyIHIgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSB2b2lkIDA7IGlmICgxID09PSB0Lm51bUFjdGl2ZUlucHV0cygpKSB7IHZhciBhID0gbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0geyB4OiBhLmxlZnQgKyBhLndpZHRoIC8gMiwgeTogYS50b3AgKyBhLmhlaWdodCAvIDIgfSwgbyA9IGVbMF0sIGkgPSB1ID0gMCB9IGVsc2UgeyByID0gbC5kZWZhdWx0LmdldE1pZHBvaW50KGVbMF0uaW5pdGlhbC54LCBlWzFdLmluaXRpYWwueCwgZVswXS5pbml0aWFsLnksIGVbMV0uaW5pdGlhbC55KTsgdmFyIHMgPSBsLmRlZmF1bHQuZ2V0TWlkcG9pbnQoZVswXS5jdXJyZW50LngsIGVbMV0uY3VycmVudC54LCBlWzBdLmN1cnJlbnQueSwgZVsxXS5jdXJyZW50LnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSByLnggLSBzLngsIHUgPSByLnkgLSBzLnksIG8gPSBsLmRlZmF1bHQuZ2V0UmlnaHRNb3N0SW5wdXQoZSkgfSB2YXIgYyA9IGwuZGVmYXVsdC5nZXRBbmdsZShyLngsIHIueSwgby5jdXJyZW50LnggKyBpLCBvLmN1cnJlbnQueSArIHUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBvLmdldEdlc3R1cmVQcm9ncmVzcyh0aGlzLmdldElkKCkpOyByZXR1cm4gZi5pbml0aWFsQW5nbGUgPyAoZi5jaGFuZ2UgPSBsLmRlZmF1bHQuZ2V0QW5ndWxhckRpc3RhbmNlKGYucHJldmlvdXNBbmdsZSwgYyksIGYuZGlzdGFuY2UgPSBmLmRpc3RhbmNlICsgZi5jaGFuZ2UpIDogKGYuaW5pdGlhbEFuZ2xlID0gZi5wcmV2aW91c0FuZ2xlID0gYywgZi5kaXN0YW5jZSA9IGYuY2hhbmdlID0gMCksIGYucHJldmlvdXNBbmdsZSA9IGMsIHsgYW5nbGU6IGMsIGRpc3RhbmNlRnJvbU9yaWdpbjogZi5kaXN0YW5jZSwgZGlzdGFuY2VGcm9tTGFzdDogZi5jaGFuZ2UgfSB9IHJldHVybiBudWxsIH0gfV0pLCB0IH0oYy5kZWZhdWx0KTtcbiAgICB0LmRlZmF1bHQgPSBwIH0sIGZ1bmN0aW9uKGUsIHQsIG4pIHsgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBmdW5jdGlvbiByKGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9IH1cblxuICAgIGZ1bmN0aW9uIGkoZSwgdCkgeyBpZiAoIShlIGluc3RhbmNlb2YgdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIikgfVxuXG4gICAgZnVuY3Rpb24gdShlLCB0KSB7IGlmICghZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyByZXR1cm4gIXQgfHwgXCJvYmplY3RcIiAhPSB0eXBlb2YgdCAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgPyBlIDogdCB9XG5cbiAgICBmdW5jdGlvbiBvKGUsIHQpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCAmJiBudWxsICE9PSB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiB0KTtcbiAgICAgICAgZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHQgJiYgdC5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IGUsIGVudW1lcmFibGU6ICExLCB3cml0YWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAgfSB9KSwgdCAmJiAoT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKGUsIHQpIDogZS5fX3Byb3RvX18gPSB0KSB9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7IHZhciBhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBlKGUsIHQpIHsgZm9yICh2YXIgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7IHZhciByID0gdFtuXTtcbiAgICAgICAgICAgICAgICAgICAgci5lbnVtZXJhYmxlID0gci5lbnVtZXJhYmxlIHx8ICExLCByLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gciAmJiAoci53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIua2V5LCByKSB9IH0gcmV0dXJuIGZ1bmN0aW9uKHQsIG4sIHIpIHsgcmV0dXJuIG4gJiYgZSh0LnByb3RvdHlwZSwgbiksIHIgJiYgZSh0LCByKSwgdCB9IH0oKSxcbiAgICAgICAgcyA9IG4oNCksXG4gICAgICAgIGMgPSByKHMpLFxuICAgICAgICBmID0gbig1KSxcbiAgICAgICAgbCA9IHIoZiksXG4gICAgICAgIGQgPSAxLFxuICAgICAgICBwID0gMTAwLFxuICAgICAgICBoID0gLjIsXG4gICAgICAgIHkgPSAxMDAsXG4gICAgICAgIHYgPSAxMCxcbiAgICAgICAgZyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHQoZSkgeyBpKHRoaXMsIHQpOyB2YXIgbiA9IHUodGhpcywgKHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSkuY2FsbCh0aGlzKSk7IHJldHVybiBuLnR5cGUgPSBcInN3aXBlXCIsIG4ubnVtSW5wdXRzID0gZSAmJiBlLm51bUlucHV0cyA/IGUubnVtSW5wdXRzIDogZCwgbi5tYXhSZXN0VGltZSA9IGUgJiYgZS5tYXhSZXN0VGltZSA/IGUubWF4UmVzdFRpbWUgOiBwLCBuLmVzY2FwZVZlbG9jaXR5ID0gZSAmJiBlLmVzY2FwZVZlbG9jaXR5ID8gZS5lc2NhcGVWZWxvY2l0eSA6IGgsIG4udGltZURpc3RvcnRpb24gPSBlICYmIGUudGltZURpc3RvcnRpb24gPyBlLnRpbWVEaXN0b3J0aW9uIDogeSwgbi5tYXhQcm9ncmVzc1N0YWNrID0gZSAmJiBlLm1heFByb2dyZXNzU3RhY2sgPyBlLm1heFByb2dyZXNzU3RhY2sgOiB2LCBuIH0gcmV0dXJuIG8odCwgZSksIGEodCwgW3sga2V5OiBcIm1vdmVcIiwgdmFsdWU6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgaWYgKHRoaXMubnVtSW5wdXRzID09PSBlLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgZS5sZW5ndGg7IHIrKykgeyB2YXIgaSA9IGVbcl0uZ2V0R2VzdHVyZVByb2dyZXNzKHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS5tb3ZlcyB8fCAoaS5tb3ZlcyA9IFtdKSwgaS5tb3Zlcy5wdXNoKHsgdGltZTogKG5ldyBEYXRlKS5nZXRUaW1lKCksIHg6IGVbcl0uY3VycmVudC54LCB5OiBlW3JdLmN1cnJlbnQueSB9KSwgaS5sZW5ndGggPiB0aGlzLm1heFByb2dyZXNzU3RhY2sgJiYgaS5tb3Zlcy5zaGlmdCgpIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGwgfSB9LCB7IGtleTogXCJlbmRcIiwgdmFsdWU6IGZ1bmN0aW9uKGUpIHsgaWYgKHRoaXMubnVtSW5wdXRzID09PSBlLmxlbmd0aCkgeyBmb3IgKHZhciB0ID0geyBkYXRhOiBbXSB9LCBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHsgaWYgKFwiZW5kXCIgIT09IGVbbl0uY3VycmVudC50eXBlKSByZXR1cm47IHZhciByID0gZVtuXS5nZXRHZXN0dXJlUHJvZ3Jlc3ModGhpcy5nZXRJZCgpKTsgaWYgKHIubW92ZXMgJiYgci5tb3Zlcy5sZW5ndGggPiAyKSB7IHZhciBpID0gci5tb3Zlcy5wb3AoKTsgaWYgKChuZXcgRGF0ZSkuZ2V0VGltZSgpIC0gaS50aW1lID4gdGhpcy5tYXhSZXN0VGltZSkgcmV0dXJuIG51bGw7IGZvciAodmFyIHUgPSB2b2lkIDAsIG8gPSByLm1vdmVzLmxlbmd0aCAtIDE7IG8gIT09IC0xOykgeyBpZiAoci5tb3Zlc1tvXS50aW1lICE9PSBpLnRpbWUpIHsgdSA9IHIubW92ZXNbb107IGJyZWFrIH0gby0tIH0gdSB8fCAodSA9IHIubW92ZXMucG9wKCksIHUudGltZSArPSB0aGlzLnRpbWVEaXN0b3J0aW9uKTsgdmFyIGEgPSBsLmRlZmF1bHQuZ2V0VmVsb2NpdHkodS54LCB1LnksIHUudGltZSwgaS54LCBpLnksIGkudGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuZGF0YVtuXSA9IHsgdmVsb2NpdHk6IGEsIGN1cnJlbnREaXJlY3Rpb246IGwuZGVmYXVsdC5nZXRBbmdsZSh1LngsIHUueSwgaS54LCBpLnkpIH0gfSB9IGZvciAodmFyIG4gPSAwOyBuIDwgdC5kYXRhLmxlbmd0aDsgbisrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhIDwgdGhpcy5lc2NhcGVWZWxvY2l0eSkgcmV0dXJuIG51bGw7IGlmICh0LmRhdGEubGVuZ3RoID4gMCkgcmV0dXJuIHQgfSByZXR1cm4gbnVsbCB9IH1dKSwgdCB9KGMuZGVmYXVsdCk7XG4gICAgdC5kZWZhdWx0ID0gZyB9LCBmdW5jdGlvbihlLCB0LCBuKSB7IFwidXNlIHN0cmljdFwiO1xuXG4gICAgZnVuY3Rpb24gcihlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfSB9XG5cbiAgICBmdW5jdGlvbiBpKGUsIHQpIHsgaWYgKCEoZSBpbnN0YW5jZW9mIHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpIH1cblxuICAgIGZ1bmN0aW9uIHUoZSwgdCkgeyBpZiAoIWUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgcmV0dXJuICF0IHx8IFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiB0ID8gZSA6IHQgfVxuXG4gICAgZnVuY3Rpb24gbyhlLCB0KSB7IGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQgJiYgbnVsbCAhPT0gdCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2YgdCk7XG4gICAgICAgIGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0ICYmIHQucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBlLCBlbnVtZXJhYmxlOiAhMSwgd3JpdGFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwIH0gfSksIHQgJiYgKE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihlLCB0KSA6IGUuX19wcm90b19fID0gdCkgfSBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pOyB2YXIgYSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHR5cGVvZiBlIH0gOiBmdW5jdGlvbihlKSB7IHJldHVybiBlICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIGUuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBlICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBlIH0sXG4gICAgICAgIHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGUoZSwgdCkgeyBmb3IgKHZhciBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHsgdmFyIHIgPSB0W25dO1xuICAgICAgICAgICAgICAgICAgICByLmVudW1lcmFibGUgPSByLmVudW1lcmFibGUgfHwgITEsIHIuY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiByICYmIChyLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgci5rZXksIHIpIH0gfSByZXR1cm4gZnVuY3Rpb24odCwgbiwgcikgeyByZXR1cm4gbiAmJiBlKHQucHJvdG90eXBlLCBuKSwgciAmJiBlKHQsIHIpLCB0IH0gfSgpLFxuICAgICAgICBjID0gbig0KSxcbiAgICAgICAgZiA9IHIoYyksXG4gICAgICAgIGwgPSBuKDUpLFxuICAgICAgICBkID0gcihsKSxcbiAgICAgICAgcCA9IDAsXG4gICAgICAgIGggPSAzMDAsXG4gICAgICAgIHkgPSAxLFxuICAgICAgICB2ID0gMTAsXG4gICAgICAgIGcgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiB0KGUpIHsgaSh0aGlzLCB0KTsgdmFyIG4gPSB1KHRoaXMsICh0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCkpLmNhbGwodGhpcykpOyByZXR1cm4gbi50eXBlID0gXCJ0YXBcIiwgbi5taW5EZWxheSA9IGUgJiYgZS5taW5EZWxheSA/IGUubWluRGVsYXkgOiBwLCBuLm1heERlbGF5ID0gZSAmJiBlLm1heERlbGF5ID8gZS5tYXhEZWxheSA6IGgsIG4ubnVtSW5wdXRzID0gZSAmJiBlLm51bUlucHV0cyA/IGUubnVtSW5wdXRzIDogeSwgbi50b2xlcmFuY2UgPSBlICYmIGUudG9sZXJhbmNlID8gZS50b2xlcmFuY2UgOiB2LCBuIH0gcmV0dXJuIG8odCwgZSksIHModCwgW3sga2V5OiBcInN0YXJ0XCIsIHZhbHVlOiBmdW5jdGlvbihlKSB7IHZhciB0ID0gdGhpczsgcmV0dXJuIGUubGVuZ3RoID09PSB0aGlzLm51bUlucHV0cyAmJiBlLmZvckVhY2goZnVuY3Rpb24oZSkgeyB2YXIgbiA9IGUuZ2V0R2VzdHVyZVByb2dyZXNzKHQudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuLnN0YXJ0ID0gKG5ldyBEYXRlKS5nZXRUaW1lKCkgfSksIG51bGwgfSB9LCB7IGtleTogXCJtb3ZlXCIsIHZhbHVlOiBmdW5jdGlvbihlLCB0LCBuKSB7IGZvciAodmFyIHIgPSB0aGlzLCBpID0gMDsgaSA8IGUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJtb3ZlXCIgPT09IGVbaV0uZ2V0Q3VycmVudEV2ZW50VHlwZSgpKSB7IHZhciB1ID0gZVtpXS5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gZVtpXS5wcmV2aW91czsgaWYgKCFkLmRlZmF1bHQuaXNXaXRoaW4odS54LCB1LnksIG8ueCwgby55LCB0aGlzLnRvbGVyYW5jZSkpIHsgdmFyIHMgPSBmdW5jdGlvbigpIHsgdmFyIHQgPSByLnR5cGU7IHJldHVybiBlLmZvckVhY2goZnVuY3Rpb24oZSkgeyBlLnJlc2V0UHJvZ3Jlc3ModCkgfSksIHsgdjogbnVsbCB9IH0oKTsgaWYgKFwib2JqZWN0XCIgPT09IChcInVuZGVmaW5lZFwiID09IHR5cGVvZiBzID8gXCJ1bmRlZmluZWRcIiA6IGEocykpKSByZXR1cm4gcy52IH0gfSByZXR1cm4gbnVsbCB9IH0sIHsga2V5OiBcImVuZFwiLCB2YWx1ZTogZnVuY3Rpb24oZSkgeyB2YXIgdCA9IHRoaXM7IGlmIChlLmxlbmd0aCAhPT0gdGhpcy5udW1JbnB1dHMpIHJldHVybiBudWxsOyBmb3IgKHZhciBuID0gTnVtYmVyLk1BWF9WQUxVRSwgciA9IDA7IHIgPCBlLmxlbmd0aDsgcisrKSB7IGlmIChcImVuZFwiICE9PSBlW3JdLmdldEN1cnJlbnRFdmVudFR5cGUoKSkgcmV0dXJuIG51bGw7IHZhciBpID0gZVtyXS5nZXRHZXN0dXJlUHJvZ3Jlc3ModGhpcy50eXBlKTsgaWYgKCFpLnN0YXJ0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkuc3RhcnQgPCBuICYmIChuID0gaS5zdGFydCkgfSB2YXIgdSA9IChuZXcgRGF0ZSkuZ2V0VGltZSgpIC0gbjsgaWYgKHRoaXMubWluRGVsYXkgPD0gdSAmJiB0aGlzLm1heERlbGF5ID49IHUpIHJldHVybiB7IGludGVydmFsOiB1IH07IHZhciBvID0gZnVuY3Rpb24oKSB7IHZhciBuID0gdC50eXBlOyByZXR1cm4gZS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHsgZS5yZXNldFByb2dyZXNzKG4pIH0pLCB7IHY6IG51bGwgfSB9KCk7IHJldHVybiBcIm9iamVjdFwiID09PSAoXCJ1bmRlZmluZWRcIiA9PSB0eXBlb2YgbyA/IFwidW5kZWZpbmVkXCIgOiBhKG8pKSA/IG8udiA6IHZvaWQgMCB9IH1dKSwgdCB9KGYuZGVmYXVsdCk7XG4gICAgdC5kZWZhdWx0ID0gZyB9LCBmdW5jdGlvbihlLCB0KSB7IFwidXNlIHN0cmljdFwiO1xuXG4gICAgZnVuY3Rpb24gbihlLCB0KSB7IGlmICghKGUgaW5zdGFuY2VvZiB0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKSB9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7IHZhciByID0gZnVuY3Rpb24gZSh0LCByLCBpLCB1LCBvKSB7IG4odGhpcywgZSksIHRoaXMuZWxlbWVudCA9IHQsIHRoaXMuZ2VzdHVyZSA9IHIsIHRoaXMuaGFuZGxlciA9IGksIHRoaXMuY2FwdHVyZSA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHUgJiYgdSwgdGhpcy5iaW5kT25jZSA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIG8gJiYgbyB9O1xuICAgIHQuZGVmYXVsdCA9IHIgfSwgZnVuY3Rpb24oZSwgdCwgbikgeyBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIHIoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH0gfVxuXG4gICAgZnVuY3Rpb24gaShlLCB0KSB7IGlmICghKGUgaW5zdGFuY2VvZiB0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKSB9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7IHZhciB1ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBlKGUsIHQpIHsgZm9yICh2YXIgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7IHZhciByID0gdFtuXTtcbiAgICAgICAgICAgICAgICAgICAgci5lbnVtZXJhYmxlID0gci5lbnVtZXJhYmxlIHx8ICExLCByLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gciAmJiAoci53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIua2V5LCByKSB9IH0gcmV0dXJuIGZ1bmN0aW9uKHQsIG4sIHIpIHsgcmV0dXJuIG4gJiYgZSh0LnByb3RvdHlwZSwgbiksIHIgJiYgZSh0LCByKSwgdCB9IH0oKSxcbiAgICAgICAgbyA9IG4oMTkpLFxuICAgICAgICBhID0gcihvKSxcbiAgICAgICAgcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZSh0LCBuKSB7IGkodGhpcywgZSk7IHZhciByID0gbmV3IGEuZGVmYXVsdCh0LCBuKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWwgPSByLCB0aGlzLmN1cnJlbnQgPSByLCB0aGlzLnByZXZpb3VzID0gciwgdGhpcy5pZGVudGlmaWVyID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgbiA/IG4gOiAwLCB0aGlzLnByb2dyZXNzID0ge30gfSByZXR1cm4gdShlLCBbeyBrZXk6IFwidXBkYXRlXCIsIHZhbHVlOiBmdW5jdGlvbihlLCB0KSB7IHRoaXMucHJldmlvdXMgPSB0aGlzLmN1cnJlbnQsIHRoaXMuY3VycmVudCA9IG5ldyBhLmRlZmF1bHQoZSwgdCkgfSB9LCB7IGtleTogXCJnZXRHZXN0dXJlUHJvZ3Jlc3NcIiwgdmFsdWU6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHRoaXMucHJvZ3Jlc3NbZV0gfHwgKHRoaXMucHJvZ3Jlc3NbZV0gPSB7fSksIHRoaXMucHJvZ3Jlc3NbZV0gfSB9LCB7IGtleTogXCJnZXRDdXJyZW50RXZlbnRUeXBlXCIsIHZhbHVlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY3VycmVudC50eXBlIH0gfSwgeyBrZXk6IFwicmVzZXRQcm9ncmVzc1wiLCB2YWx1ZTogZnVuY3Rpb24oZSkgeyB0aGlzLnByb2dyZXNzW2VdID0ge30gfSB9XSksIGUgfSgpO1xuICAgIHQuZGVmYXVsdCA9IHMgfSwgZnVuY3Rpb24oZSwgdCwgbikgeyBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uIHIoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH0gfVxuXG4gICAgZnVuY3Rpb24gaShlLCB0KSB7IGlmICghKGUgaW5zdGFuY2VvZiB0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKSB9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7IHZhciB1ID0gbig1KSxcbiAgICAgICAgbyA9IHIodSksXG4gICAgICAgIGEgPSAwLFxuICAgICAgICBzID0gZnVuY3Rpb24gZSh0LCBuKSB7IGkodGhpcywgZSksIHRoaXMub3JpZ2luYWxFdmVudCA9IHQsIHRoaXMudHlwZSA9IG8uZGVmYXVsdC5ub3JtYWxpemVFdmVudCh0LnR5cGUpLCB0aGlzLnggPSBhLCB0aGlzLnkgPSBhOyB2YXIgciA9IHZvaWQgMDsgaWYgKHQudG91Y2hlcyAmJiB0LmNoYW5nZWRUb3VjaGVzKSB7IGZvciAodmFyIHUgPSAwOyB1IDwgdC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IHUrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQuY2hhbmdlZFRvdWNoZXNbdV0uaWRlbnRpZmllciA9PT0gbikgeyByID0gdC5jaGFuZ2VkVG91Y2hlc1t1XTsgYnJlYWsgfSB9IGVsc2UgciA9IHQ7XG4gICAgICAgICAgICB0aGlzLnggPSB0aGlzLmNsaWVudFggPSByLmNsaWVudFgsIHRoaXMueSA9IHRoaXMuY2xpZW50WSA9IHIuY2xpZW50WSwgdGhpcy5wYWdlWCA9IHIucGFnZVgsIHRoaXMucGFnZVkgPSByLnBhZ2VZLCB0aGlzLnNjcmVlblggPSByLnNjcmVlblgsIHRoaXMuc2NyZWVuWSA9IHIuc2NyZWVuWSB9O1xuICAgIHQuZGVmYXVsdCA9IHMgfV0pOyJdLCJmaWxlIjoiemluZ3RvdWNoLm1pbi5qcyJ9
