/*! jQuery UI - v1.12.1 - 2017-06-01
 * http://jqueryui.com
 * Includes: widget.js, position.js, keycode.js, unique-id.js, widgets/autocomplete.js, widgets/menu.js, effect.js, effects/effect-slide.js
 * Copyright jQuery Foundation and other contributors; Licensed MIT */

(function(t) { "function" == typeof define && define.amd ? define(["jquery"], t) : t(jQuery) })(function(t) {
    t.ui = t.ui || {}, t.ui.version = "1.12.1";
    var e = 0,
        i = Array.prototype.slice;
    t.cleanData = function(e) { return function(i) { var s, n, o; for (o = 0; null != (n = i[o]); o++) try { s = t._data(n, "events"), s && s.remove && t(n).triggerHandler("remove") } catch (a) {} e(i) } }(t.cleanData), t.widget = function(e, i, s) { var n, o, a, r = {},
                l = e.split(".")[0];
            e = e.split(".")[1]; var h = l + "-" + e; return s || (s = i, i = t.Widget), t.isArray(s) && (s = t.extend.apply(null, [{}].concat(s))), t.expr[":"][h.toLowerCase()] = function(e) { return !!t.data(e, h) }, t[l] = t[l] || {}, n = t[l][e], o = t[l][e] = function(t, e) { return this._createWidget ? (arguments.length && this._createWidget(t, e), void 0) : new o(t, e) }, t.extend(o, n, { version: s.version, _proto: t.extend({}, s), _childConstructors: [] }), a = new i, a.options = t.widget.extend({}, a.options), t.each(s, function(e, s) { return t.isFunction(s) ? (r[e] = function() {
                    function t() { return i.prototype[e].apply(this, arguments) }

                    function n(t) { return i.prototype[e].apply(this, t) } return function() { var e, i = this._super,
                            o = this._superApply; return this._super = t, this._superApply = n, e = s.apply(this, arguments), this._super = i, this._superApply = o, e } }(), void 0) : (r[e] = s, void 0) }), o.prototype = t.widget.extend(a, { widgetEventPrefix: n ? a.widgetEventPrefix || e : e }, r, { constructor: o, namespace: l, widgetName: e, widgetFullName: h }), n ? (t.each(n._childConstructors, function(e, i) { var s = i.prototype;
                t.widget(s.namespace + "." + s.widgetName, o, i._proto) }), delete n._childConstructors) : i._childConstructors.push(o), t.widget.bridge(e, o), o }, t.widget.extend = function(e) { for (var s, n, o = i.call(arguments, 1), a = 0, r = o.length; r > a; a++)
                for (s in o[a]) n = o[a][s], o[a].hasOwnProperty(s) && void 0 !== n && (e[s] = t.isPlainObject(n) ? t.isPlainObject(e[s]) ? t.widget.extend({}, e[s], n) : t.widget.extend({}, n) : n); return e }, t.widget.bridge = function(e, s) { var n = s.prototype.widgetFullName || e;
            t.fn[e] = function(o) { var a = "string" == typeof o,
                    r = i.call(arguments, 1),
                    l = this; return a ? this.length || "instance" !== o ? this.each(function() { var i, s = t.data(this, n); return "instance" === o ? (l = s, !1) : s ? t.isFunction(s[o]) && "_" !== o.charAt(0) ? (i = s[o].apply(s, r), i !== s && void 0 !== i ? (l = i && i.jquery ? l.pushStack(i.get()) : i, !1) : void 0) : t.error("no such method '" + o + "' for " + e + " widget instance") : t.error("cannot call methods on " + e + " prior to initialization; " + "attempted to call method '" + o + "'") }) : l = void 0 : (r.length && (o = t.widget.extend.apply(null, [o].concat(r))), this.each(function() { var e = t.data(this, n);
                    e ? (e.option(o || {}), e._init && e._init()) : t.data(this, n, new s(o, this)) })), l } }, t.Widget = function() {}, t.Widget._childConstructors = [], t.Widget.prototype = { widgetName: "widget", widgetEventPrefix: "", defaultElement: "<div>", options: { classes: {}, disabled: !1, create: null }, _createWidget: function(i, s) { s = t(s || this.defaultElement || this)[0], this.element = t(s), this.uuid = e++, this.eventNamespace = "." + this.widgetName + this.uuid, this.bindings = t(), this.hoverable = t(), this.focusable = t(), this.classesElementLookup = {}, s !== this && (t.data(s, this.widgetFullName, this), this._on(!0, this.element, { remove: function(t) { t.target === s && this.destroy() } }), this.document = t(s.style ? s.ownerDocument : s.document || s), this.window = t(this.document[0].defaultView || this.document[0].parentWindow)), this.options = t.widget.extend({}, this.options, this._getCreateOptions(), i), this._create(), this.options.disabled && this._setOptionDisabled(this.options.disabled), this._trigger("create", null, this._getCreateEventData()), this._init() }, _getCreateOptions: function() { return {} }, _getCreateEventData: t.noop, _create: t.noop, _init: t.noop, destroy: function() { var e = this;
                this._destroy(), t.each(this.classesElementLookup, function(t, i) { e._removeClass(i, t) }), this.element.off(this.eventNamespace).removeData(this.widgetFullName), this.widget().off(this.eventNamespace).removeAttr("aria-disabled"), this.bindings.off(this.eventNamespace) }, _destroy: t.noop, widget: function() { return this.element }, option: function(e, i) { var s, n, o, a = e; if (0 === arguments.length) return t.widget.extend({}, this.options); if ("string" == typeof e)
                    if (a = {}, s = e.split("."), e = s.shift(), s.length) { for (n = a[e] = t.widget.extend({}, this.options[e]), o = 0; s.length - 1 > o; o++) n[s[o]] = n[s[o]] || {}, n = n[s[o]]; if (e = s.pop(), 1 === arguments.length) return void 0 === n[e] ? null : n[e];
                        n[e] = i } else { if (1 === arguments.length) return void 0 === this.options[e] ? null : this.options[e];
                        a[e] = i } return this._setOptions(a), this }, _setOptions: function(t) { var e; for (e in t) this._setOption(e, t[e]); return this }, _setOption: function(t, e) { return "classes" === t && this._setOptionClasses(e), this.options[t] = e, "disabled" === t && this._setOptionDisabled(e), this }, _setOptionClasses: function(e) { var i, s, n; for (i in e) n = this.classesElementLookup[i], e[i] !== this.options.classes[i] && n && n.length && (s = t(n.get()), this._removeClass(n, i), s.addClass(this._classes({ element: s, keys: i, classes: e, add: !0 }))) }, _setOptionDisabled: function(t) { this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!t), t && (this._removeClass(this.hoverable, null, "ui-state-hover"), this._removeClass(this.focusable, null, "ui-state-focus")) }, enable: function() { return this._setOptions({ disabled: !1 }) }, disable: function() { return this._setOptions({ disabled: !0 }) }, _classes: function(e) {
                function i(i, o) { var a, r; for (r = 0; i.length > r; r++) a = n.classesElementLookup[i[r]] || t(), a = e.add ? t(t.unique(a.get().concat(e.element.get()))) : t(a.not(e.element).get()), n.classesElementLookup[i[r]] = a, s.push(i[r]), o && e.classes[i[r]] && s.push(e.classes[i[r]]) } var s = [],
                    n = this; return e = t.extend({ element: this.element, classes: this.options.classes || {} }, e), this._on(e.element, { remove: "_untrackClassesElement" }), e.keys && i(e.keys.match(/\S+/g) || [], !0), e.extra && i(e.extra.match(/\S+/g) || []), s.join(" ") }, _untrackClassesElement: function(e) { var i = this;
                t.each(i.classesElementLookup, function(s, n) {-1 !== t.inArray(e.target, n) && (i.classesElementLookup[s] = t(n.not(e.target).get())) }) }, _removeClass: function(t, e, i) { return this._toggleClass(t, e, i, !1) }, _addClass: function(t, e, i) { return this._toggleClass(t, e, i, !0) }, _toggleClass: function(t, e, i, s) { s = "boolean" == typeof s ? s : i; var n = "string" == typeof t || null === t,
                    o = { extra: n ? e : i, keys: n ? t : e, element: n ? this.element : t, add: s }; return o.element.toggleClass(this._classes(o), s), this }, _on: function(e, i, s) { var n, o = this; "boolean" != typeof e && (s = i, i = e, e = !1), s ? (i = n = t(i), this.bindings = this.bindings.add(i)) : (s = i, i = this.element, n = this.widget()), t.each(s, function(s, a) {
                    function r() { return e || o.options.disabled !== !0 && !t(this).hasClass("ui-state-disabled") ? ("string" == typeof a ? o[a] : a).apply(o, arguments) : void 0 } "string" != typeof a && (r.guid = a.guid = a.guid || r.guid || t.guid++); var l = s.match(/^([\w:-]*)\s*(.*)$/),
                        h = l[1] + o.eventNamespace,
                        c = l[2];
                    c ? n.on(h, c, r) : i.on(h, r) }) }, _off: function(e, i) { i = (i || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, e.off(i).off(i), this.bindings = t(this.bindings.not(e).get()), this.focusable = t(this.focusable.not(e).get()), this.hoverable = t(this.hoverable.not(e).get()) }, _delay: function(t, e) {
                function i() { return ("string" == typeof t ? s[t] : t).apply(s, arguments) } var s = this; return setTimeout(i, e || 0) }, _hoverable: function(e) { this.hoverable = this.hoverable.add(e), this._on(e, { mouseenter: function(e) { this._addClass(t(e.currentTarget), null, "ui-state-hover") }, mouseleave: function(e) { this._removeClass(t(e.currentTarget), null, "ui-state-hover") } }) }, _focusable: function(e) { this.focusable = this.focusable.add(e), this._on(e, { focusin: function(e) { this._addClass(t(e.currentTarget), null, "ui-state-focus") }, focusout: function(e) { this._removeClass(t(e.currentTarget), null, "ui-state-focus") } }) }, _trigger: function(e, i, s) { var n, o, a = this.options[e]; if (s = s || {}, i = t.Event(i), i.type = (e === this.widgetEventPrefix ? e : this.widgetEventPrefix + e).toLowerCase(), i.target = this.element[0], o = i.originalEvent)
                    for (n in o) n in i || (i[n] = o[n]); return this.element.trigger(i, s), !(t.isFunction(a) && a.apply(this.element[0], [i].concat(s)) === !1 || i.isDefaultPrevented()) } }, t.each({ show: "fadeIn", hide: "fadeOut" }, function(e, i) { t.Widget.prototype["_" + e] = function(s, n, o) { "string" == typeof n && (n = { effect: n }); var a, r = n ? n === !0 || "number" == typeof n ? i : n.effect || i : e;
                n = n || {}, "number" == typeof n && (n = { duration: n }), a = !t.isEmptyObject(n), n.complete = o, n.delay && s.delay(n.delay), a && t.effects && t.effects.effect[r] ? s[e](n) : r !== e && s[r] ? s[r](n.duration, n.easing, o) : s.queue(function(i) { t(this)[e](), o && o.call(s[0]), i() }) } }), t.widget,
        function() {
            function e(t, e, i) { return [parseFloat(t[0]) * (u.test(t[0]) ? e / 100 : 1), parseFloat(t[1]) * (u.test(t[1]) ? i / 100 : 1)] }

            function i(e, i) { return parseInt(t.css(e, i), 10) || 0 }

            function s(e) { var i = e[0]; return 9 === i.nodeType ? { width: e.width(), height: e.height(), offset: { top: 0, left: 0 } } : t.isWindow(i) ? { width: e.width(), height: e.height(), offset: { top: e.scrollTop(), left: e.scrollLeft() } } : i.preventDefault ? { width: 0, height: 0, offset: { top: i.pageY, left: i.pageX } } : { width: e.outerWidth(), height: e.outerHeight(), offset: e.offset() } } var n, o = Math.max,
                a = Math.abs,
                r = /left|center|right/,
                l = /top|center|bottom/,
                h = /[\+\-]\d+(\.[\d]+)?%?/,
                c = /^\w+/,
                u = /%$/,
                d = t.fn.position;
            t.position = { scrollbarWidth: function() { if (void 0 !== n) return n; var e, i, s = t("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),
                        o = s.children()[0]; return t("body").append(s), e = o.offsetWidth, s.css("overflow", "scroll"), i = o.offsetWidth, e === i && (i = s[0].clientWidth), s.remove(), n = e - i }, getScrollInfo: function(e) { var i = e.isWindow || e.isDocument ? "" : e.element.css("overflow-x"),
                        s = e.isWindow || e.isDocument ? "" : e.element.css("overflow-y"),
                        n = "scroll" === i || "auto" === i && e.width < e.element[0].scrollWidth,
                        o = "scroll" === s || "auto" === s && e.height < e.element[0].scrollHeight; return { width: o ? t.position.scrollbarWidth() : 0, height: n ? t.position.scrollbarWidth() : 0 } }, getWithinInfo: function(e) { var i = t(e || window),
                        s = t.isWindow(i[0]),
                        n = !!i[0] && 9 === i[0].nodeType,
                        o = !s && !n; return { element: i, isWindow: s, isDocument: n, offset: o ? t(e).offset() : { left: 0, top: 0 }, scrollLeft: i.scrollLeft(), scrollTop: i.scrollTop(), width: i.outerWidth(), height: i.outerHeight() } } }, t.fn.position = function(n) { if (!n || !n.of) return d.apply(this, arguments);
                n = t.extend({}, n); var u, p, f, g, m, _, v = t(n.of),
                    b = t.position.getWithinInfo(n.within),
                    y = t.position.getScrollInfo(b),
                    w = (n.collision || "flip").split(" "),
                    k = {}; return _ = s(v), v[0].preventDefault && (n.at = "left top"), p = _.width, f = _.height, g = _.offset, m = t.extend({}, g), t.each(["my", "at"], function() { var t, e, i = (n[this] || "").split(" ");
                    1 === i.length && (i = r.test(i[0]) ? i.concat(["center"]) : l.test(i[0]) ? ["center"].concat(i) : ["center", "center"]), i[0] = r.test(i[0]) ? i[0] : "center", i[1] = l.test(i[1]) ? i[1] : "center", t = h.exec(i[0]), e = h.exec(i[1]), k[this] = [t ? t[0] : 0, e ? e[0] : 0], n[this] = [c.exec(i[0])[0], c.exec(i[1])[0]] }), 1 === w.length && (w[1] = w[0]), "right" === n.at[0] ? m.left += p : "center" === n.at[0] && (m.left += p / 2), "bottom" === n.at[1] ? m.top += f : "center" === n.at[1] && (m.top += f / 2), u = e(k.at, p, f), m.left += u[0], m.top += u[1], this.each(function() { var s, r, l = t(this),
                        h = l.outerWidth(),
                        c = l.outerHeight(),
                        d = i(this, "marginLeft"),
                        _ = i(this, "marginTop"),
                        x = h + d + i(this, "marginRight") + y.width,
                        C = c + _ + i(this, "marginBottom") + y.height,
                        D = t.extend({}, m),
                        T = e(k.my, l.outerWidth(), l.outerHeight()); "right" === n.my[0] ? D.left -= h : "center" === n.my[0] && (D.left -= h / 2), "bottom" === n.my[1] ? D.top -= c : "center" === n.my[1] && (D.top -= c / 2), D.left += T[0], D.top += T[1], s = { marginLeft: d, marginTop: _ }, t.each(["left", "top"], function(e, i) { t.ui.position[w[e]] && t.ui.position[w[e]][i](D, { targetWidth: p, targetHeight: f, elemWidth: h, elemHeight: c, collisionPosition: s, collisionWidth: x, collisionHeight: C, offset: [u[0] + T[0], u[1] + T[1]], my: n.my, at: n.at, within: b, elem: l }) }), n.using && (r = function(t) { var e = g.left - D.left,
                            i = e + p - h,
                            s = g.top - D.top,
                            r = s + f - c,
                            u = { target: { element: v, left: g.left, top: g.top, width: p, height: f }, element: { element: l, left: D.left, top: D.top, width: h, height: c }, horizontal: 0 > i ? "left" : e > 0 ? "right" : "center", vertical: 0 > r ? "top" : s > 0 ? "bottom" : "middle" };
                        h > p && p > a(e + i) && (u.horizontal = "center"), c > f && f > a(s + r) && (u.vertical = "middle"), u.important = o(a(e), a(i)) > o(a(s), a(r)) ? "horizontal" : "vertical", n.using.call(this, t, u) }), l.offset(t.extend(D, { using: r })) }) }, t.ui.position = { fit: { left: function(t, e) { var i, s = e.within,
                            n = s.isWindow ? s.scrollLeft : s.offset.left,
                            a = s.width,
                            r = t.left - e.collisionPosition.marginLeft,
                            l = n - r,
                            h = r + e.collisionWidth - a - n;
                        e.collisionWidth > a ? l > 0 && 0 >= h ? (i = t.left + l + e.collisionWidth - a - n, t.left += l - i) : t.left = h > 0 && 0 >= l ? n : l > h ? n + a - e.collisionWidth : n : l > 0 ? t.left += l : h > 0 ? t.left -= h : t.left = o(t.left - r, t.left) }, top: function(t, e) { var i, s = e.within,
                            n = s.isWindow ? s.scrollTop : s.offset.top,
                            a = e.within.height,
                            r = t.top - e.collisionPosition.marginTop,
                            l = n - r,
                            h = r + e.collisionHeight - a - n;
                        e.collisionHeight > a ? l > 0 && 0 >= h ? (i = t.top + l + e.collisionHeight - a - n, t.top += l - i) : t.top = h > 0 && 0 >= l ? n : l > h ? n + a - e.collisionHeight : n : l > 0 ? t.top += l : h > 0 ? t.top -= h : t.top = o(t.top - r, t.top) } }, flip: { left: function(t, e) { var i, s, n = e.within,
                            o = n.offset.left + n.scrollLeft,
                            r = n.width,
                            l = n.isWindow ? n.scrollLeft : n.offset.left,
                            h = t.left - e.collisionPosition.marginLeft,
                            c = h - l,
                            u = h + e.collisionWidth - r - l,
                            d = "left" === e.my[0] ? -e.elemWidth : "right" === e.my[0] ? e.elemWidth : 0,
                            p = "left" === e.at[0] ? e.targetWidth : "right" === e.at[0] ? -e.targetWidth : 0,
                            f = -2 * e.offset[0];
                        0 > c ? (i = t.left + d + p + f + e.collisionWidth - r - o, (0 > i || a(c) > i) && (t.left += d + p + f)) : u > 0 && (s = t.left - e.collisionPosition.marginLeft + d + p + f - l, (s > 0 || u > a(s)) && (t.left += d + p + f)) }, top: function(t, e) { var i, s, n = e.within,
                            o = n.offset.top + n.scrollTop,
                            r = n.height,
                            l = n.isWindow ? n.scrollTop : n.offset.top,
                            h = t.top - e.collisionPosition.marginTop,
                            c = h - l,
                            u = h + e.collisionHeight - r - l,
                            d = "top" === e.my[1],
                            p = d ? -e.elemHeight : "bottom" === e.my[1] ? e.elemHeight : 0,
                            f = "top" === e.at[1] ? e.targetHeight : "bottom" === e.at[1] ? -e.targetHeight : 0,
                            g = -2 * e.offset[1];
                        0 > c ? (s = t.top + p + f + g + e.collisionHeight - r - o, (0 > s || a(c) > s) && (t.top += p + f + g)) : u > 0 && (i = t.top - e.collisionPosition.marginTop + p + f + g - l, (i > 0 || u > a(i)) && (t.top += p + f + g)) } }, flipfit: { left: function() { t.ui.position.flip.left.apply(this, arguments), t.ui.position.fit.left.apply(this, arguments) }, top: function() { t.ui.position.flip.top.apply(this, arguments), t.ui.position.fit.top.apply(this, arguments) } } } }(), t.ui.position, t.ui.keyCode = { BACKSPACE: 8, COMMA: 188, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, LEFT: 37, PAGE_DOWN: 34, PAGE_UP: 33, PERIOD: 190, RIGHT: 39, SPACE: 32, TAB: 9, UP: 38 }, t.fn.extend({ uniqueId: function() { var t = 0; return function() { return this.each(function() { this.id || (this.id = "ui-id-" + ++t) }) } }(), removeUniqueId: function() { return this.each(function() { /^ui-id-\d+$/.test(this.id) && t(this).removeAttr("id") }) } }), t.ui.safeActiveElement = function(t) { var e; try { e = t.activeElement } catch (i) { e = t.body } return e || (e = t.body), e.nodeName || (e = t.body), e }, t.widget("ui.menu", { version: "1.12.1", defaultElement: "<ul>", delay: 300, options: { icons: { submenu: "ui-icon-caret-1-e" }, items: "> *", menus: "ul", position: { my: "left top", at: "right top" }, role: "menu", blur: null, focus: null, select: null }, _create: function() { this.activeMenu = this.element, this.mouseHandled = !1, this.element.uniqueId().attr({ role: this.options.role, tabIndex: 0 }), this._addClass("ui-menu", "ui-widget ui-widget-content"), this._on({ "mousedown .ui-menu-item": function(t) { t.preventDefault() }, "click .ui-menu-item": function(e) { var i = t(e.target),
                            s = t(t.ui.safeActiveElement(this.document[0]));!this.mouseHandled && i.not(".ui-state-disabled").length && (this.select(e), e.isPropagationStopped() || (this.mouseHandled = !0), i.has(".ui-menu").length ? this.expand(e) : !this.element.is(":focus") && s.closest(".ui-menu").length && (this.element.trigger("focus", [!0]), this.active && 1 === this.active.parents(".ui-menu").length && clearTimeout(this.timer))) }, "mouseenter .ui-menu-item": function(e) { if (!this.previousFilter) { var i = t(e.target).closest(".ui-menu-item"),
                                s = t(e.currentTarget);
                            i[0] === s[0] && (this._removeClass(s.siblings().children(".ui-state-active"), null, "ui-state-active"), this.focus(e, s)) } }, mouseleave: "collapseAll", "mouseleave .ui-menu": "collapseAll", focus: function(t, e) { var i = this.active || this.element.find(this.options.items).eq(0);
                        e || this.focus(t, i) }, blur: function(e) { this._delay(function() { var i = !t.contains(this.element[0], t.ui.safeActiveElement(this.document[0]));
                            i && this.collapseAll(e) }) }, keydown: "_keydown" }), this.refresh(), this._on(this.document, { click: function(t) { this._closeOnDocumentClick(t) && this.collapseAll(t), this.mouseHandled = !1 } }) }, _destroy: function() { var e = this.element.find(".ui-menu-item").removeAttr("role aria-disabled"),
                    i = e.children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");
                this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex").removeUniqueId().show(), i.children().each(function() { var e = t(this);
                    e.data("ui-menu-submenu-caret") && e.remove() }) }, _keydown: function(e) { var i, s, n, o, a = !0; switch (e.keyCode) {
                    case t.ui.keyCode.PAGE_UP:
                        this.previousPage(e); break;
                    case t.ui.keyCode.PAGE_DOWN:
                        this.nextPage(e); break;
                    case t.ui.keyCode.HOME:
                        this._move("first", "first", e); break;
                    case t.ui.keyCode.END:
                        this._move("last", "last", e); break;
                    case t.ui.keyCode.UP:
                        this.previous(e); break;
                    case t.ui.keyCode.DOWN:
                        this.next(e); break;
                    case t.ui.keyCode.LEFT:
                        this.collapse(e); break;
                    case t.ui.keyCode.RIGHT:
                        this.active && !this.active.is(".ui-state-disabled") && this.expand(e); break;
                    case t.ui.keyCode.ENTER:
                    case t.ui.keyCode.SPACE:
                        this._activate(e); break;
                    case t.ui.keyCode.ESCAPE:
                        this.collapse(e); break;
                    default:
                        a = !1, s = this.previousFilter || "", o = !1, n = e.keyCode >= 96 && 105 >= e.keyCode ? "" + (e.keyCode - 96) : String.fromCharCode(e.keyCode), clearTimeout(this.filterTimer), n === s ? o = !0 : n = s + n, i = this._filterMenuItems(n), i = o && -1 !== i.index(this.active.next()) ? this.active.nextAll(".ui-menu-item") : i, i.length || (n = String.fromCharCode(e.keyCode), i = this._filterMenuItems(n)), i.length ? (this.focus(e, i), this.previousFilter = n, this.filterTimer = this._delay(function() { delete this.previousFilter }, 1e3)) : delete this.previousFilter } a && e.preventDefault() }, _activate: function(t) { this.active && !this.active.is(".ui-state-disabled") && (this.active.children("[aria-haspopup='true']").length ? this.expand(t) : this.select(t)) }, refresh: function() { var e, i, s, n, o, a = this,
                    r = this.options.icons.submenu,
                    l = this.element.find(this.options.menus);
                this._toggleClass("ui-menu-icons", null, !!this.element.find(".ui-icon").length), s = l.filter(":not(.ui-menu)").hide().attr({ role: this.options.role, "aria-hidden": "true", "aria-expanded": "false" }).each(function() { var e = t(this),
                        i = e.prev(),
                        s = t("<span>").data("ui-menu-submenu-caret", !0);
                    a._addClass(s, "ui-menu-icon", "ui-icon " + r), i.attr("aria-haspopup", "true").prepend(s), e.attr("aria-labelledby", i.attr("id")) }), this._addClass(s, "ui-menu", "ui-widget ui-widget-content ui-front"), e = l.add(this.element), i = e.find(this.options.items), i.not(".ui-menu-item").each(function() { var e = t(this);
                    a._isDivider(e) && a._addClass(e, "ui-menu-divider", "ui-widget-content") }), n = i.not(".ui-menu-item, .ui-menu-divider"), o = n.children().not(".ui-menu").uniqueId().attr({ tabIndex: -1, role: this._itemRole() }), this._addClass(n, "ui-menu-item")._addClass(o, "ui-menu-item-wrapper"), i.filter(".ui-state-disabled").attr("aria-disabled", "true"), this.active && !t.contains(this.element[0], this.active[0]) && this.blur() }, _itemRole: function() { return { menu: "menuitem", listbox: "option" } [this.options.role] }, _setOption: function(t, e) { if ("icons" === t) { var i = this.element.find(".ui-menu-icon");
                    this._removeClass(i, null, this.options.icons.submenu)._addClass(i, null, e.submenu) } this._super(t, e) }, _setOptionDisabled: function(t) { this._super(t), this.element.attr("aria-disabled", t + ""), this._toggleClass(null, "ui-state-disabled", !!t) }, focus: function(t, e) { var i, s, n;
                this.blur(t, t && "focus" === t.type), this._scrollIntoView(e), this.active = e.first(), s = this.active.children(".ui-menu-item-wrapper"), this._addClass(s, null, "ui-state-active"), this.options.role && this.element.attr("aria-activedescendant", s.attr("id")), n = this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper"), this._addClass(n, null, "ui-state-active"), t && "keydown" === t.type ? this._close() : this.timer = this._delay(function() { this._close() }, this.delay), i = e.children(".ui-menu"), i.length && t && /^mouse/.test(t.type) && this._startOpening(i), this.activeMenu = e.parent(), this._trigger("focus", t, { item: e }) }, _scrollIntoView: function(e) { var i, s, n, o, a, r;
                this._hasScroll() && (i = parseFloat(t.css(this.activeMenu[0], "borderTopWidth")) || 0, s = parseFloat(t.css(this.activeMenu[0], "paddingTop")) || 0, n = e.offset().top - this.activeMenu.offset().top - i - s, o = this.activeMenu.scrollTop(), a = this.activeMenu.height(), r = e.outerHeight(), 0 > n ? this.activeMenu.scrollTop(o + n) : n + r > a && this.activeMenu.scrollTop(o + n - a + r)) }, blur: function(t, e) { e || clearTimeout(this.timer), this.active && (this._removeClass(this.active.children(".ui-menu-item-wrapper"), null, "ui-state-active"), this._trigger("blur", t, { item: this.active }), this.active = null) }, _startOpening: function(t) { clearTimeout(this.timer), "true" === t.attr("aria-hidden") && (this.timer = this._delay(function() { this._close(), this._open(t) }, this.delay)) }, _open: function(e) { var i = t.extend({ of: this.active }, this.options.position);
                clearTimeout(this.timer), this.element.find(".ui-menu").not(e.parents(".ui-menu")).hide().attr("aria-hidden", "true"), e.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(i) }, collapseAll: function(e, i) { clearTimeout(this.timer), this.timer = this._delay(function() { var s = i ? this.element : t(e && e.target).closest(this.element.find(".ui-menu"));
                    s.length || (s = this.element), this._close(s), this.blur(e), this._removeClass(s.find(".ui-state-active"), null, "ui-state-active"), this.activeMenu = s }, this.delay) }, _close: function(t) { t || (t = this.active ? this.active.parent() : this.element), t.find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false") }, _closeOnDocumentClick: function(e) { return !t(e.target).closest(".ui-menu").length }, _isDivider: function(t) { return !/[^\-\u2014\u2013\s]/.test(t.text()) }, collapse: function(t) { var e = this.active && this.active.parent().closest(".ui-menu-item", this.element);
                e && e.length && (this._close(), this.focus(t, e)) }, expand: function(t) { var e = this.active && this.active.children(".ui-menu ").find(this.options.items).first();
                e && e.length && (this._open(e.parent()), this._delay(function() { this.focus(t, e) })) }, next: function(t) { this._move("next", "first", t) }, previous: function(t) { this._move("prev", "last", t) }, isFirstItem: function() { return this.active && !this.active.prevAll(".ui-menu-item").length }, isLastItem: function() { return this.active && !this.active.nextAll(".ui-menu-item").length }, _move: function(t, e, i) { var s;
                this.active && (s = "first" === t || "last" === t ? this.active["first" === t ? "prevAll" : "nextAll"](".ui-menu-item").eq(-1) : this.active[t + "All"](".ui-menu-item").eq(0)), s && s.length && this.active || (s = this.activeMenu.find(this.options.items)[e]()), this.focus(i, s) }, nextPage: function(e) { var i, s, n; return this.active ? (this.isLastItem() || (this._hasScroll() ? (s = this.active.offset().top, n = this.element.height(), this.active.nextAll(".ui-menu-item").each(function() { return i = t(this), 0 > i.offset().top - s - n }), this.focus(e, i)) : this.focus(e, this.activeMenu.find(this.options.items)[this.active ? "last" : "first"]())), void 0) : (this.next(e), void 0) }, previousPage: function(e) { var i, s, n; return this.active ? (this.isFirstItem() || (this._hasScroll() ? (s = this.active.offset().top, n = this.element.height(), this.active.prevAll(".ui-menu-item").each(function() { return i = t(this), i.offset().top - s + n > 0 }), this.focus(e, i)) : this.focus(e, this.activeMenu.find(this.options.items).first())), void 0) : (this.next(e), void 0) }, _hasScroll: function() { return this.element.outerHeight() < this.element.prop("scrollHeight") }, select: function(e) { this.active = this.active || t(e.target).closest(".ui-menu-item"); var i = { item: this.active };
                this.active.has(".ui-menu").length || this.collapseAll(e, !0), this._trigger("select", e, i) }, _filterMenuItems: function(e) { var i = e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"),
                    s = RegExp("^" + i, "i"); return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function() { return s.test(t.trim(t(this).children(".ui-menu-item-wrapper").text())) }) } }), t.widget("ui.autocomplete", { version: "1.12.1", defaultElement: "<input>", options: { appendTo: null, autoFocus: !1, delay: 300, minLength: 1, position: { my: "left top", at: "left bottom", collision: "none" }, source: null, change: null, close: null, focus: null, open: null, response: null, search: null, select: null }, requestIndex: 0, pending: 0, _create: function() { var e, i, s, n = this.element[0].nodeName.toLowerCase(),
                    o = "textarea" === n,
                    a = "input" === n;
                this.isMultiLine = o || !a && this._isContentEditable(this.element), this.valueMethod = this.element[o || a ? "val" : "text"], this.isNewMenu = !0, this._addClass("ui-autocomplete-input"), this.element.attr("autocomplete", "off"), this._on(this.element, { keydown: function(n) { if (this.element.prop("readOnly")) return e = !0, s = !0, i = !0, void 0;
                        e = !1, s = !1, i = !1; var o = t.ui.keyCode; switch (n.keyCode) {
                            case o.PAGE_UP:
                                e = !0, this._move("previousPage", n); break;
                            case o.PAGE_DOWN:
                                e = !0, this._move("nextPage", n); break;
                            case o.UP:
                                e = !0, this._keyEvent("previous", n); break;
                            case o.DOWN:
                                e = !0, this._keyEvent("next", n); break;
                            case o.ENTER:
                                this.menu.active && (e = !0, n.preventDefault(), this.menu.select(n)); break;
                            case o.TAB:
                                this.menu.active && this.menu.select(n); break;
                            case o.ESCAPE:
                                this.menu.element.is(":visible") && (this.isMultiLine || this._value(this.term), this.close(n), n.preventDefault()); break;
                            default:
                                i = !0, this._searchTimeout(n) } }, keypress: function(s) { if (e) return e = !1, (!this.isMultiLine || this.menu.element.is(":visible")) && s.preventDefault(), void 0; if (!i) { var n = t.ui.keyCode; switch (s.keyCode) {
                                case n.PAGE_UP:
                                    this._move("previousPage", s); break;
                                case n.PAGE_DOWN:
                                    this._move("nextPage", s); break;
                                case n.UP:
                                    this._keyEvent("previous", s); break;
                                case n.DOWN:
                                    this._keyEvent("next", s) } } }, input: function(t) { return s ? (s = !1, t.preventDefault(), void 0) : (this._searchTimeout(t), void 0) }, focus: function() { this.selectedItem = null, this.previous = this._value() }, blur: function(t) { return this.cancelBlur ? (delete this.cancelBlur, void 0) : (clearTimeout(this.searching), this.close(t), this._change(t), void 0) } }), this._initSource(), this.menu = t("<ul>").appendTo(this._appendTo()).menu({ role: null }).hide().menu("instance"), this._addClass(this.menu.element, "ui-autocomplete", "ui-front"), this._on(this.menu.element, { mousedown: function(e) { e.preventDefault(), this.cancelBlur = !0, this._delay(function() { delete this.cancelBlur, this.element[0] !== t.ui.safeActiveElement(this.document[0]) && this.element.trigger("focus") }) }, menufocus: function(e, i) { var s, n; return this.isNewMenu && (this.isNewMenu = !1, e.originalEvent && /^mouse/.test(e.originalEvent.type)) ? (this.menu.blur(), this.document.one("mousemove", function() { t(e.target).trigger(e.originalEvent) }), void 0) : (n = i.item.data("ui-autocomplete-item"), !1 !== this._trigger("focus", e, { item: n }) && e.originalEvent && /^key/.test(e.originalEvent.type) && this._value(n.value), s = i.item.attr("aria-label") || n.value, s && t.trim(s).length && (this.liveRegion.children().hide(), t("<div>").text(s).appendTo(this.liveRegion)), void 0) }, menuselect: function(e, i) { var s = i.item.data("ui-autocomplete-item"),
                            n = this.previous;
                        this.element[0] !== t.ui.safeActiveElement(this.document[0]) && (this.element.trigger("focus"), this.previous = n, this._delay(function() { this.previous = n, this.selectedItem = s })), !1 !== this._trigger("select", e, { item: s }) && this._value(s.value), this.term = this._value(), this.close(e), this.selectedItem = s } }), this.liveRegion = t("<div>", { role: "status", "aria-live": "assertive", "aria-relevant": "additions" }).appendTo(this.document[0].body), this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible"), this._on(this.window, { beforeunload: function() { this.element.removeAttr("autocomplete") } }) }, _destroy: function() { clearTimeout(this.searching), this.element.removeAttr("autocomplete"), this.menu.element.remove(), this.liveRegion.remove() }, _setOption: function(t, e) { this._super(t, e), "source" === t && this._initSource(), "appendTo" === t && this.menu.element.appendTo(this._appendTo()), "disabled" === t && e && this.xhr && this.xhr.abort() }, _isEventTargetInWidget: function(e) { var i = this.menu.element[0]; return e.target === this.element[0] || e.target === i || t.contains(i, e.target) }, _closeOnClickOutside: function(t) { this._isEventTargetInWidget(t) || this.close() }, _appendTo: function() { var e = this.options.appendTo; return e && (e = e.jquery || e.nodeType ? t(e) : this.document.find(e).eq(0)), e && e[0] || (e = this.element.closest(".ui-front, dialog")), e.length || (e = this.document[0].body), e }, _initSource: function() { var e, i, s = this;
                t.isArray(this.options.source) ? (e = this.options.source, this.source = function(i, s) { s(t.ui.autocomplete.filter(e, i.term)) }) : "string" == typeof this.options.source ? (i = this.options.source, this.source = function(e, n) { s.xhr && s.xhr.abort(), s.xhr = t.ajax({ url: i, data: e, dataType: "json", success: function(t) { n(t) }, error: function() { n([]) } }) }) : this.source = this.options.source }, _searchTimeout: function(t) { clearTimeout(this.searching), this.searching = this._delay(function() { var e = this.term === this._value(),
                        i = this.menu.element.is(":visible"),
                        s = t.altKey || t.ctrlKey || t.metaKey || t.shiftKey;
                    (!e || e && !i && !s) && (this.selectedItem = null, this.search(null, t)) }, this.options.delay) }, search: function(t, e) { return t = null != t ? t : this._value(), this.term = this._value(), t.length < this.options.minLength ? this.close(e) : this._trigger("search", e) !== !1 ? this._search(t) : void 0 }, _search: function(t) { this.pending++, this._addClass("ui-autocomplete-loading"), this.cancelSearch = !1, this.source({ term: t }, this._response()) }, _response: function() { var e = ++this.requestIndex; return t.proxy(function(t) { e === this.requestIndex && this.__response(t), this.pending--, this.pending || this._removeClass("ui-autocomplete-loading") }, this) }, __response: function(t) { t && (t = this._normalize(t)), this._trigger("response", null, { content: t }), !this.options.disabled && t && t.length && !this.cancelSearch ? (this._suggest(t), this._trigger("open")) : this._close() }, close: function(t) { this.cancelSearch = !0, this._close(t) }, _close: function(t) { this._off(this.document, "mousedown"), this.menu.element.is(":visible") && (this.menu.element.hide(), this.menu.blur(), this.isNewMenu = !0, this._trigger("close", t)) }, _change: function(t) { this.previous !== this._value() && this._trigger("change", t, { item: this.selectedItem }) }, _normalize: function(e) { return e.length && e[0].label && e[0].value ? e : t.map(e, function(e) { return "string" == typeof e ? { label: e, value: e } : t.extend({}, e, { label: e.label || e.value, value: e.value || e.label }) }) }, _suggest: function(e) { var i = this.menu.element.empty();
                this._renderMenu(i, e), this.isNewMenu = !0, this.menu.refresh(), i.show(), this._resizeMenu(), i.position(t.extend({ of: this.element }, this.options.position)), this.options.autoFocus && this.menu.next(), this._on(this.document, { mousedown: "_closeOnClickOutside" }) }, _resizeMenu: function() { var t = this.menu.element;
                t.outerWidth(Math.max(t.width("").outerWidth() + 1, this.element.outerWidth())) }, _renderMenu: function(e, i) { var s = this;
                t.each(i, function(t, i) { s._renderItemData(e, i) }) }, _renderItemData: function(t, e) { return this._renderItem(t, e).data("ui-autocomplete-item", e) }, _renderItem: function(e, i) { return t("<li>").append(t("<div>").text(i.label)).appendTo(e) }, _move: function(t, e) { return this.menu.element.is(":visible") ? this.menu.isFirstItem() && /^previous/.test(t) || this.menu.isLastItem() && /^next/.test(t) ? (this.isMultiLine || this._value(this.term), this.menu.blur(), void 0) : (this.menu[t](e), void 0) : (this.search(null, e), void 0) }, widget: function() { return this.menu.element }, _value: function() { return this.valueMethod.apply(this.element, arguments) }, _keyEvent: function(t, e) {
                (!this.isMultiLine || this.menu.element.is(":visible")) && (this._move(t, e), e.preventDefault()) }, _isContentEditable: function(t) { if (!t.length) return !1; var e = t.prop("contentEditable"); return "inherit" === e ? this._isContentEditable(t.parent()) : "true" === e } }), t.extend(t.ui.autocomplete, { escapeRegex: function(t) { return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&") }, filter: function(e, i) { var s = RegExp(t.ui.autocomplete.escapeRegex(i), "i"); return t.grep(e, function(t) { return s.test(t.label || t.value || t) }) } }), t.widget("ui.autocomplete", t.ui.autocomplete, { options: { messages: { noResults: "No search results.", results: function(t) { return t + (t > 1 ? " results are" : " result is") + " available, use up and down arrow keys to navigate." } } }, __response: function(e) { var i;
                this._superApply(arguments), this.options.disabled || this.cancelSearch || (i = e && e.length ? this.options.messages.results(e.length) : this.options.messages.noResults, this.liveRegion.children().hide(), t("<div>").text(i).appendTo(this.liveRegion)) } }), t.ui.autocomplete;
    var s = "ui-effects-",
        n = "ui-effects-style",
        o = "ui-effects-animated",
        a = t;
    t.effects = { effect: {} },
        function(t, e) {
            function i(t, e, i) {
                var s = u[e.type] || {};
                return null == t ? i || !e.def ? null : e.def : (t = s.floor ? ~~t : parseFloat(t), isNaN(t) ? e.def : s.mod ? (t + s.mod) % s.mod : 0 > t ? 0 : t > s.max ? s.max : t)
            }

            function s(i) { var s = h(),
                    n = s._rgba = []; return i = i.toLowerCase(), f(l, function(t, o) { var a, r = o.re.exec(i),
                        l = r && o.parse(r),
                        h = o.space || "rgba"; return l ? (a = s[h](l), s[c[h].cache] = a[c[h].cache], n = s._rgba = a._rgba, !1) : e }), n.length ? ("0,0,0,0" === n.join() && t.extend(n, o.transparent), s) : o[i] }

            function n(t, e, i) { return i = (i + 1) % 1, 1 > 6 * i ? t + 6 * (e - t) * i : 1 > 2 * i ? e : 2 > 3 * i ? t + 6 * (e - t) * (2 / 3 - i) : t }
            var o, a = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",
                r = /^([\-+])=\s*(\d+\.?\d*)/,
                l = [{ re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/, parse: function(t) { return [t[1], t[2], t[3], t[4]] } }, { re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/, parse: function(t) { return [2.55 * t[1], 2.55 * t[2], 2.55 * t[3], t[4]] } }, { re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/, parse: function(t) { return [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)] } }, { re: /#([a-f0-9])([a-f0-9])([a-f0-9])/, parse: function(t) { return [parseInt(t[1] + t[1], 16), parseInt(t[2] + t[2], 16), parseInt(t[3] + t[3], 16)] } }, { re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/, space: "hsla", parse: function(t) { return [t[1], t[2] / 100, t[3] / 100, t[4]] } }],
                h = t.Color = function(e, i, s, n) { return new t.Color.fn.parse(e, i, s, n) },
                c = { rgba: { props: { red: { idx: 0, type: "byte" }, green: { idx: 1, type: "byte" }, blue: { idx: 2, type: "byte" } } }, hsla: { props: { hue: { idx: 0, type: "degrees" }, saturation: { idx: 1, type: "percent" }, lightness: { idx: 2, type: "percent" } } } },
                u = { "byte": { floor: !0, max: 255 }, percent: { max: 1 }, degrees: { mod: 360, floor: !0 } },
                d = h.support = {},
                p = t("<p>")[0],
                f = t.each;
            p.style.cssText = "background-color:rgba(1,1,1,.5)", d.rgba = p.style.backgroundColor.indexOf("rgba") > -1, f(c, function(t, e) { e.cache = "_" + t, e.props.alpha = { idx: 3, type: "percent", def: 1 } }), h.fn = t.extend(h.prototype, { parse: function(n, a, r, l) { if (n === e) return this._rgba = [null, null, null, null], this;
                    (n.jquery || n.nodeType) && (n = t(n).css(a), a = e); var u = this,
                        d = t.type(n),
                        p = this._rgba = []; return a !== e && (n = [n, a, r, l], d = "array"), "string" === d ? this.parse(s(n) || o._default) : "array" === d ? (f(c.rgba.props, function(t, e) { p[e.idx] = i(n[e.idx], e) }), this) : "object" === d ? (n instanceof h ? f(c, function(t, e) { n[e.cache] && (u[e.cache] = n[e.cache].slice()) }) : f(c, function(e, s) { var o = s.cache;
                        f(s.props, function(t, e) { if (!u[o] && s.to) { if ("alpha" === t || null == n[t]) return;
                                u[o] = s.to(u._rgba) } u[o][e.idx] = i(n[t], e, !0) }), u[o] && 0 > t.inArray(null, u[o].slice(0, 3)) && (u[o][3] = 1, s.from && (u._rgba = s.from(u[o]))) }), this) : e }, is: function(t) { var i = h(t),
                        s = !0,
                        n = this; return f(c, function(t, o) { var a, r = i[o.cache]; return r && (a = n[o.cache] || o.to && o.to(n._rgba) || [], f(o.props, function(t, i) { return null != r[i.idx] ? s = r[i.idx] === a[i.idx] : e })), s }), s }, _space: function() { var t = [],
                        e = this; return f(c, function(i, s) { e[s.cache] && t.push(i) }), t.pop() }, transition: function(t, e) { var s = h(t),
                        n = s._space(),
                        o = c[n],
                        a = 0 === this.alpha() ? h("transparent") : this,
                        r = a[o.cache] || o.to(a._rgba),
                        l = r.slice(); return s = s[o.cache], f(o.props, function(t, n) { var o = n.idx,
                            a = r[o],
                            h = s[o],
                            c = u[n.type] || {};
                        null !== h && (null === a ? l[o] = h : (c.mod && (h - a > c.mod / 2 ? a += c.mod : a - h > c.mod / 2 && (a -= c.mod)), l[o] = i((h - a) * e + a, n))) }), this[n](l) }, blend: function(e) { if (1 === this._rgba[3]) return this; var i = this._rgba.slice(),
                        s = i.pop(),
                        n = h(e)._rgba; return h(t.map(i, function(t, e) { return (1 - s) * n[e] + s * t })) }, toRgbaString: function() { var e = "rgba(",
                        i = t.map(this._rgba, function(t, e) { return null == t ? e > 2 ? 1 : 0 : t }); return 1 === i[3] && (i.pop(), e = "rgb("), e + i.join() + ")" }, toHslaString: function() { var e = "hsla(",
                        i = t.map(this.hsla(), function(t, e) { return null == t && (t = e > 2 ? 1 : 0), e && 3 > e && (t = Math.round(100 * t) + "%"), t }); return 1 === i[3] && (i.pop(), e = "hsl("), e + i.join() + ")" }, toHexString: function(e) { var i = this._rgba.slice(),
                        s = i.pop(); return e && i.push(~~(255 * s)), "#" + t.map(i, function(t) { return t = (t || 0).toString(16), 1 === t.length ? "0" + t : t }).join("") }, toString: function() { return 0 === this._rgba[3] ? "transparent" : this.toRgbaString() } }), h.fn.parse.prototype = h.fn, c.hsla.to = function(t) { if (null == t[0] || null == t[1] || null == t[2]) return [null, null, null, t[3]]; var e, i, s = t[0] / 255,
                    n = t[1] / 255,
                    o = t[2] / 255,
                    a = t[3],
                    r = Math.max(s, n, o),
                    l = Math.min(s, n, o),
                    h = r - l,
                    c = r + l,
                    u = .5 * c; return e = l === r ? 0 : s === r ? 60 * (n - o) / h + 360 : n === r ? 60 * (o - s) / h + 120 : 60 * (s - n) / h + 240, i = 0 === h ? 0 : .5 >= u ? h / c : h / (2 - c), [Math.round(e) % 360, i, u, null == a ? 1 : a] }, c.hsla.from = function(t) { if (null == t[0] || null == t[1] || null == t[2]) return [null, null, null, t[3]]; var e = t[0] / 360,
                    i = t[1],
                    s = t[2],
                    o = t[3],
                    a = .5 >= s ? s * (1 + i) : s + i - s * i,
                    r = 2 * s - a; return [Math.round(255 * n(r, a, e + 1 / 3)), Math.round(255 * n(r, a, e)), Math.round(255 * n(r, a, e - 1 / 3)), o] }, f(c, function(s, n) { var o = n.props,
                    a = n.cache,
                    l = n.to,
                    c = n.from;
                h.fn[s] = function(s) { if (l && !this[a] && (this[a] = l(this._rgba)), s === e) return this[a].slice(); var n, r = t.type(s),
                        u = "array" === r || "object" === r ? s : arguments,
                        d = this[a].slice(); return f(o, function(t, e) { var s = u["object" === r ? t : e.idx];
                        null == s && (s = d[e.idx]), d[e.idx] = i(s, e) }), c ? (n = h(c(d)), n[a] = d, n) : h(d) }, f(o, function(e, i) { h.fn[e] || (h.fn[e] = function(n) { var o, a = t.type(n),
                            l = "alpha" === e ? this._hsla ? "hsla" : "rgba" : s,
                            h = this[l](),
                            c = h[i.idx]; return "undefined" === a ? c : ("function" === a && (n = n.call(this, c), a = t.type(n)), null == n && i.empty ? this : ("string" === a && (o = r.exec(n), o && (n = c + parseFloat(o[2]) * ("+" === o[1] ? 1 : -1))), h[i.idx] = n, this[l](h))) }) }) }), h.hook = function(e) { var i = e.split(" ");
                f(i, function(e, i) { t.cssHooks[i] = { set: function(e, n) { var o, a, r = ""; if ("transparent" !== n && ("string" !== t.type(n) || (o = s(n)))) { if (n = h(o || n), !d.rgba && 1 !== n._rgba[3]) { for (a = "backgroundColor" === i ? e.parentNode : e;
                                        ("" === r || "transparent" === r) && a && a.style;) try { r = t.css(a, "backgroundColor"), a = a.parentNode } catch (l) {} n = n.blend(r && "transparent" !== r ? r : "_default") } n = n.toRgbaString() } try { e.style[i] = n } catch (l) {} } }, t.fx.step[i] = function(e) { e.colorInit || (e.start = h(e.elem, i), e.end = h(e.end), e.colorInit = !0), t.cssHooks[i].set(e.elem, e.start.transition(e.end, e.pos)) } }) }, h.hook(a), t.cssHooks.borderColor = { expand: function(t) { var e = {}; return f(["Top", "Right", "Bottom", "Left"], function(i, s) { e["border" + s + "Color"] = t }), e } }, o = t.Color.names = { aqua: "#00ffff", black: "#000000", blue: "#0000ff", fuchsia: "#ff00ff", gray: "#808080", green: "#008000", lime: "#00ff00", maroon: "#800000", navy: "#000080", olive: "#808000", purple: "#800080", red: "#ff0000", silver: "#c0c0c0", teal: "#008080", white: "#ffffff", yellow: "#ffff00", transparent: [null, null, null, 0], _default: "#ffffff" }
        }(a),
        function() {
            function e(e) { var i, s, n = e.ownerDocument.defaultView ? e.ownerDocument.defaultView.getComputedStyle(e, null) : e.currentStyle,
                    o = {}; if (n && n.length && n[0] && n[n[0]])
                    for (s = n.length; s--;) i = n[s], "string" == typeof n[i] && (o[t.camelCase(i)] = n[i]);
                else
                    for (i in n) "string" == typeof n[i] && (o[i] = n[i]); return o }

            function i(e, i) { var s, o, a = {}; for (s in i) o = i[s], e[s] !== o && (n[s] || (t.fx.step[s] || !isNaN(parseFloat(o))) && (a[s] = o)); return a } var s = ["add", "remove", "toggle"],
                n = { border: 1, borderBottom: 1, borderColor: 1, borderLeft: 1, borderRight: 1, borderTop: 1, borderWidth: 1, margin: 1, padding: 1 };
            t.each(["borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle"], function(e, i) { t.fx.step[i] = function(t) {
                    ("none" !== t.end && !t.setAttr || 1 === t.pos && !t.setAttr) && (a.style(t.elem, i, t.end), t.setAttr = !0) } }), t.fn.addBack || (t.fn.addBack = function(t) { return this.add(null == t ? this.prevObject : this.prevObject.filter(t)) }), t.effects.animateClass = function(n, o, a, r) { var l = t.speed(o, a, r); return this.queue(function() { var o, a = t(this),
                        r = a.attr("class") || "",
                        h = l.children ? a.find("*").addBack() : a;
                    h = h.map(function() { var i = t(this); return { el: i, start: e(this) } }), o = function() { t.each(s, function(t, e) { n[e] && a[e + "Class"](n[e]) }) }, o(), h = h.map(function() { return this.end = e(this.el[0]), this.diff = i(this.start, this.end), this }), a.attr("class", r), h = h.map(function() { var e = this,
                            i = t.Deferred(),
                            s = t.extend({}, l, { queue: !1, complete: function() { i.resolve(e) } }); return this.el.animate(this.diff, s), i.promise() }), t.when.apply(t, h.get()).done(function() { o(), t.each(arguments, function() { var e = this.el;
                            t.each(this.diff, function(t) { e.css(t, "") }) }), l.complete.call(a[0]) }) }) }, t.fn.extend({ addClass: function(e) { return function(i, s, n, o) { return s ? t.effects.animateClass.call(this, { add: i }, s, n, o) : e.apply(this, arguments) } }(t.fn.addClass), removeClass: function(e) { return function(i, s, n, o) { return arguments.length > 1 ? t.effects.animateClass.call(this, { remove: i }, s, n, o) : e.apply(this, arguments) } }(t.fn.removeClass), toggleClass: function(e) { return function(i, s, n, o, a) { return "boolean" == typeof s || void 0 === s ? n ? t.effects.animateClass.call(this, s ? { add: i } : { remove: i }, n, o, a) : e.apply(this, arguments) : t.effects.animateClass.call(this, { toggle: i }, s, n, o) } }(t.fn.toggleClass), switchClass: function(e, i, s, n, o) { return t.effects.animateClass.call(this, { add: i, remove: e }, s, n, o) } }) }(),
        function() {
            function e(e, i, s, n) { return t.isPlainObject(e) && (i = e, e = e.effect), e = { effect: e }, null == i && (i = {}), t.isFunction(i) && (n = i, s = null, i = {}), ("number" == typeof i || t.fx.speeds[i]) && (n = s, s = i, i = {}), t.isFunction(s) && (n = s, s = null), i && t.extend(e, i), s = s || i.duration, e.duration = t.fx.off ? 0 : "number" == typeof s ? s : s in t.fx.speeds ? t.fx.speeds[s] : t.fx.speeds._default, e.complete = n || i.complete, e }

            function i(e) { return !e || "number" == typeof e || t.fx.speeds[e] ? !0 : "string" != typeof e || t.effects.effect[e] ? t.isFunction(e) ? !0 : "object" != typeof e || e.effect ? !1 : !0 : !0 }

            function a(t, e) { var i = e.outerWidth(),
                    s = e.outerHeight(),
                    n = /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/,
                    o = n.exec(t) || ["", 0, i, s, 0]; return { top: parseFloat(o[1]) || 0, right: "auto" === o[2] ? i : parseFloat(o[2]), bottom: "auto" === o[3] ? s : parseFloat(o[3]), left: parseFloat(o[4]) || 0 } } t.expr && t.expr.filters && t.expr.filters.animated && (t.expr.filters.animated = function(e) { return function(i) { return !!t(i).data(o) || e(i) } }(t.expr.filters.animated)), t.uiBackCompat !== !1 && t.extend(t.effects, { save: function(t, e) { for (var i = 0, n = e.length; n > i; i++) null !== e[i] && t.data(s + e[i], t[0].style[e[i]]) }, restore: function(t, e) { for (var i, n = 0, o = e.length; o > n; n++) null !== e[n] && (i = t.data(s + e[n]), t.css(e[n], i)) }, setMode: function(t, e) { return "toggle" === e && (e = t.is(":hidden") ? "show" : "hide"), e }, createWrapper: function(e) { if (e.parent().is(".ui-effects-wrapper")) return e.parent(); var i = { width: e.outerWidth(!0), height: e.outerHeight(!0), "float": e.css("float") },
                        s = t("<div></div>").addClass("ui-effects-wrapper").css({ fontSize: "100%", background: "transparent", border: "none", margin: 0, padding: 0 }),
                        n = { width: e.width(), height: e.height() },
                        o = document.activeElement; try { o.id } catch (a) { o = document.body } return e.wrap(s), (e[0] === o || t.contains(e[0], o)) && t(o).trigger("focus"), s = e.parent(), "static" === e.css("position") ? (s.css({ position: "relative" }), e.css({ position: "relative" })) : (t.extend(i, { position: e.css("position"), zIndex: e.css("z-index") }), t.each(["top", "left", "bottom", "right"], function(t, s) { i[s] = e.css(s), isNaN(parseInt(i[s], 10)) && (i[s] = "auto") }), e.css({ position: "relative", top: 0, left: 0, right: "auto", bottom: "auto" })), e.css(n), s.css(i).show() }, removeWrapper: function(e) { var i = document.activeElement; return e.parent().is(".ui-effects-wrapper") && (e.parent().replaceWith(e), (e[0] === i || t.contains(e[0], i)) && t(i).trigger("focus")), e } }), t.extend(t.effects, { version: "1.12.1", define: function(e, i, s) { return s || (s = i, i = "effect"), t.effects.effect[e] = s, t.effects.effect[e].mode = i, s }, scaledDimensions: function(t, e, i) { if (0 === e) return { height: 0, width: 0, outerHeight: 0, outerWidth: 0 }; var s = "horizontal" !== i ? (e || 100) / 100 : 1,
                        n = "vertical" !== i ? (e || 100) / 100 : 1; return { height: t.height() * n, width: t.width() * s, outerHeight: t.outerHeight() * n, outerWidth: t.outerWidth() * s } }, clipToBox: function(t) { return { width: t.clip.right - t.clip.left, height: t.clip.bottom - t.clip.top, left: t.clip.left, top: t.clip.top } }, unshift: function(t, e, i) { var s = t.queue();
                    e > 1 && s.splice.apply(s, [1, 0].concat(s.splice(e, i))), t.dequeue() }, saveStyle: function(t) { t.data(n, t[0].style.cssText) }, restoreStyle: function(t) { t[0].style.cssText = t.data(n) || "", t.removeData(n) }, mode: function(t, e) { var i = t.is(":hidden"); return "toggle" === e && (e = i ? "show" : "hide"), (i ? "hide" === e : "show" === e) && (e = "none"), e }, getBaseline: function(t, e) { var i, s; switch (t[0]) {
                        case "top":
                            i = 0; break;
                        case "middle":
                            i = .5; break;
                        case "bottom":
                            i = 1; break;
                        default:
                            i = t[0] / e.height } switch (t[1]) {
                        case "left":
                            s = 0; break;
                        case "center":
                            s = .5; break;
                        case "right":
                            s = 1; break;
                        default:
                            s = t[1] / e.width } return { x: s, y: i } }, createPlaceholder: function(e) { var i, n = e.css("position"),
                        o = e.position(); return e.css({ marginTop: e.css("marginTop"), marginBottom: e.css("marginBottom"), marginLeft: e.css("marginLeft"), marginRight: e.css("marginRight") }).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()), /^(static|relative)/.test(n) && (n = "absolute", i = t("<" + e[0].nodeName + ">").insertAfter(e).css({ display: /^(inline|ruby)/.test(e.css("display")) ? "inline-block" : "block", visibility: "hidden", marginTop: e.css("marginTop"), marginBottom: e.css("marginBottom"), marginLeft: e.css("marginLeft"), marginRight: e.css("marginRight"), "float": e.css("float") }).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).addClass("ui-effects-placeholder"), e.data(s + "placeholder", i)), e.css({ position: n, left: o.left, top: o.top }), i }, removePlaceholder: function(t) { var e = s + "placeholder",
                        i = t.data(e);
                    i && (i.remove(), t.removeData(e)) }, cleanUp: function(e) { t.effects.restoreStyle(e), t.effects.removePlaceholder(e) }, setTransition: function(e, i, s, n) { return n = n || {}, t.each(i, function(t, i) { var o = e.cssUnit(i);
                        o[0] > 0 && (n[i] = o[0] * s + o[1]) }), n } }), t.fn.extend({ effect: function() {
                    function i(e) {
                        function i() { l.removeData(o), t.effects.cleanUp(l), "hide" === s.mode && l.hide(), r() }

                        function r() { t.isFunction(h) && h.call(l[0]), t.isFunction(e) && e() } var l = t(this);
                        s.mode = u.shift(), t.uiBackCompat === !1 || a ? "none" === s.mode ? (l[c](), r()) : n.call(l[0], s, i) : (l.is(":hidden") ? "hide" === c : "show" === c) ? (l[c](), r()) : n.call(l[0], s, r) } var s = e.apply(this, arguments),
                        n = t.effects.effect[s.effect],
                        a = n.mode,
                        r = s.queue,
                        l = r || "fx",
                        h = s.complete,
                        c = s.mode,
                        u = [],
                        d = function(e) { var i = t(this),
                                s = t.effects.mode(i, c) || a;
                            i.data(o, !0), u.push(s), a && ("show" === s || s === a && "hide" === s) && i.show(), a && "none" === s || t.effects.saveStyle(i), t.isFunction(e) && e() }; return t.fx.off || !n ? c ? this[c](s.duration, h) : this.each(function() { h && h.call(this) }) : r === !1 ? this.each(d).each(i) : this.queue(l, d).queue(l, i) }, show: function(t) { return function(s) { if (i(s)) return t.apply(this, arguments); var n = e.apply(this, arguments); return n.mode = "show", this.effect.call(this, n) } }(t.fn.show), hide: function(t) { return function(s) { if (i(s)) return t.apply(this, arguments); var n = e.apply(this, arguments); return n.mode = "hide", this.effect.call(this, n) } }(t.fn.hide), toggle: function(t) { return function(s) { if (i(s) || "boolean" == typeof s) return t.apply(this, arguments); var n = e.apply(this, arguments); return n.mode = "toggle", this.effect.call(this, n) } }(t.fn.toggle), cssUnit: function(e) { var i = this.css(e),
                        s = []; return t.each(["em", "px", "%", "pt"], function(t, e) { i.indexOf(e) > 0 && (s = [parseFloat(i), e]) }), s }, cssClip: function(t) { return t ? this.css("clip", "rect(" + t.top + "px " + t.right + "px " + t.bottom + "px " + t.left + "px)") : a(this.css("clip"), this) }, transfer: function(e, i) { var s = t(this),
                        n = t(e.to),
                        o = "fixed" === n.css("position"),
                        a = t("body"),
                        r = o ? a.scrollTop() : 0,
                        l = o ? a.scrollLeft() : 0,
                        h = n.offset(),
                        c = { top: h.top - r, left: h.left - l, height: n.innerHeight(), width: n.innerWidth() },
                        u = s.offset(),
                        d = t("<div class='ui-effects-transfer'></div>").appendTo("body").addClass(e.className).css({ top: u.top - r, left: u.left - l, height: s.innerHeight(), width: s.innerWidth(), position: o ? "fixed" : "absolute" }).animate(c, e.duration, e.easing, function() { d.remove(), t.isFunction(i) && i() }) } }), t.fx.step.clip = function(e) { e.clipInit || (e.start = t(e.elem).cssClip(), "string" == typeof e.end && (e.end = a(e.end, e.elem)), e.clipInit = !0), t(e.elem).cssClip({ top: e.pos * (e.end.top - e.start.top) + e.start.top, right: e.pos * (e.end.right - e.start.right) + e.start.right, bottom: e.pos * (e.end.bottom - e.start.bottom) + e.start.bottom, left: e.pos * (e.end.left - e.start.left) + e.start.left }) } }(),
        function() { var e = {};
            t.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], function(t, i) { e[i] = function(e) { return Math.pow(e, t + 2) } }), t.extend(e, { Sine: function(t) { return 1 - Math.cos(t * Math.PI / 2) }, Circ: function(t) { return 1 - Math.sqrt(1 - t * t) }, Elastic: function(t) { return 0 === t || 1 === t ? t : -Math.pow(2, 8 * (t - 1)) * Math.sin((80 * (t - 1) - 7.5) * Math.PI / 15) }, Back: function(t) { return t * t * (3 * t - 2) }, Bounce: function(t) { for (var e, i = 4;
                        ((e = Math.pow(2, --i)) - 1) / 11 > t;); return 1 / Math.pow(4, 3 - i) - 7.5625 * Math.pow((3 * e - 2) / 22 - t, 2) } }), t.each(e, function(e, i) { t.easing["easeIn" + e] = i, t.easing["easeOut" + e] = function(t) { return 1 - i(1 - t) }, t.easing["easeInOut" + e] = function(t) { return .5 > t ? i(2 * t) / 2 : 1 - i(-2 * t + 2) / 2 } }) }(), t.effects, t.effects.define("slide", "show", function(e, i) { var s, n, o = t(this),
                a = { up: ["bottom", "top"], down: ["top", "bottom"], left: ["right", "left"], right: ["left", "right"] },
                r = e.mode,
                l = e.direction || "left",
                h = "up" === l || "down" === l ? "top" : "left",
                c = "up" === l || "left" === l,
                u = e.distance || o["top" === h ? "outerHeight" : "outerWidth"](!0),
                d = {};
            t.effects.createPlaceholder(o), s = o.cssClip(), n = o.position()[h], d[h] = (c ? -1 : 1) * u + n, d.clip = o.cssClip(), d.clip[a[l][1]] = d.clip[a[l][0]], "show" === r && (o.cssClip(d.clip), o.css(h, d[h]), d.clip = s, d[h] = n), o.animate(d, { queue: !1, duration: e.duration, easing: e.easing, complete: i }) })
});
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJqcXVlcnktdWkubWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBqUXVlcnkgVUkgLSB2MS4xMi4xIC0gMjAxNy0wNi0wMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICogSW5jbHVkZXM6IHdpZGdldC5qcywgcG9zaXRpb24uanMsIGtleWNvZGUuanMsIHVuaXF1ZS1pZC5qcywgd2lkZ2V0cy9hdXRvY29tcGxldGUuanMsIHdpZGdldHMvbWVudS5qcywgZWZmZWN0LmpzLCBlZmZlY3RzL2VmZmVjdC1zbGlkZS5qc1xuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnM7IExpY2Vuc2VkIE1JVCAqL1xuXG4oZnVuY3Rpb24odCkgeyBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFtcImpxdWVyeVwiXSwgdCkgOiB0KGpRdWVyeSkgfSkoZnVuY3Rpb24odCkge1xuICAgIHQudWkgPSB0LnVpIHx8IHt9LCB0LnVpLnZlcnNpb24gPSBcIjEuMTIuMVwiO1xuICAgIHZhciBlID0gMCxcbiAgICAgICAgaSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbiAgICB0LmNsZWFuRGF0YSA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGZ1bmN0aW9uKGkpIHsgdmFyIHMsIG4sIG87IGZvciAobyA9IDA7IG51bGwgIT0gKG4gPSBpW29dKTsgbysrKSB0cnkgeyBzID0gdC5fZGF0YShuLCBcImV2ZW50c1wiKSwgcyAmJiBzLnJlbW92ZSAmJiB0KG4pLnRyaWdnZXJIYW5kbGVyKFwicmVtb3ZlXCIpIH0gY2F0Y2ggKGEpIHt9IGUoaSkgfSB9KHQuY2xlYW5EYXRhKSwgdC53aWRnZXQgPSBmdW5jdGlvbihlLCBpLCBzKSB7IHZhciBuLCBvLCBhLCByID0ge30sXG4gICAgICAgICAgICAgICAgbCA9IGUuc3BsaXQoXCIuXCIpWzBdO1xuICAgICAgICAgICAgZSA9IGUuc3BsaXQoXCIuXCIpWzFdOyB2YXIgaCA9IGwgKyBcIi1cIiArIGU7IHJldHVybiBzIHx8IChzID0gaSwgaSA9IHQuV2lkZ2V0KSwgdC5pc0FycmF5KHMpICYmIChzID0gdC5leHRlbmQuYXBwbHkobnVsbCwgW3t9XS5jb25jYXQocykpKSwgdC5leHByW1wiOlwiXVtoLnRvTG93ZXJDYXNlKCldID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gISF0LmRhdGEoZSwgaCkgfSwgdFtsXSA9IHRbbF0gfHwge30sIG4gPSB0W2xdW2VdLCBvID0gdFtsXVtlXSA9IGZ1bmN0aW9uKHQsIGUpIHsgcmV0dXJuIHRoaXMuX2NyZWF0ZVdpZGdldCA/IChhcmd1bWVudHMubGVuZ3RoICYmIHRoaXMuX2NyZWF0ZVdpZGdldCh0LCBlKSwgdm9pZCAwKSA6IG5ldyBvKHQsIGUpIH0sIHQuZXh0ZW5kKG8sIG4sIHsgdmVyc2lvbjogcy52ZXJzaW9uLCBfcHJvdG86IHQuZXh0ZW5kKHt9LCBzKSwgX2NoaWxkQ29uc3RydWN0b3JzOiBbXSB9KSwgYSA9IG5ldyBpLCBhLm9wdGlvbnMgPSB0LndpZGdldC5leHRlbmQoe30sIGEub3B0aW9ucyksIHQuZWFjaChzLCBmdW5jdGlvbihlLCBzKSB7IHJldHVybiB0LmlzRnVuY3Rpb24ocykgPyAocltlXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0KCkgeyByZXR1cm4gaS5wcm90b3R5cGVbZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gbih0KSB7IHJldHVybiBpLnByb3RvdHlwZVtlXS5hcHBseSh0aGlzLCB0KSB9IHJldHVybiBmdW5jdGlvbigpIHsgdmFyIGUsIGkgPSB0aGlzLl9zdXBlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gdGhpcy5fc3VwZXJBcHBseTsgcmV0dXJuIHRoaXMuX3N1cGVyID0gdCwgdGhpcy5fc3VwZXJBcHBseSA9IG4sIGUgPSBzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXMuX3N1cGVyID0gaSwgdGhpcy5fc3VwZXJBcHBseSA9IG8sIGUgfSB9KCksIHZvaWQgMCkgOiAocltlXSA9IHMsIHZvaWQgMCkgfSksIG8ucHJvdG90eXBlID0gdC53aWRnZXQuZXh0ZW5kKGEsIHsgd2lkZ2V0RXZlbnRQcmVmaXg6IG4gPyBhLndpZGdldEV2ZW50UHJlZml4IHx8IGUgOiBlIH0sIHIsIHsgY29uc3RydWN0b3I6IG8sIG5hbWVzcGFjZTogbCwgd2lkZ2V0TmFtZTogZSwgd2lkZ2V0RnVsbE5hbWU6IGggfSksIG4gPyAodC5lYWNoKG4uX2NoaWxkQ29uc3RydWN0b3JzLCBmdW5jdGlvbihlLCBpKSB7IHZhciBzID0gaS5wcm90b3R5cGU7XG4gICAgICAgICAgICAgICAgdC53aWRnZXQocy5uYW1lc3BhY2UgKyBcIi5cIiArIHMud2lkZ2V0TmFtZSwgbywgaS5fcHJvdG8pIH0pLCBkZWxldGUgbi5fY2hpbGRDb25zdHJ1Y3RvcnMpIDogaS5fY2hpbGRDb25zdHJ1Y3RvcnMucHVzaChvKSwgdC53aWRnZXQuYnJpZGdlKGUsIG8pLCBvIH0sIHQud2lkZ2V0LmV4dGVuZCA9IGZ1bmN0aW9uKGUpIHsgZm9yICh2YXIgcywgbiwgbyA9IGkuY2FsbChhcmd1bWVudHMsIDEpLCBhID0gMCwgciA9IG8ubGVuZ3RoOyByID4gYTsgYSsrKVxuICAgICAgICAgICAgICAgIGZvciAocyBpbiBvW2FdKSBuID0gb1thXVtzXSwgb1thXS5oYXNPd25Qcm9wZXJ0eShzKSAmJiB2b2lkIDAgIT09IG4gJiYgKGVbc10gPSB0LmlzUGxhaW5PYmplY3QobikgPyB0LmlzUGxhaW5PYmplY3QoZVtzXSkgPyB0LndpZGdldC5leHRlbmQoe30sIGVbc10sIG4pIDogdC53aWRnZXQuZXh0ZW5kKHt9LCBuKSA6IG4pOyByZXR1cm4gZSB9LCB0LndpZGdldC5icmlkZ2UgPSBmdW5jdGlvbihlLCBzKSB7IHZhciBuID0gcy5wcm90b3R5cGUud2lkZ2V0RnVsbE5hbWUgfHwgZTtcbiAgICAgICAgICAgIHQuZm5bZV0gPSBmdW5jdGlvbihvKSB7IHZhciBhID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgbyxcbiAgICAgICAgICAgICAgICAgICAgciA9IGkuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgICAgICAgICBsID0gdGhpczsgcmV0dXJuIGEgPyB0aGlzLmxlbmd0aCB8fCBcImluc3RhbmNlXCIgIT09IG8gPyB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IHZhciBpLCBzID0gdC5kYXRhKHRoaXMsIG4pOyByZXR1cm4gXCJpbnN0YW5jZVwiID09PSBvID8gKGwgPSBzLCAhMSkgOiBzID8gdC5pc0Z1bmN0aW9uKHNbb10pICYmIFwiX1wiICE9PSBvLmNoYXJBdCgwKSA/IChpID0gc1tvXS5hcHBseShzLCByKSwgaSAhPT0gcyAmJiB2b2lkIDAgIT09IGkgPyAobCA9IGkgJiYgaS5qcXVlcnkgPyBsLnB1c2hTdGFjayhpLmdldCgpKSA6IGksICExKSA6IHZvaWQgMCkgOiB0LmVycm9yKFwibm8gc3VjaCBtZXRob2QgJ1wiICsgbyArIFwiJyBmb3IgXCIgKyBlICsgXCIgd2lkZ2V0IGluc3RhbmNlXCIpIDogdC5lcnJvcihcImNhbm5vdCBjYWxsIG1ldGhvZHMgb24gXCIgKyBlICsgXCIgcHJpb3IgdG8gaW5pdGlhbGl6YXRpb247IFwiICsgXCJhdHRlbXB0ZWQgdG8gY2FsbCBtZXRob2QgJ1wiICsgbyArIFwiJ1wiKSB9KSA6IGwgPSB2b2lkIDAgOiAoci5sZW5ndGggJiYgKG8gPSB0LndpZGdldC5leHRlbmQuYXBwbHkobnVsbCwgW29dLmNvbmNhdChyKSkpLCB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IHZhciBlID0gdC5kYXRhKHRoaXMsIG4pO1xuICAgICAgICAgICAgICAgICAgICBlID8gKGUub3B0aW9uKG8gfHwge30pLCBlLl9pbml0ICYmIGUuX2luaXQoKSkgOiB0LmRhdGEodGhpcywgbiwgbmV3IHMobywgdGhpcykpIH0pKSwgbCB9IH0sIHQuV2lkZ2V0ID0gZnVuY3Rpb24oKSB7fSwgdC5XaWRnZXQuX2NoaWxkQ29uc3RydWN0b3JzID0gW10sIHQuV2lkZ2V0LnByb3RvdHlwZSA9IHsgd2lkZ2V0TmFtZTogXCJ3aWRnZXRcIiwgd2lkZ2V0RXZlbnRQcmVmaXg6IFwiXCIsIGRlZmF1bHRFbGVtZW50OiBcIjxkaXY+XCIsIG9wdGlvbnM6IHsgY2xhc3Nlczoge30sIGRpc2FibGVkOiAhMSwgY3JlYXRlOiBudWxsIH0sIF9jcmVhdGVXaWRnZXQ6IGZ1bmN0aW9uKGksIHMpIHsgcyA9IHQocyB8fCB0aGlzLmRlZmF1bHRFbGVtZW50IHx8IHRoaXMpWzBdLCB0aGlzLmVsZW1lbnQgPSB0KHMpLCB0aGlzLnV1aWQgPSBlKyssIHRoaXMuZXZlbnROYW1lc3BhY2UgPSBcIi5cIiArIHRoaXMud2lkZ2V0TmFtZSArIHRoaXMudXVpZCwgdGhpcy5iaW5kaW5ncyA9IHQoKSwgdGhpcy5ob3ZlcmFibGUgPSB0KCksIHRoaXMuZm9jdXNhYmxlID0gdCgpLCB0aGlzLmNsYXNzZXNFbGVtZW50TG9va3VwID0ge30sIHMgIT09IHRoaXMgJiYgKHQuZGF0YShzLCB0aGlzLndpZGdldEZ1bGxOYW1lLCB0aGlzKSwgdGhpcy5fb24oITAsIHRoaXMuZWxlbWVudCwgeyByZW1vdmU6IGZ1bmN0aW9uKHQpIHsgdC50YXJnZXQgPT09IHMgJiYgdGhpcy5kZXN0cm95KCkgfSB9KSwgdGhpcy5kb2N1bWVudCA9IHQocy5zdHlsZSA/IHMub3duZXJEb2N1bWVudCA6IHMuZG9jdW1lbnQgfHwgcyksIHRoaXMud2luZG93ID0gdCh0aGlzLmRvY3VtZW50WzBdLmRlZmF1bHRWaWV3IHx8IHRoaXMuZG9jdW1lbnRbMF0ucGFyZW50V2luZG93KSksIHRoaXMub3B0aW9ucyA9IHQud2lkZ2V0LmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCB0aGlzLl9nZXRDcmVhdGVPcHRpb25zKCksIGkpLCB0aGlzLl9jcmVhdGUoKSwgdGhpcy5vcHRpb25zLmRpc2FibGVkICYmIHRoaXMuX3NldE9wdGlvbkRpc2FibGVkKHRoaXMub3B0aW9ucy5kaXNhYmxlZCksIHRoaXMuX3RyaWdnZXIoXCJjcmVhdGVcIiwgbnVsbCwgdGhpcy5fZ2V0Q3JlYXRlRXZlbnREYXRhKCkpLCB0aGlzLl9pbml0KCkgfSwgX2dldENyZWF0ZU9wdGlvbnM6IGZ1bmN0aW9uKCkgeyByZXR1cm4ge30gfSwgX2dldENyZWF0ZUV2ZW50RGF0YTogdC5ub29wLCBfY3JlYXRlOiB0Lm5vb3AsIF9pbml0OiB0Lm5vb3AsIGRlc3Ryb3k6IGZ1bmN0aW9uKCkgeyB2YXIgZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzdHJveSgpLCB0LmVhY2godGhpcy5jbGFzc2VzRWxlbWVudExvb2t1cCwgZnVuY3Rpb24odCwgaSkgeyBlLl9yZW1vdmVDbGFzcyhpLCB0KSB9KSwgdGhpcy5lbGVtZW50Lm9mZih0aGlzLmV2ZW50TmFtZXNwYWNlKS5yZW1vdmVEYXRhKHRoaXMud2lkZ2V0RnVsbE5hbWUpLCB0aGlzLndpZGdldCgpLm9mZih0aGlzLmV2ZW50TmFtZXNwYWNlKS5yZW1vdmVBdHRyKFwiYXJpYS1kaXNhYmxlZFwiKSwgdGhpcy5iaW5kaW5ncy5vZmYodGhpcy5ldmVudE5hbWVzcGFjZSkgfSwgX2Rlc3Ryb3k6IHQubm9vcCwgd2lkZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZWxlbWVudCB9LCBvcHRpb246IGZ1bmN0aW9uKGUsIGkpIHsgdmFyIHMsIG4sIG8sIGEgPSBlOyBpZiAoMCA9PT0gYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHQud2lkZ2V0LmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zKTsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpXG4gICAgICAgICAgICAgICAgICAgIGlmIChhID0ge30sIHMgPSBlLnNwbGl0KFwiLlwiKSwgZSA9IHMuc2hpZnQoKSwgcy5sZW5ndGgpIHsgZm9yIChuID0gYVtlXSA9IHQud2lkZ2V0LmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zW2VdKSwgbyA9IDA7IHMubGVuZ3RoIC0gMSA+IG87IG8rKykgbltzW29dXSA9IG5bc1tvXV0gfHwge30sIG4gPSBuW3Nbb11dOyBpZiAoZSA9IHMucG9wKCksIDEgPT09IGFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2b2lkIDAgPT09IG5bZV0gPyBudWxsIDogbltlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5bZV0gPSBpIH0gZWxzZSB7IGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdm9pZCAwID09PSB0aGlzLm9wdGlvbnNbZV0gPyBudWxsIDogdGhpcy5vcHRpb25zW2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYVtlXSA9IGkgfSByZXR1cm4gdGhpcy5fc2V0T3B0aW9ucyhhKSwgdGhpcyB9LCBfc2V0T3B0aW9uczogZnVuY3Rpb24odCkgeyB2YXIgZTsgZm9yIChlIGluIHQpIHRoaXMuX3NldE9wdGlvbihlLCB0W2VdKTsgcmV0dXJuIHRoaXMgfSwgX3NldE9wdGlvbjogZnVuY3Rpb24odCwgZSkgeyByZXR1cm4gXCJjbGFzc2VzXCIgPT09IHQgJiYgdGhpcy5fc2V0T3B0aW9uQ2xhc3NlcyhlKSwgdGhpcy5vcHRpb25zW3RdID0gZSwgXCJkaXNhYmxlZFwiID09PSB0ICYmIHRoaXMuX3NldE9wdGlvbkRpc2FibGVkKGUpLCB0aGlzIH0sIF9zZXRPcHRpb25DbGFzc2VzOiBmdW5jdGlvbihlKSB7IHZhciBpLCBzLCBuOyBmb3IgKGkgaW4gZSkgbiA9IHRoaXMuY2xhc3Nlc0VsZW1lbnRMb29rdXBbaV0sIGVbaV0gIT09IHRoaXMub3B0aW9ucy5jbGFzc2VzW2ldICYmIG4gJiYgbi5sZW5ndGggJiYgKHMgPSB0KG4uZ2V0KCkpLCB0aGlzLl9yZW1vdmVDbGFzcyhuLCBpKSwgcy5hZGRDbGFzcyh0aGlzLl9jbGFzc2VzKHsgZWxlbWVudDogcywga2V5czogaSwgY2xhc3NlczogZSwgYWRkOiAhMCB9KSkpIH0sIF9zZXRPcHRpb25EaXNhYmxlZDogZnVuY3Rpb24odCkgeyB0aGlzLl90b2dnbGVDbGFzcyh0aGlzLndpZGdldCgpLCB0aGlzLndpZGdldEZ1bGxOYW1lICsgXCItZGlzYWJsZWRcIiwgbnVsbCwgISF0KSwgdCAmJiAodGhpcy5fcmVtb3ZlQ2xhc3ModGhpcy5ob3ZlcmFibGUsIG51bGwsIFwidWktc3RhdGUtaG92ZXJcIiksIHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMuZm9jdXNhYmxlLCBudWxsLCBcInVpLXN0YXRlLWZvY3VzXCIpKSB9LCBlbmFibGU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fc2V0T3B0aW9ucyh7IGRpc2FibGVkOiAhMSB9KSB9LCBkaXNhYmxlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3NldE9wdGlvbnMoeyBkaXNhYmxlZDogITAgfSkgfSwgX2NsYXNzZXM6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpKGksIG8pIHsgdmFyIGEsIHI7IGZvciAociA9IDA7IGkubGVuZ3RoID4gcjsgcisrKSBhID0gbi5jbGFzc2VzRWxlbWVudExvb2t1cFtpW3JdXSB8fCB0KCksIGEgPSBlLmFkZCA/IHQodC51bmlxdWUoYS5nZXQoKS5jb25jYXQoZS5lbGVtZW50LmdldCgpKSkpIDogdChhLm5vdChlLmVsZW1lbnQpLmdldCgpKSwgbi5jbGFzc2VzRWxlbWVudExvb2t1cFtpW3JdXSA9IGEsIHMucHVzaChpW3JdKSwgbyAmJiBlLmNsYXNzZXNbaVtyXV0gJiYgcy5wdXNoKGUuY2xhc3Nlc1tpW3JdXSkgfSB2YXIgcyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBuID0gdGhpczsgcmV0dXJuIGUgPSB0LmV4dGVuZCh7IGVsZW1lbnQ6IHRoaXMuZWxlbWVudCwgY2xhc3NlczogdGhpcy5vcHRpb25zLmNsYXNzZXMgfHwge30gfSwgZSksIHRoaXMuX29uKGUuZWxlbWVudCwgeyByZW1vdmU6IFwiX3VudHJhY2tDbGFzc2VzRWxlbWVudFwiIH0pLCBlLmtleXMgJiYgaShlLmtleXMubWF0Y2goL1xcUysvZykgfHwgW10sICEwKSwgZS5leHRyYSAmJiBpKGUuZXh0cmEubWF0Y2goL1xcUysvZykgfHwgW10pLCBzLmpvaW4oXCIgXCIpIH0sIF91bnRyYWNrQ2xhc3Nlc0VsZW1lbnQ6IGZ1bmN0aW9uKGUpIHsgdmFyIGkgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHQuZWFjaChpLmNsYXNzZXNFbGVtZW50TG9va3VwLCBmdW5jdGlvbihzLCBuKSB7LTEgIT09IHQuaW5BcnJheShlLnRhcmdldCwgbikgJiYgKGkuY2xhc3Nlc0VsZW1lbnRMb29rdXBbc10gPSB0KG4ubm90KGUudGFyZ2V0KS5nZXQoKSkpIH0pIH0sIF9yZW1vdmVDbGFzczogZnVuY3Rpb24odCwgZSwgaSkgeyByZXR1cm4gdGhpcy5fdG9nZ2xlQ2xhc3ModCwgZSwgaSwgITEpIH0sIF9hZGRDbGFzczogZnVuY3Rpb24odCwgZSwgaSkgeyByZXR1cm4gdGhpcy5fdG9nZ2xlQ2xhc3ModCwgZSwgaSwgITApIH0sIF90b2dnbGVDbGFzczogZnVuY3Rpb24odCwgZSwgaSwgcykgeyBzID0gXCJib29sZWFuXCIgPT0gdHlwZW9mIHMgPyBzIDogaTsgdmFyIG4gPSBcInN0cmluZ1wiID09IHR5cGVvZiB0IHx8IG51bGwgPT09IHQsXG4gICAgICAgICAgICAgICAgICAgIG8gPSB7IGV4dHJhOiBuID8gZSA6IGksIGtleXM6IG4gPyB0IDogZSwgZWxlbWVudDogbiA/IHRoaXMuZWxlbWVudCA6IHQsIGFkZDogcyB9OyByZXR1cm4gby5lbGVtZW50LnRvZ2dsZUNsYXNzKHRoaXMuX2NsYXNzZXMobyksIHMpLCB0aGlzIH0sIF9vbjogZnVuY3Rpb24oZSwgaSwgcykgeyB2YXIgbiwgbyA9IHRoaXM7IFwiYm9vbGVhblwiICE9IHR5cGVvZiBlICYmIChzID0gaSwgaSA9IGUsIGUgPSAhMSksIHMgPyAoaSA9IG4gPSB0KGkpLCB0aGlzLmJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5hZGQoaSkpIDogKHMgPSBpLCBpID0gdGhpcy5lbGVtZW50LCBuID0gdGhpcy53aWRnZXQoKSksIHQuZWFjaChzLCBmdW5jdGlvbihzLCBhKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHIoKSB7IHJldHVybiBlIHx8IG8ub3B0aW9ucy5kaXNhYmxlZCAhPT0gITAgJiYgIXQodGhpcykuaGFzQ2xhc3MoXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiKSA/IChcInN0cmluZ1wiID09IHR5cGVvZiBhID8gb1thXSA6IGEpLmFwcGx5KG8sIGFyZ3VtZW50cykgOiB2b2lkIDAgfSBcInN0cmluZ1wiICE9IHR5cGVvZiBhICYmIChyLmd1aWQgPSBhLmd1aWQgPSBhLmd1aWQgfHwgci5ndWlkIHx8IHQuZ3VpZCsrKTsgdmFyIGwgPSBzLm1hdGNoKC9eKFtcXHc6LV0qKVxccyooLiopJC8pLFxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IGxbMV0gKyBvLmV2ZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGxbMl07XG4gICAgICAgICAgICAgICAgICAgIGMgPyBuLm9uKGgsIGMsIHIpIDogaS5vbihoLCByKSB9KSB9LCBfb2ZmOiBmdW5jdGlvbihlLCBpKSB7IGkgPSAoaSB8fCBcIlwiKS5zcGxpdChcIiBcIikuam9pbih0aGlzLmV2ZW50TmFtZXNwYWNlICsgXCIgXCIpICsgdGhpcy5ldmVudE5hbWVzcGFjZSwgZS5vZmYoaSkub2ZmKGkpLCB0aGlzLmJpbmRpbmdzID0gdCh0aGlzLmJpbmRpbmdzLm5vdChlKS5nZXQoKSksIHRoaXMuZm9jdXNhYmxlID0gdCh0aGlzLmZvY3VzYWJsZS5ub3QoZSkuZ2V0KCkpLCB0aGlzLmhvdmVyYWJsZSA9IHQodGhpcy5ob3ZlcmFibGUubm90KGUpLmdldCgpKSB9LCBfZGVsYXk6IGZ1bmN0aW9uKHQsIGUpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBpKCkgeyByZXR1cm4gKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgPyBzW3RdIDogdCkuYXBwbHkocywgYXJndW1lbnRzKSB9IHZhciBzID0gdGhpczsgcmV0dXJuIHNldFRpbWVvdXQoaSwgZSB8fCAwKSB9LCBfaG92ZXJhYmxlOiBmdW5jdGlvbihlKSB7IHRoaXMuaG92ZXJhYmxlID0gdGhpcy5ob3ZlcmFibGUuYWRkKGUpLCB0aGlzLl9vbihlLCB7IG1vdXNlZW50ZXI6IGZ1bmN0aW9uKGUpIHsgdGhpcy5fYWRkQ2xhc3ModChlLmN1cnJlbnRUYXJnZXQpLCBudWxsLCBcInVpLXN0YXRlLWhvdmVyXCIpIH0sIG1vdXNlbGVhdmU6IGZ1bmN0aW9uKGUpIHsgdGhpcy5fcmVtb3ZlQ2xhc3ModChlLmN1cnJlbnRUYXJnZXQpLCBudWxsLCBcInVpLXN0YXRlLWhvdmVyXCIpIH0gfSkgfSwgX2ZvY3VzYWJsZTogZnVuY3Rpb24oZSkgeyB0aGlzLmZvY3VzYWJsZSA9IHRoaXMuZm9jdXNhYmxlLmFkZChlKSwgdGhpcy5fb24oZSwgeyBmb2N1c2luOiBmdW5jdGlvbihlKSB7IHRoaXMuX2FkZENsYXNzKHQoZS5jdXJyZW50VGFyZ2V0KSwgbnVsbCwgXCJ1aS1zdGF0ZS1mb2N1c1wiKSB9LCBmb2N1c291dDogZnVuY3Rpb24oZSkgeyB0aGlzLl9yZW1vdmVDbGFzcyh0KGUuY3VycmVudFRhcmdldCksIG51bGwsIFwidWktc3RhdGUtZm9jdXNcIikgfSB9KSB9LCBfdHJpZ2dlcjogZnVuY3Rpb24oZSwgaSwgcykgeyB2YXIgbiwgbywgYSA9IHRoaXMub3B0aW9uc1tlXTsgaWYgKHMgPSBzIHx8IHt9LCBpID0gdC5FdmVudChpKSwgaS50eXBlID0gKGUgPT09IHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggPyBlIDogdGhpcy53aWRnZXRFdmVudFByZWZpeCArIGUpLnRvTG93ZXJDYXNlKCksIGkudGFyZ2V0ID0gdGhpcy5lbGVtZW50WzBdLCBvID0gaS5vcmlnaW5hbEV2ZW50KVxuICAgICAgICAgICAgICAgICAgICBmb3IgKG4gaW4gbykgbiBpbiBpIHx8IChpW25dID0gb1tuXSk7IHJldHVybiB0aGlzLmVsZW1lbnQudHJpZ2dlcihpLCBzKSwgISh0LmlzRnVuY3Rpb24oYSkgJiYgYS5hcHBseSh0aGlzLmVsZW1lbnRbMF0sIFtpXS5jb25jYXQocykpID09PSAhMSB8fCBpLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB9IH0sIHQuZWFjaCh7IHNob3c6IFwiZmFkZUluXCIsIGhpZGU6IFwiZmFkZU91dFwiIH0sIGZ1bmN0aW9uKGUsIGkpIHsgdC5XaWRnZXQucHJvdG90eXBlW1wiX1wiICsgZV0gPSBmdW5jdGlvbihzLCBuLCBvKSB7IFwic3RyaW5nXCIgPT0gdHlwZW9mIG4gJiYgKG4gPSB7IGVmZmVjdDogbiB9KTsgdmFyIGEsIHIgPSBuID8gbiA9PT0gITAgfHwgXCJudW1iZXJcIiA9PSB0eXBlb2YgbiA/IGkgOiBuLmVmZmVjdCB8fCBpIDogZTtcbiAgICAgICAgICAgICAgICBuID0gbiB8fCB7fSwgXCJudW1iZXJcIiA9PSB0eXBlb2YgbiAmJiAobiA9IHsgZHVyYXRpb246IG4gfSksIGEgPSAhdC5pc0VtcHR5T2JqZWN0KG4pLCBuLmNvbXBsZXRlID0gbywgbi5kZWxheSAmJiBzLmRlbGF5KG4uZGVsYXkpLCBhICYmIHQuZWZmZWN0cyAmJiB0LmVmZmVjdHMuZWZmZWN0W3JdID8gc1tlXShuKSA6IHIgIT09IGUgJiYgc1tyXSA/IHNbcl0obi5kdXJhdGlvbiwgbi5lYXNpbmcsIG8pIDogcy5xdWV1ZShmdW5jdGlvbihpKSB7IHQodGhpcylbZV0oKSwgbyAmJiBvLmNhbGwoc1swXSksIGkoKSB9KSB9IH0pLCB0LndpZGdldCxcbiAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBlKHQsIGUsIGkpIHsgcmV0dXJuIFtwYXJzZUZsb2F0KHRbMF0pICogKHUudGVzdCh0WzBdKSA/IGUgLyAxMDAgOiAxKSwgcGFyc2VGbG9hdCh0WzFdKSAqICh1LnRlc3QodFsxXSkgPyBpIC8gMTAwIDogMSldIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaShlLCBpKSB7IHJldHVybiBwYXJzZUludCh0LmNzcyhlLCBpKSwgMTApIHx8IDAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBzKGUpIHsgdmFyIGkgPSBlWzBdOyByZXR1cm4gOSA9PT0gaS5ub2RlVHlwZSA/IHsgd2lkdGg6IGUud2lkdGgoKSwgaGVpZ2h0OiBlLmhlaWdodCgpLCBvZmZzZXQ6IHsgdG9wOiAwLCBsZWZ0OiAwIH0gfSA6IHQuaXNXaW5kb3coaSkgPyB7IHdpZHRoOiBlLndpZHRoKCksIGhlaWdodDogZS5oZWlnaHQoKSwgb2Zmc2V0OiB7IHRvcDogZS5zY3JvbGxUb3AoKSwgbGVmdDogZS5zY3JvbGxMZWZ0KCkgfSB9IDogaS5wcmV2ZW50RGVmYXVsdCA/IHsgd2lkdGg6IDAsIGhlaWdodDogMCwgb2Zmc2V0OiB7IHRvcDogaS5wYWdlWSwgbGVmdDogaS5wYWdlWCB9IH0gOiB7IHdpZHRoOiBlLm91dGVyV2lkdGgoKSwgaGVpZ2h0OiBlLm91dGVySGVpZ2h0KCksIG9mZnNldDogZS5vZmZzZXQoKSB9IH0gdmFyIG4sIG8gPSBNYXRoLm1heCxcbiAgICAgICAgICAgICAgICBhID0gTWF0aC5hYnMsXG4gICAgICAgICAgICAgICAgciA9IC9sZWZ0fGNlbnRlcnxyaWdodC8sXG4gICAgICAgICAgICAgICAgbCA9IC90b3B8Y2VudGVyfGJvdHRvbS8sXG4gICAgICAgICAgICAgICAgaCA9IC9bXFwrXFwtXVxcZCsoXFwuW1xcZF0rKT8lPy8sXG4gICAgICAgICAgICAgICAgYyA9IC9eXFx3Ky8sXG4gICAgICAgICAgICAgICAgdSA9IC8lJC8sXG4gICAgICAgICAgICAgICAgZCA9IHQuZm4ucG9zaXRpb247XG4gICAgICAgICAgICB0LnBvc2l0aW9uID0geyBzY3JvbGxiYXJXaWR0aDogZnVuY3Rpb24oKSB7IGlmICh2b2lkIDAgIT09IG4pIHJldHVybiBuOyB2YXIgZSwgaSwgcyA9IHQoXCI8ZGl2IHN0eWxlPSdkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjUwcHg7aGVpZ2h0OjUwcHg7b3ZlcmZsb3c6aGlkZGVuOyc+PGRpdiBzdHlsZT0naGVpZ2h0OjEwMHB4O3dpZHRoOmF1dG87Jz48L2Rpdj48L2Rpdj5cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gcy5jaGlsZHJlbigpWzBdOyByZXR1cm4gdChcImJvZHlcIikuYXBwZW5kKHMpLCBlID0gby5vZmZzZXRXaWR0aCwgcy5jc3MoXCJvdmVyZmxvd1wiLCBcInNjcm9sbFwiKSwgaSA9IG8ub2Zmc2V0V2lkdGgsIGUgPT09IGkgJiYgKGkgPSBzWzBdLmNsaWVudFdpZHRoKSwgcy5yZW1vdmUoKSwgbiA9IGUgLSBpIH0sIGdldFNjcm9sbEluZm86IGZ1bmN0aW9uKGUpIHsgdmFyIGkgPSBlLmlzV2luZG93IHx8IGUuaXNEb2N1bWVudCA/IFwiXCIgOiBlLmVsZW1lbnQuY3NzKFwib3ZlcmZsb3cteFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBlLmlzV2luZG93IHx8IGUuaXNEb2N1bWVudCA/IFwiXCIgOiBlLmVsZW1lbnQuY3NzKFwib3ZlcmZsb3cteVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBcInNjcm9sbFwiID09PSBpIHx8IFwiYXV0b1wiID09PSBpICYmIGUud2lkdGggPCBlLmVsZW1lbnRbMF0uc2Nyb2xsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBvID0gXCJzY3JvbGxcIiA9PT0gcyB8fCBcImF1dG9cIiA9PT0gcyAmJiBlLmhlaWdodCA8IGUuZWxlbWVudFswXS5zY3JvbGxIZWlnaHQ7IHJldHVybiB7IHdpZHRoOiBvID8gdC5wb3NpdGlvbi5zY3JvbGxiYXJXaWR0aCgpIDogMCwgaGVpZ2h0OiBuID8gdC5wb3NpdGlvbi5zY3JvbGxiYXJXaWR0aCgpIDogMCB9IH0sIGdldFdpdGhpbkluZm86IGZ1bmN0aW9uKGUpIHsgdmFyIGkgPSB0KGUgfHwgd2luZG93KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSB0LmlzV2luZG93KGlbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9ICEhaVswXSAmJiA5ID09PSBpWzBdLm5vZGVUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbyA9ICFzICYmICFuOyByZXR1cm4geyBlbGVtZW50OiBpLCBpc1dpbmRvdzogcywgaXNEb2N1bWVudDogbiwgb2Zmc2V0OiBvID8gdChlKS5vZmZzZXQoKSA6IHsgbGVmdDogMCwgdG9wOiAwIH0sIHNjcm9sbExlZnQ6IGkuc2Nyb2xsTGVmdCgpLCBzY3JvbGxUb3A6IGkuc2Nyb2xsVG9wKCksIHdpZHRoOiBpLm91dGVyV2lkdGgoKSwgaGVpZ2h0OiBpLm91dGVySGVpZ2h0KCkgfSB9IH0sIHQuZm4ucG9zaXRpb24gPSBmdW5jdGlvbihuKSB7IGlmICghbiB8fCAhbi5vZikgcmV0dXJuIGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBuID0gdC5leHRlbmQoe30sIG4pOyB2YXIgdSwgcCwgZiwgZywgbSwgXywgdiA9IHQobi5vZiksXG4gICAgICAgICAgICAgICAgICAgIGIgPSB0LnBvc2l0aW9uLmdldFdpdGhpbkluZm8obi53aXRoaW4pLFxuICAgICAgICAgICAgICAgICAgICB5ID0gdC5wb3NpdGlvbi5nZXRTY3JvbGxJbmZvKGIpLFxuICAgICAgICAgICAgICAgICAgICB3ID0gKG4uY29sbGlzaW9uIHx8IFwiZmxpcFwiKS5zcGxpdChcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgIGsgPSB7fTsgcmV0dXJuIF8gPSBzKHYpLCB2WzBdLnByZXZlbnREZWZhdWx0ICYmIChuLmF0ID0gXCJsZWZ0IHRvcFwiKSwgcCA9IF8ud2lkdGgsIGYgPSBfLmhlaWdodCwgZyA9IF8ub2Zmc2V0LCBtID0gdC5leHRlbmQoe30sIGcpLCB0LmVhY2goW1wibXlcIiwgXCJhdFwiXSwgZnVuY3Rpb24oKSB7IHZhciB0LCBlLCBpID0gKG5bdGhpc10gfHwgXCJcIikuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICAxID09PSBpLmxlbmd0aCAmJiAoaSA9IHIudGVzdChpWzBdKSA/IGkuY29uY2F0KFtcImNlbnRlclwiXSkgOiBsLnRlc3QoaVswXSkgPyBbXCJjZW50ZXJcIl0uY29uY2F0KGkpIDogW1wiY2VudGVyXCIsIFwiY2VudGVyXCJdKSwgaVswXSA9IHIudGVzdChpWzBdKSA/IGlbMF0gOiBcImNlbnRlclwiLCBpWzFdID0gbC50ZXN0KGlbMV0pID8gaVsxXSA6IFwiY2VudGVyXCIsIHQgPSBoLmV4ZWMoaVswXSksIGUgPSBoLmV4ZWMoaVsxXSksIGtbdGhpc10gPSBbdCA/IHRbMF0gOiAwLCBlID8gZVswXSA6IDBdLCBuW3RoaXNdID0gW2MuZXhlYyhpWzBdKVswXSwgYy5leGVjKGlbMV0pWzBdXSB9KSwgMSA9PT0gdy5sZW5ndGggJiYgKHdbMV0gPSB3WzBdKSwgXCJyaWdodFwiID09PSBuLmF0WzBdID8gbS5sZWZ0ICs9IHAgOiBcImNlbnRlclwiID09PSBuLmF0WzBdICYmIChtLmxlZnQgKz0gcCAvIDIpLCBcImJvdHRvbVwiID09PSBuLmF0WzFdID8gbS50b3AgKz0gZiA6IFwiY2VudGVyXCIgPT09IG4uYXRbMV0gJiYgKG0udG9wICs9IGYgLyAyKSwgdSA9IGUoay5hdCwgcCwgZiksIG0ubGVmdCArPSB1WzBdLCBtLnRvcCArPSB1WzFdLCB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IHZhciBzLCByLCBsID0gdCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSBsLm91dGVyV2lkdGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBsLm91dGVySGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gaSh0aGlzLCBcIm1hcmdpbkxlZnRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBfID0gaSh0aGlzLCBcIm1hcmdpblRvcFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBoICsgZCArIGkodGhpcywgXCJtYXJnaW5SaWdodFwiKSArIHkud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBDID0gYyArIF8gKyBpKHRoaXMsIFwibWFyZ2luQm90dG9tXCIpICsgeS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBEID0gdC5leHRlbmQoe30sIG0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgVCA9IGUoay5teSwgbC5vdXRlcldpZHRoKCksIGwub3V0ZXJIZWlnaHQoKSk7IFwicmlnaHRcIiA9PT0gbi5teVswXSA/IEQubGVmdCAtPSBoIDogXCJjZW50ZXJcIiA9PT0gbi5teVswXSAmJiAoRC5sZWZ0IC09IGggLyAyKSwgXCJib3R0b21cIiA9PT0gbi5teVsxXSA/IEQudG9wIC09IGMgOiBcImNlbnRlclwiID09PSBuLm15WzFdICYmIChELnRvcCAtPSBjIC8gMiksIEQubGVmdCArPSBUWzBdLCBELnRvcCArPSBUWzFdLCBzID0geyBtYXJnaW5MZWZ0OiBkLCBtYXJnaW5Ub3A6IF8gfSwgdC5lYWNoKFtcImxlZnRcIiwgXCJ0b3BcIl0sIGZ1bmN0aW9uKGUsIGkpIHsgdC51aS5wb3NpdGlvblt3W2VdXSAmJiB0LnVpLnBvc2l0aW9uW3dbZV1dW2ldKEQsIHsgdGFyZ2V0V2lkdGg6IHAsIHRhcmdldEhlaWdodDogZiwgZWxlbVdpZHRoOiBoLCBlbGVtSGVpZ2h0OiBjLCBjb2xsaXNpb25Qb3NpdGlvbjogcywgY29sbGlzaW9uV2lkdGg6IHgsIGNvbGxpc2lvbkhlaWdodDogQywgb2Zmc2V0OiBbdVswXSArIFRbMF0sIHVbMV0gKyBUWzFdXSwgbXk6IG4ubXksIGF0OiBuLmF0LCB3aXRoaW46IGIsIGVsZW06IGwgfSkgfSksIG4udXNpbmcgJiYgKHIgPSBmdW5jdGlvbih0KSB7IHZhciBlID0gZy5sZWZ0IC0gRC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBlICsgcCAtIGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IGcudG9wIC0gRC50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHMgKyBmIC0gYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ID0geyB0YXJnZXQ6IHsgZWxlbWVudDogdiwgbGVmdDogZy5sZWZ0LCB0b3A6IGcudG9wLCB3aWR0aDogcCwgaGVpZ2h0OiBmIH0sIGVsZW1lbnQ6IHsgZWxlbWVudDogbCwgbGVmdDogRC5sZWZ0LCB0b3A6IEQudG9wLCB3aWR0aDogaCwgaGVpZ2h0OiBjIH0sIGhvcml6b250YWw6IDAgPiBpID8gXCJsZWZ0XCIgOiBlID4gMCA/IFwicmlnaHRcIiA6IFwiY2VudGVyXCIsIHZlcnRpY2FsOiAwID4gciA/IFwidG9wXCIgOiBzID4gMCA/IFwiYm90dG9tXCIgOiBcIm1pZGRsZVwiIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBoID4gcCAmJiBwID4gYShlICsgaSkgJiYgKHUuaG9yaXpvbnRhbCA9IFwiY2VudGVyXCIpLCBjID4gZiAmJiBmID4gYShzICsgcikgJiYgKHUudmVydGljYWwgPSBcIm1pZGRsZVwiKSwgdS5pbXBvcnRhbnQgPSBvKGEoZSksIGEoaSkpID4gbyhhKHMpLCBhKHIpKSA/IFwiaG9yaXpvbnRhbFwiIDogXCJ2ZXJ0aWNhbFwiLCBuLnVzaW5nLmNhbGwodGhpcywgdCwgdSkgfSksIGwub2Zmc2V0KHQuZXh0ZW5kKEQsIHsgdXNpbmc6IHIgfSkpIH0pIH0sIHQudWkucG9zaXRpb24gPSB7IGZpdDogeyBsZWZ0OiBmdW5jdGlvbih0LCBlKSB7IHZhciBpLCBzID0gZS53aXRoaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IHMuaXNXaW5kb3cgPyBzLnNjcm9sbExlZnQgOiBzLm9mZnNldC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSB0LmxlZnQgLSBlLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IG4gLSByLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSByICsgZS5jb2xsaXNpb25XaWR0aCAtIGEgLSBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5jb2xsaXNpb25XaWR0aCA+IGEgPyBsID4gMCAmJiAwID49IGggPyAoaSA9IHQubGVmdCArIGwgKyBlLmNvbGxpc2lvbldpZHRoIC0gYSAtIG4sIHQubGVmdCArPSBsIC0gaSkgOiB0LmxlZnQgPSBoID4gMCAmJiAwID49IGwgPyBuIDogbCA+IGggPyBuICsgYSAtIGUuY29sbGlzaW9uV2lkdGggOiBuIDogbCA+IDAgPyB0LmxlZnQgKz0gbCA6IGggPiAwID8gdC5sZWZ0IC09IGggOiB0LmxlZnQgPSBvKHQubGVmdCAtIHIsIHQubGVmdCkgfSwgdG9wOiBmdW5jdGlvbih0LCBlKSB7IHZhciBpLCBzID0gZS53aXRoaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IHMuaXNXaW5kb3cgPyBzLnNjcm9sbFRvcCA6IHMub2Zmc2V0LnRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gZS53aXRoaW4uaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIgPSB0LnRvcCAtIGUuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBuIC0gcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoID0gciArIGUuY29sbGlzaW9uSGVpZ2h0IC0gYSAtIG47XG4gICAgICAgICAgICAgICAgICAgICAgICBlLmNvbGxpc2lvbkhlaWdodCA+IGEgPyBsID4gMCAmJiAwID49IGggPyAoaSA9IHQudG9wICsgbCArIGUuY29sbGlzaW9uSGVpZ2h0IC0gYSAtIG4sIHQudG9wICs9IGwgLSBpKSA6IHQudG9wID0gaCA+IDAgJiYgMCA+PSBsID8gbiA6IGwgPiBoID8gbiArIGEgLSBlLmNvbGxpc2lvbkhlaWdodCA6IG4gOiBsID4gMCA/IHQudG9wICs9IGwgOiBoID4gMCA/IHQudG9wIC09IGggOiB0LnRvcCA9IG8odC50b3AgLSByLCB0LnRvcCkgfSB9LCBmbGlwOiB7IGxlZnQ6IGZ1bmN0aW9uKHQsIGUpIHsgdmFyIGksIHMsIG4gPSBlLndpdGhpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gbi5vZmZzZXQubGVmdCArIG4uc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gbi53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gbi5pc1dpbmRvdyA/IG4uc2Nyb2xsTGVmdCA6IG4ub2Zmc2V0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHQubGVmdCAtIGUuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gaCAtIGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdSA9IGggKyBlLmNvbGxpc2lvbldpZHRoIC0gciAtIGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9IFwibGVmdFwiID09PSBlLm15WzBdID8gLWUuZWxlbVdpZHRoIDogXCJyaWdodFwiID09PSBlLm15WzBdID8gZS5lbGVtV2lkdGggOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBcImxlZnRcIiA9PT0gZS5hdFswXSA/IGUudGFyZ2V0V2lkdGggOiBcInJpZ2h0XCIgPT09IGUuYXRbMF0gPyAtZS50YXJnZXRXaWR0aCA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IC0yICogZS5vZmZzZXRbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAwID4gYyA/IChpID0gdC5sZWZ0ICsgZCArIHAgKyBmICsgZS5jb2xsaXNpb25XaWR0aCAtIHIgLSBvLCAoMCA+IGkgfHwgYShjKSA+IGkpICYmICh0LmxlZnQgKz0gZCArIHAgKyBmKSkgOiB1ID4gMCAmJiAocyA9IHQubGVmdCAtIGUuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luTGVmdCArIGQgKyBwICsgZiAtIGwsIChzID4gMCB8fCB1ID4gYShzKSkgJiYgKHQubGVmdCArPSBkICsgcCArIGYpKSB9LCB0b3A6IGZ1bmN0aW9uKHQsIGUpIHsgdmFyIGksIHMsIG4gPSBlLndpdGhpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0gbi5vZmZzZXQudG9wICsgbi5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IG4uaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBuLmlzV2luZG93ID8gbi5zY3JvbGxUb3AgOiBuLm9mZnNldC50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHQudG9wIC0gZS5jb2xsaXNpb25Qb3NpdGlvbi5tYXJnaW5Ub3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGggLSBsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBoICsgZS5jb2xsaXNpb25IZWlnaHQgLSByIC0gbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gXCJ0b3BcIiA9PT0gZS5teVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gZCA/IC1lLmVsZW1IZWlnaHQgOiBcImJvdHRvbVwiID09PSBlLm15WzFdID8gZS5lbGVtSGVpZ2h0IDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gXCJ0b3BcIiA9PT0gZS5hdFsxXSA/IGUudGFyZ2V0SGVpZ2h0IDogXCJib3R0b21cIiA9PT0gZS5hdFsxXSA/IC1lLnRhcmdldEhlaWdodCA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZyA9IC0yICogZS5vZmZzZXRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAwID4gYyA/IChzID0gdC50b3AgKyBwICsgZiArIGcgKyBlLmNvbGxpc2lvbkhlaWdodCAtIHIgLSBvLCAoMCA+IHMgfHwgYShjKSA+IHMpICYmICh0LnRvcCArPSBwICsgZiArIGcpKSA6IHUgPiAwICYmIChpID0gdC50b3AgLSBlLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpblRvcCArIHAgKyBmICsgZyAtIGwsIChpID4gMCB8fCB1ID4gYShpKSkgJiYgKHQudG9wICs9IHAgKyBmICsgZykpIH0gfSwgZmxpcGZpdDogeyBsZWZ0OiBmdW5jdGlvbigpIHsgdC51aS5wb3NpdGlvbi5mbGlwLmxlZnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdC51aS5wb3NpdGlvbi5maXQubGVmdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH0sIHRvcDogZnVuY3Rpb24oKSB7IHQudWkucG9zaXRpb24uZmxpcC50b3AuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdC51aS5wb3NpdGlvbi5maXQudG9wLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfSB9IH0gfSgpLCB0LnVpLnBvc2l0aW9uLCB0LnVpLmtleUNvZGUgPSB7IEJBQ0tTUEFDRTogOCwgQ09NTUE6IDE4OCwgREVMRVRFOiA0NiwgRE9XTjogNDAsIEVORDogMzUsIEVOVEVSOiAxMywgRVNDQVBFOiAyNywgSE9NRTogMzYsIExFRlQ6IDM3LCBQQUdFX0RPV046IDM0LCBQQUdFX1VQOiAzMywgUEVSSU9EOiAxOTAsIFJJR0hUOiAzOSwgU1BBQ0U6IDMyLCBUQUI6IDksIFVQOiAzOCB9LCB0LmZuLmV4dGVuZCh7IHVuaXF1ZUlkOiBmdW5jdGlvbigpIHsgdmFyIHQgPSAwOyByZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IHRoaXMuaWQgfHwgKHRoaXMuaWQgPSBcInVpLWlkLVwiICsgKyt0KSB9KSB9IH0oKSwgcmVtb3ZlVW5pcXVlSWQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyAvXnVpLWlkLVxcZCskLy50ZXN0KHRoaXMuaWQpICYmIHQodGhpcykucmVtb3ZlQXR0cihcImlkXCIpIH0pIH0gfSksIHQudWkuc2FmZUFjdGl2ZUVsZW1lbnQgPSBmdW5jdGlvbih0KSB7IHZhciBlOyB0cnkgeyBlID0gdC5hY3RpdmVFbGVtZW50IH0gY2F0Y2ggKGkpIHsgZSA9IHQuYm9keSB9IHJldHVybiBlIHx8IChlID0gdC5ib2R5KSwgZS5ub2RlTmFtZSB8fCAoZSA9IHQuYm9keSksIGUgfSwgdC53aWRnZXQoXCJ1aS5tZW51XCIsIHsgdmVyc2lvbjogXCIxLjEyLjFcIiwgZGVmYXVsdEVsZW1lbnQ6IFwiPHVsPlwiLCBkZWxheTogMzAwLCBvcHRpb25zOiB7IGljb25zOiB7IHN1Ym1lbnU6IFwidWktaWNvbi1jYXJldC0xLWVcIiB9LCBpdGVtczogXCI+ICpcIiwgbWVudXM6IFwidWxcIiwgcG9zaXRpb246IHsgbXk6IFwibGVmdCB0b3BcIiwgYXQ6IFwicmlnaHQgdG9wXCIgfSwgcm9sZTogXCJtZW51XCIsIGJsdXI6IG51bGwsIGZvY3VzOiBudWxsLCBzZWxlY3Q6IG51bGwgfSwgX2NyZWF0ZTogZnVuY3Rpb24oKSB7IHRoaXMuYWN0aXZlTWVudSA9IHRoaXMuZWxlbWVudCwgdGhpcy5tb3VzZUhhbmRsZWQgPSAhMSwgdGhpcy5lbGVtZW50LnVuaXF1ZUlkKCkuYXR0cih7IHJvbGU6IHRoaXMub3B0aW9ucy5yb2xlLCB0YWJJbmRleDogMCB9KSwgdGhpcy5fYWRkQ2xhc3MoXCJ1aS1tZW51XCIsIFwidWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50XCIpLCB0aGlzLl9vbih7IFwibW91c2Vkb3duIC51aS1tZW51LWl0ZW1cIjogZnVuY3Rpb24odCkgeyB0LnByZXZlbnREZWZhdWx0KCkgfSwgXCJjbGljayAudWktbWVudS1pdGVtXCI6IGZ1bmN0aW9uKGUpIHsgdmFyIGkgPSB0KGUudGFyZ2V0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gdCh0LnVpLnNhZmVBY3RpdmVFbGVtZW50KHRoaXMuZG9jdW1lbnRbMF0pKTshdGhpcy5tb3VzZUhhbmRsZWQgJiYgaS5ub3QoXCIudWktc3RhdGUtZGlzYWJsZWRcIikubGVuZ3RoICYmICh0aGlzLnNlbGVjdChlKSwgZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpIHx8ICh0aGlzLm1vdXNlSGFuZGxlZCA9ICEwKSwgaS5oYXMoXCIudWktbWVudVwiKS5sZW5ndGggPyB0aGlzLmV4cGFuZChlKSA6ICF0aGlzLmVsZW1lbnQuaXMoXCI6Zm9jdXNcIikgJiYgcy5jbG9zZXN0KFwiLnVpLW1lbnVcIikubGVuZ3RoICYmICh0aGlzLmVsZW1lbnQudHJpZ2dlcihcImZvY3VzXCIsIFshMF0pLCB0aGlzLmFjdGl2ZSAmJiAxID09PSB0aGlzLmFjdGl2ZS5wYXJlbnRzKFwiLnVpLW1lbnVcIikubGVuZ3RoICYmIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKSkpIH0sIFwibW91c2VlbnRlciAudWktbWVudS1pdGVtXCI6IGZ1bmN0aW9uKGUpIHsgaWYgKCF0aGlzLnByZXZpb3VzRmlsdGVyKSB7IHZhciBpID0gdChlLnRhcmdldCkuY2xvc2VzdChcIi51aS1tZW51LWl0ZW1cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSB0KGUuY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaVswXSA9PT0gc1swXSAmJiAodGhpcy5fcmVtb3ZlQ2xhc3Mocy5zaWJsaW5ncygpLmNoaWxkcmVuKFwiLnVpLXN0YXRlLWFjdGl2ZVwiKSwgbnVsbCwgXCJ1aS1zdGF0ZS1hY3RpdmVcIiksIHRoaXMuZm9jdXMoZSwgcykpIH0gfSwgbW91c2VsZWF2ZTogXCJjb2xsYXBzZUFsbFwiLCBcIm1vdXNlbGVhdmUgLnVpLW1lbnVcIjogXCJjb2xsYXBzZUFsbFwiLCBmb2N1czogZnVuY3Rpb24odCwgZSkgeyB2YXIgaSA9IHRoaXMuYWN0aXZlIHx8IHRoaXMuZWxlbWVudC5maW5kKHRoaXMub3B0aW9ucy5pdGVtcykuZXEoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlIHx8IHRoaXMuZm9jdXModCwgaSkgfSwgYmx1cjogZnVuY3Rpb24oZSkgeyB0aGlzLl9kZWxheShmdW5jdGlvbigpIHsgdmFyIGkgPSAhdC5jb250YWlucyh0aGlzLmVsZW1lbnRbMF0sIHQudWkuc2FmZUFjdGl2ZUVsZW1lbnQodGhpcy5kb2N1bWVudFswXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgJiYgdGhpcy5jb2xsYXBzZUFsbChlKSB9KSB9LCBrZXlkb3duOiBcIl9rZXlkb3duXCIgfSksIHRoaXMucmVmcmVzaCgpLCB0aGlzLl9vbih0aGlzLmRvY3VtZW50LCB7IGNsaWNrOiBmdW5jdGlvbih0KSB7IHRoaXMuX2Nsb3NlT25Eb2N1bWVudENsaWNrKHQpICYmIHRoaXMuY29sbGFwc2VBbGwodCksIHRoaXMubW91c2VIYW5kbGVkID0gITEgfSB9KSB9LCBfZGVzdHJveTogZnVuY3Rpb24oKSB7IHZhciBlID0gdGhpcy5lbGVtZW50LmZpbmQoXCIudWktbWVudS1pdGVtXCIpLnJlbW92ZUF0dHIoXCJyb2xlIGFyaWEtZGlzYWJsZWRcIiksXG4gICAgICAgICAgICAgICAgICAgIGkgPSBlLmNoaWxkcmVuKFwiLnVpLW1lbnUtaXRlbS13cmFwcGVyXCIpLnJlbW92ZVVuaXF1ZUlkKCkucmVtb3ZlQXR0cihcInRhYkluZGV4IHJvbGUgYXJpYS1oYXNwb3B1cFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cihcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiKS5maW5kKFwiLnVpLW1lbnVcIikuYWRkQmFjaygpLnJlbW92ZUF0dHIoXCJyb2xlIGFyaWEtbGFiZWxsZWRieSBhcmlhLWV4cGFuZGVkIGFyaWEtaGlkZGVuIGFyaWEtZGlzYWJsZWQgdGFiSW5kZXhcIikucmVtb3ZlVW5pcXVlSWQoKS5zaG93KCksIGkuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKCkgeyB2YXIgZSA9IHQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGUuZGF0YShcInVpLW1lbnUtc3VibWVudS1jYXJldFwiKSAmJiBlLnJlbW92ZSgpIH0pIH0sIF9rZXlkb3duOiBmdW5jdGlvbihlKSB7IHZhciBpLCBzLCBuLCBvLCBhID0gITA7IHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdC51aS5rZXlDb2RlLlBBR0VfVVA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzUGFnZShlKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdC51aS5rZXlDb2RlLlBBR0VfRE9XTjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFBhZ2UoZSk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHQudWkua2V5Q29kZS5IT01FOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW92ZShcImZpcnN0XCIsIFwiZmlyc3RcIiwgZSk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHQudWkua2V5Q29kZS5FTkQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlKFwibGFzdFwiLCBcImxhc3RcIiwgZSk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHQudWkua2V5Q29kZS5VUDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXMoZSk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHQudWkua2V5Q29kZS5ET1dOOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0KGUpOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0LnVpLmtleUNvZGUuTEVGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29sbGFwc2UoZSk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHQudWkua2V5Q29kZS5SSUdIVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlICYmICF0aGlzLmFjdGl2ZS5pcyhcIi51aS1zdGF0ZS1kaXNhYmxlZFwiKSAmJiB0aGlzLmV4cGFuZChlKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdC51aS5rZXlDb2RlLkVOVEVSOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIHQudWkua2V5Q29kZS5TUEFDRTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2YXRlKGUpOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0LnVpLmtleUNvZGUuRVNDQVBFOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzZShlKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gITEsIHMgPSB0aGlzLnByZXZpb3VzRmlsdGVyIHx8IFwiXCIsIG8gPSAhMSwgbiA9IGUua2V5Q29kZSA+PSA5NiAmJiAxMDUgPj0gZS5rZXlDb2RlID8gXCJcIiArIChlLmtleUNvZGUgLSA5NikgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGUua2V5Q29kZSksIGNsZWFyVGltZW91dCh0aGlzLmZpbHRlclRpbWVyKSwgbiA9PT0gcyA/IG8gPSAhMCA6IG4gPSBzICsgbiwgaSA9IHRoaXMuX2ZpbHRlck1lbnVJdGVtcyhuKSwgaSA9IG8gJiYgLTEgIT09IGkuaW5kZXgodGhpcy5hY3RpdmUubmV4dCgpKSA/IHRoaXMuYWN0aXZlLm5leHRBbGwoXCIudWktbWVudS1pdGVtXCIpIDogaSwgaS5sZW5ndGggfHwgKG4gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUua2V5Q29kZSksIGkgPSB0aGlzLl9maWx0ZXJNZW51SXRlbXMobikpLCBpLmxlbmd0aCA/ICh0aGlzLmZvY3VzKGUsIGkpLCB0aGlzLnByZXZpb3VzRmlsdGVyID0gbiwgdGhpcy5maWx0ZXJUaW1lciA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkgeyBkZWxldGUgdGhpcy5wcmV2aW91c0ZpbHRlciB9LCAxZTMpKSA6IGRlbGV0ZSB0aGlzLnByZXZpb3VzRmlsdGVyIH0gYSAmJiBlLnByZXZlbnREZWZhdWx0KCkgfSwgX2FjdGl2YXRlOiBmdW5jdGlvbih0KSB7IHRoaXMuYWN0aXZlICYmICF0aGlzLmFjdGl2ZS5pcyhcIi51aS1zdGF0ZS1kaXNhYmxlZFwiKSAmJiAodGhpcy5hY3RpdmUuY2hpbGRyZW4oXCJbYXJpYS1oYXNwb3B1cD0ndHJ1ZSddXCIpLmxlbmd0aCA/IHRoaXMuZXhwYW5kKHQpIDogdGhpcy5zZWxlY3QodCkpIH0sIHJlZnJlc2g6IGZ1bmN0aW9uKCkgeyB2YXIgZSwgaSwgcywgbiwgbywgYSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHIgPSB0aGlzLm9wdGlvbnMuaWNvbnMuc3VibWVudSxcbiAgICAgICAgICAgICAgICAgICAgbCA9IHRoaXMuZWxlbWVudC5maW5kKHRoaXMub3B0aW9ucy5tZW51cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlQ2xhc3MoXCJ1aS1tZW51LWljb25zXCIsIG51bGwsICEhdGhpcy5lbGVtZW50LmZpbmQoXCIudWktaWNvblwiKS5sZW5ndGgpLCBzID0gbC5maWx0ZXIoXCI6bm90KC51aS1tZW51KVwiKS5oaWRlKCkuYXR0cih7IHJvbGU6IHRoaXMub3B0aW9ucy5yb2xlLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLCBcImFyaWEtZXhwYW5kZWRcIjogXCJmYWxzZVwiIH0pLmVhY2goZnVuY3Rpb24oKSB7IHZhciBlID0gdCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBlLnByZXYoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSB0KFwiPHNwYW4+XCIpLmRhdGEoXCJ1aS1tZW51LXN1Ym1lbnUtY2FyZXRcIiwgITApO1xuICAgICAgICAgICAgICAgICAgICBhLl9hZGRDbGFzcyhzLCBcInVpLW1lbnUtaWNvblwiLCBcInVpLWljb24gXCIgKyByKSwgaS5hdHRyKFwiYXJpYS1oYXNwb3B1cFwiLCBcInRydWVcIikucHJlcGVuZChzKSwgZS5hdHRyKFwiYXJpYS1sYWJlbGxlZGJ5XCIsIGkuYXR0cihcImlkXCIpKSB9KSwgdGhpcy5fYWRkQ2xhc3MocywgXCJ1aS1tZW51XCIsIFwidWktd2lkZ2V0IHVpLXdpZGdldC1jb250ZW50IHVpLWZyb250XCIpLCBlID0gbC5hZGQodGhpcy5lbGVtZW50KSwgaSA9IGUuZmluZCh0aGlzLm9wdGlvbnMuaXRlbXMpLCBpLm5vdChcIi51aS1tZW51LWl0ZW1cIikuZWFjaChmdW5jdGlvbigpIHsgdmFyIGUgPSB0KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBhLl9pc0RpdmlkZXIoZSkgJiYgYS5fYWRkQ2xhc3MoZSwgXCJ1aS1tZW51LWRpdmlkZXJcIiwgXCJ1aS13aWRnZXQtY29udGVudFwiKSB9KSwgbiA9IGkubm90KFwiLnVpLW1lbnUtaXRlbSwgLnVpLW1lbnUtZGl2aWRlclwiKSwgbyA9IG4uY2hpbGRyZW4oKS5ub3QoXCIudWktbWVudVwiKS51bmlxdWVJZCgpLmF0dHIoeyB0YWJJbmRleDogLTEsIHJvbGU6IHRoaXMuX2l0ZW1Sb2xlKCkgfSksIHRoaXMuX2FkZENsYXNzKG4sIFwidWktbWVudS1pdGVtXCIpLl9hZGRDbGFzcyhvLCBcInVpLW1lbnUtaXRlbS13cmFwcGVyXCIpLCBpLmZpbHRlcihcIi51aS1zdGF0ZS1kaXNhYmxlZFwiKS5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLCBcInRydWVcIiksIHRoaXMuYWN0aXZlICYmICF0LmNvbnRhaW5zKHRoaXMuZWxlbWVudFswXSwgdGhpcy5hY3RpdmVbMF0pICYmIHRoaXMuYmx1cigpIH0sIF9pdGVtUm9sZTogZnVuY3Rpb24oKSB7IHJldHVybiB7IG1lbnU6IFwibWVudWl0ZW1cIiwgbGlzdGJveDogXCJvcHRpb25cIiB9IFt0aGlzLm9wdGlvbnMucm9sZV0gfSwgX3NldE9wdGlvbjogZnVuY3Rpb24odCwgZSkgeyBpZiAoXCJpY29uc1wiID09PSB0KSB7IHZhciBpID0gdGhpcy5lbGVtZW50LmZpbmQoXCIudWktbWVudS1pY29uXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVDbGFzcyhpLCBudWxsLCB0aGlzLm9wdGlvbnMuaWNvbnMuc3VibWVudSkuX2FkZENsYXNzKGksIG51bGwsIGUuc3VibWVudSkgfSB0aGlzLl9zdXBlcih0LCBlKSB9LCBfc2V0T3B0aW9uRGlzYWJsZWQ6IGZ1bmN0aW9uKHQpIHsgdGhpcy5fc3VwZXIodCksIHRoaXMuZWxlbWVudC5hdHRyKFwiYXJpYS1kaXNhYmxlZFwiLCB0ICsgXCJcIiksIHRoaXMuX3RvZ2dsZUNsYXNzKG51bGwsIFwidWktc3RhdGUtZGlzYWJsZWRcIiwgISF0KSB9LCBmb2N1czogZnVuY3Rpb24odCwgZSkgeyB2YXIgaSwgcywgbjtcbiAgICAgICAgICAgICAgICB0aGlzLmJsdXIodCwgdCAmJiBcImZvY3VzXCIgPT09IHQudHlwZSksIHRoaXMuX3Njcm9sbEludG9WaWV3KGUpLCB0aGlzLmFjdGl2ZSA9IGUuZmlyc3QoKSwgcyA9IHRoaXMuYWN0aXZlLmNoaWxkcmVuKFwiLnVpLW1lbnUtaXRlbS13cmFwcGVyXCIpLCB0aGlzLl9hZGRDbGFzcyhzLCBudWxsLCBcInVpLXN0YXRlLWFjdGl2ZVwiKSwgdGhpcy5vcHRpb25zLnJvbGUgJiYgdGhpcy5lbGVtZW50LmF0dHIoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgcy5hdHRyKFwiaWRcIikpLCBuID0gdGhpcy5hY3RpdmUucGFyZW50KCkuY2xvc2VzdChcIi51aS1tZW51LWl0ZW1cIikuY2hpbGRyZW4oXCIudWktbWVudS1pdGVtLXdyYXBwZXJcIiksIHRoaXMuX2FkZENsYXNzKG4sIG51bGwsIFwidWktc3RhdGUtYWN0aXZlXCIpLCB0ICYmIFwia2V5ZG93blwiID09PSB0LnR5cGUgPyB0aGlzLl9jbG9zZSgpIDogdGhpcy50aW1lciA9IHRoaXMuX2RlbGF5KGZ1bmN0aW9uKCkgeyB0aGlzLl9jbG9zZSgpIH0sIHRoaXMuZGVsYXkpLCBpID0gZS5jaGlsZHJlbihcIi51aS1tZW51XCIpLCBpLmxlbmd0aCAmJiB0ICYmIC9ebW91c2UvLnRlc3QodC50eXBlKSAmJiB0aGlzLl9zdGFydE9wZW5pbmcoaSksIHRoaXMuYWN0aXZlTWVudSA9IGUucGFyZW50KCksIHRoaXMuX3RyaWdnZXIoXCJmb2N1c1wiLCB0LCB7IGl0ZW06IGUgfSkgfSwgX3Njcm9sbEludG9WaWV3OiBmdW5jdGlvbihlKSB7IHZhciBpLCBzLCBuLCBvLCBhLCByO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1Njcm9sbCgpICYmIChpID0gcGFyc2VGbG9hdCh0LmNzcyh0aGlzLmFjdGl2ZU1lbnVbMF0sIFwiYm9yZGVyVG9wV2lkdGhcIikpIHx8IDAsIHMgPSBwYXJzZUZsb2F0KHQuY3NzKHRoaXMuYWN0aXZlTWVudVswXSwgXCJwYWRkaW5nVG9wXCIpKSB8fCAwLCBuID0gZS5vZmZzZXQoKS50b3AgLSB0aGlzLmFjdGl2ZU1lbnUub2Zmc2V0KCkudG9wIC0gaSAtIHMsIG8gPSB0aGlzLmFjdGl2ZU1lbnUuc2Nyb2xsVG9wKCksIGEgPSB0aGlzLmFjdGl2ZU1lbnUuaGVpZ2h0KCksIHIgPSBlLm91dGVySGVpZ2h0KCksIDAgPiBuID8gdGhpcy5hY3RpdmVNZW51LnNjcm9sbFRvcChvICsgbikgOiBuICsgciA+IGEgJiYgdGhpcy5hY3RpdmVNZW51LnNjcm9sbFRvcChvICsgbiAtIGEgKyByKSkgfSwgYmx1cjogZnVuY3Rpb24odCwgZSkgeyBlIHx8IGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKSwgdGhpcy5hY3RpdmUgJiYgKHRoaXMuX3JlbW92ZUNsYXNzKHRoaXMuYWN0aXZlLmNoaWxkcmVuKFwiLnVpLW1lbnUtaXRlbS13cmFwcGVyXCIpLCBudWxsLCBcInVpLXN0YXRlLWFjdGl2ZVwiKSwgdGhpcy5fdHJpZ2dlcihcImJsdXJcIiwgdCwgeyBpdGVtOiB0aGlzLmFjdGl2ZSB9KSwgdGhpcy5hY3RpdmUgPSBudWxsKSB9LCBfc3RhcnRPcGVuaW5nOiBmdW5jdGlvbih0KSB7IGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKSwgXCJ0cnVlXCIgPT09IHQuYXR0cihcImFyaWEtaGlkZGVuXCIpICYmICh0aGlzLnRpbWVyID0gdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7IHRoaXMuX2Nsb3NlKCksIHRoaXMuX29wZW4odCkgfSwgdGhpcy5kZWxheSkpIH0sIF9vcGVuOiBmdW5jdGlvbihlKSB7IHZhciBpID0gdC5leHRlbmQoeyBvZjogdGhpcy5hY3RpdmUgfSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lciksIHRoaXMuZWxlbWVudC5maW5kKFwiLnVpLW1lbnVcIikubm90KGUucGFyZW50cyhcIi51aS1tZW51XCIpKS5oaWRlKCkuYXR0cihcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKSwgZS5zaG93KCkucmVtb3ZlQXR0cihcImFyaWEtaGlkZGVuXCIpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsIFwidHJ1ZVwiKS5wb3NpdGlvbihpKSB9LCBjb2xsYXBzZUFsbDogZnVuY3Rpb24oZSwgaSkgeyBjbGVhclRpbWVvdXQodGhpcy50aW1lciksIHRoaXMudGltZXIgPSB0aGlzLl9kZWxheShmdW5jdGlvbigpIHsgdmFyIHMgPSBpID8gdGhpcy5lbGVtZW50IDogdChlICYmIGUudGFyZ2V0KS5jbG9zZXN0KHRoaXMuZWxlbWVudC5maW5kKFwiLnVpLW1lbnVcIikpO1xuICAgICAgICAgICAgICAgICAgICBzLmxlbmd0aCB8fCAocyA9IHRoaXMuZWxlbWVudCksIHRoaXMuX2Nsb3NlKHMpLCB0aGlzLmJsdXIoZSksIHRoaXMuX3JlbW92ZUNsYXNzKHMuZmluZChcIi51aS1zdGF0ZS1hY3RpdmVcIiksIG51bGwsIFwidWktc3RhdGUtYWN0aXZlXCIpLCB0aGlzLmFjdGl2ZU1lbnUgPSBzIH0sIHRoaXMuZGVsYXkpIH0sIF9jbG9zZTogZnVuY3Rpb24odCkgeyB0IHx8ICh0ID0gdGhpcy5hY3RpdmUgPyB0aGlzLmFjdGl2ZS5wYXJlbnQoKSA6IHRoaXMuZWxlbWVudCksIHQuZmluZChcIi51aS1tZW51XCIpLmhpZGUoKS5hdHRyKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsIFwiZmFsc2VcIikgfSwgX2Nsb3NlT25Eb2N1bWVudENsaWNrOiBmdW5jdGlvbihlKSB7IHJldHVybiAhdChlLnRhcmdldCkuY2xvc2VzdChcIi51aS1tZW51XCIpLmxlbmd0aCB9LCBfaXNEaXZpZGVyOiBmdW5jdGlvbih0KSB7IHJldHVybiAhL1teXFwtXFx1MjAxNFxcdTIwMTNcXHNdLy50ZXN0KHQudGV4dCgpKSB9LCBjb2xsYXBzZTogZnVuY3Rpb24odCkgeyB2YXIgZSA9IHRoaXMuYWN0aXZlICYmIHRoaXMuYWN0aXZlLnBhcmVudCgpLmNsb3Nlc3QoXCIudWktbWVudS1pdGVtXCIsIHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgZSAmJiBlLmxlbmd0aCAmJiAodGhpcy5fY2xvc2UoKSwgdGhpcy5mb2N1cyh0LCBlKSkgfSwgZXhwYW5kOiBmdW5jdGlvbih0KSB7IHZhciBlID0gdGhpcy5hY3RpdmUgJiYgdGhpcy5hY3RpdmUuY2hpbGRyZW4oXCIudWktbWVudSBcIikuZmluZCh0aGlzLm9wdGlvbnMuaXRlbXMpLmZpcnN0KCk7XG4gICAgICAgICAgICAgICAgZSAmJiBlLmxlbmd0aCAmJiAodGhpcy5fb3BlbihlLnBhcmVudCgpKSwgdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7IHRoaXMuZm9jdXModCwgZSkgfSkpIH0sIG5leHQ6IGZ1bmN0aW9uKHQpIHsgdGhpcy5fbW92ZShcIm5leHRcIiwgXCJmaXJzdFwiLCB0KSB9LCBwcmV2aW91czogZnVuY3Rpb24odCkgeyB0aGlzLl9tb3ZlKFwicHJldlwiLCBcImxhc3RcIiwgdCkgfSwgaXNGaXJzdEl0ZW06IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5hY3RpdmUgJiYgIXRoaXMuYWN0aXZlLnByZXZBbGwoXCIudWktbWVudS1pdGVtXCIpLmxlbmd0aCB9LCBpc0xhc3RJdGVtOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuYWN0aXZlICYmICF0aGlzLmFjdGl2ZS5uZXh0QWxsKFwiLnVpLW1lbnUtaXRlbVwiKS5sZW5ndGggfSwgX21vdmU6IGZ1bmN0aW9uKHQsIGUsIGkpIHsgdmFyIHM7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUgJiYgKHMgPSBcImZpcnN0XCIgPT09IHQgfHwgXCJsYXN0XCIgPT09IHQgPyB0aGlzLmFjdGl2ZVtcImZpcnN0XCIgPT09IHQgPyBcInByZXZBbGxcIiA6IFwibmV4dEFsbFwiXShcIi51aS1tZW51LWl0ZW1cIikuZXEoLTEpIDogdGhpcy5hY3RpdmVbdCArIFwiQWxsXCJdKFwiLnVpLW1lbnUtaXRlbVwiKS5lcSgwKSksIHMgJiYgcy5sZW5ndGggJiYgdGhpcy5hY3RpdmUgfHwgKHMgPSB0aGlzLmFjdGl2ZU1lbnUuZmluZCh0aGlzLm9wdGlvbnMuaXRlbXMpW2VdKCkpLCB0aGlzLmZvY3VzKGksIHMpIH0sIG5leHRQYWdlOiBmdW5jdGlvbihlKSB7IHZhciBpLCBzLCBuOyByZXR1cm4gdGhpcy5hY3RpdmUgPyAodGhpcy5pc0xhc3RJdGVtKCkgfHwgKHRoaXMuX2hhc1Njcm9sbCgpID8gKHMgPSB0aGlzLmFjdGl2ZS5vZmZzZXQoKS50b3AsIG4gPSB0aGlzLmVsZW1lbnQuaGVpZ2h0KCksIHRoaXMuYWN0aXZlLm5leHRBbGwoXCIudWktbWVudS1pdGVtXCIpLmVhY2goZnVuY3Rpb24oKSB7IHJldHVybiBpID0gdCh0aGlzKSwgMCA+IGkub2Zmc2V0KCkudG9wIC0gcyAtIG4gfSksIHRoaXMuZm9jdXMoZSwgaSkpIDogdGhpcy5mb2N1cyhlLCB0aGlzLmFjdGl2ZU1lbnUuZmluZCh0aGlzLm9wdGlvbnMuaXRlbXMpW3RoaXMuYWN0aXZlID8gXCJsYXN0XCIgOiBcImZpcnN0XCJdKCkpKSwgdm9pZCAwKSA6ICh0aGlzLm5leHQoZSksIHZvaWQgMCkgfSwgcHJldmlvdXNQYWdlOiBmdW5jdGlvbihlKSB7IHZhciBpLCBzLCBuOyByZXR1cm4gdGhpcy5hY3RpdmUgPyAodGhpcy5pc0ZpcnN0SXRlbSgpIHx8ICh0aGlzLl9oYXNTY3JvbGwoKSA/IChzID0gdGhpcy5hY3RpdmUub2Zmc2V0KCkudG9wLCBuID0gdGhpcy5lbGVtZW50LmhlaWdodCgpLCB0aGlzLmFjdGl2ZS5wcmV2QWxsKFwiLnVpLW1lbnUtaXRlbVwiKS5lYWNoKGZ1bmN0aW9uKCkgeyByZXR1cm4gaSA9IHQodGhpcyksIGkub2Zmc2V0KCkudG9wIC0gcyArIG4gPiAwIH0pLCB0aGlzLmZvY3VzKGUsIGkpKSA6IHRoaXMuZm9jdXMoZSwgdGhpcy5hY3RpdmVNZW51LmZpbmQodGhpcy5vcHRpb25zLml0ZW1zKS5maXJzdCgpKSksIHZvaWQgMCkgOiAodGhpcy5uZXh0KGUpLCB2b2lkIDApIH0sIF9oYXNTY3JvbGw6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5lbGVtZW50Lm91dGVySGVpZ2h0KCkgPCB0aGlzLmVsZW1lbnQucHJvcChcInNjcm9sbEhlaWdodFwiKSB9LCBzZWxlY3Q6IGZ1bmN0aW9uKGUpIHsgdGhpcy5hY3RpdmUgPSB0aGlzLmFjdGl2ZSB8fCB0KGUudGFyZ2V0KS5jbG9zZXN0KFwiLnVpLW1lbnUtaXRlbVwiKTsgdmFyIGkgPSB7IGl0ZW06IHRoaXMuYWN0aXZlIH07XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUuaGFzKFwiLnVpLW1lbnVcIikubGVuZ3RoIHx8IHRoaXMuY29sbGFwc2VBbGwoZSwgITApLCB0aGlzLl90cmlnZ2VyKFwic2VsZWN0XCIsIGUsIGkpIH0sIF9maWx0ZXJNZW51SXRlbXM6IGZ1bmN0aW9uKGUpIHsgdmFyIGkgPSBlLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiKSxcbiAgICAgICAgICAgICAgICAgICAgcyA9IFJlZ0V4cChcIl5cIiArIGksIFwiaVwiKTsgcmV0dXJuIHRoaXMuYWN0aXZlTWVudS5maW5kKHRoaXMub3B0aW9ucy5pdGVtcykuZmlsdGVyKFwiLnVpLW1lbnUtaXRlbVwiKS5maWx0ZXIoZnVuY3Rpb24oKSB7IHJldHVybiBzLnRlc3QodC50cmltKHQodGhpcykuY2hpbGRyZW4oXCIudWktbWVudS1pdGVtLXdyYXBwZXJcIikudGV4dCgpKSkgfSkgfSB9KSwgdC53aWRnZXQoXCJ1aS5hdXRvY29tcGxldGVcIiwgeyB2ZXJzaW9uOiBcIjEuMTIuMVwiLCBkZWZhdWx0RWxlbWVudDogXCI8aW5wdXQ+XCIsIG9wdGlvbnM6IHsgYXBwZW5kVG86IG51bGwsIGF1dG9Gb2N1czogITEsIGRlbGF5OiAzMDAsIG1pbkxlbmd0aDogMSwgcG9zaXRpb246IHsgbXk6IFwibGVmdCB0b3BcIiwgYXQ6IFwibGVmdCBib3R0b21cIiwgY29sbGlzaW9uOiBcIm5vbmVcIiB9LCBzb3VyY2U6IG51bGwsIGNoYW5nZTogbnVsbCwgY2xvc2U6IG51bGwsIGZvY3VzOiBudWxsLCBvcGVuOiBudWxsLCByZXNwb25zZTogbnVsbCwgc2VhcmNoOiBudWxsLCBzZWxlY3Q6IG51bGwgfSwgcmVxdWVzdEluZGV4OiAwLCBwZW5kaW5nOiAwLCBfY3JlYXRlOiBmdW5jdGlvbigpIHsgdmFyIGUsIGksIHMsIG4gPSB0aGlzLmVsZW1lbnRbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgbyA9IFwidGV4dGFyZWFcIiA9PT0gbixcbiAgICAgICAgICAgICAgICAgICAgYSA9IFwiaW5wdXRcIiA9PT0gbjtcbiAgICAgICAgICAgICAgICB0aGlzLmlzTXVsdGlMaW5lID0gbyB8fCAhYSAmJiB0aGlzLl9pc0NvbnRlbnRFZGl0YWJsZSh0aGlzLmVsZW1lbnQpLCB0aGlzLnZhbHVlTWV0aG9kID0gdGhpcy5lbGVtZW50W28gfHwgYSA/IFwidmFsXCIgOiBcInRleHRcIl0sIHRoaXMuaXNOZXdNZW51ID0gITAsIHRoaXMuX2FkZENsYXNzKFwidWktYXV0b2NvbXBsZXRlLWlucHV0XCIpLCB0aGlzLmVsZW1lbnQuYXR0cihcImF1dG9jb21wbGV0ZVwiLCBcIm9mZlwiKSwgdGhpcy5fb24odGhpcy5lbGVtZW50LCB7IGtleWRvd246IGZ1bmN0aW9uKG4pIHsgaWYgKHRoaXMuZWxlbWVudC5wcm9wKFwicmVhZE9ubHlcIikpIHJldHVybiBlID0gITAsIHMgPSAhMCwgaSA9ICEwLCB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gITEsIHMgPSAhMSwgaSA9ICExOyB2YXIgbyA9IHQudWkua2V5Q29kZTsgc3dpdGNoIChuLmtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG8uUEFHRV9VUDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSA9ICEwLCB0aGlzLl9tb3ZlKFwicHJldmlvdXNQYWdlXCIsIG4pOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG8uUEFHRV9ET1dOOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gITAsIHRoaXMuX21vdmUoXCJuZXh0UGFnZVwiLCBuKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBvLlVQOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gITAsIHRoaXMuX2tleUV2ZW50KFwicHJldmlvdXNcIiwgbik7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugby5ET1dOOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlID0gITAsIHRoaXMuX2tleUV2ZW50KFwibmV4dFwiLCBuKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBvLkVOVEVSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbnUuYWN0aXZlICYmIChlID0gITAsIG4ucHJldmVudERlZmF1bHQoKSwgdGhpcy5tZW51LnNlbGVjdChuKSk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugby5UQUI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVudS5hY3RpdmUgJiYgdGhpcy5tZW51LnNlbGVjdChuKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBvLkVTQ0FQRTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW51LmVsZW1lbnQuaXMoXCI6dmlzaWJsZVwiKSAmJiAodGhpcy5pc011bHRpTGluZSB8fCB0aGlzLl92YWx1ZSh0aGlzLnRlcm0pLCB0aGlzLmNsb3NlKG4pLCBuLnByZXZlbnREZWZhdWx0KCkpOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gITAsIHRoaXMuX3NlYXJjaFRpbWVvdXQobikgfSB9LCBrZXlwcmVzczogZnVuY3Rpb24ocykgeyBpZiAoZSkgcmV0dXJuIGUgPSAhMSwgKCF0aGlzLmlzTXVsdGlMaW5lIHx8IHRoaXMubWVudS5lbGVtZW50LmlzKFwiOnZpc2libGVcIikpICYmIHMucHJldmVudERlZmF1bHQoKSwgdm9pZCAwOyBpZiAoIWkpIHsgdmFyIG4gPSB0LnVpLmtleUNvZGU7IHN3aXRjaCAocy5rZXlDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugbi5QQUdFX1VQOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW92ZShcInByZXZpb3VzUGFnZVwiLCBzKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2Ugbi5QQUdFX0RPV046XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlKFwibmV4dFBhZ2VcIiwgcyk7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIG4uVVA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlFdmVudChcInByZXZpb3VzXCIsIHMpOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBuLkRPV046XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlFdmVudChcIm5leHRcIiwgcykgfSB9IH0sIGlucHV0OiBmdW5jdGlvbih0KSB7IHJldHVybiBzID8gKHMgPSAhMSwgdC5wcmV2ZW50RGVmYXVsdCgpLCB2b2lkIDApIDogKHRoaXMuX3NlYXJjaFRpbWVvdXQodCksIHZvaWQgMCkgfSwgZm9jdXM6IGZ1bmN0aW9uKCkgeyB0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGwsIHRoaXMucHJldmlvdXMgPSB0aGlzLl92YWx1ZSgpIH0sIGJsdXI6IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHRoaXMuY2FuY2VsQmx1ciA/IChkZWxldGUgdGhpcy5jYW5jZWxCbHVyLCB2b2lkIDApIDogKGNsZWFyVGltZW91dCh0aGlzLnNlYXJjaGluZyksIHRoaXMuY2xvc2UodCksIHRoaXMuX2NoYW5nZSh0KSwgdm9pZCAwKSB9IH0pLCB0aGlzLl9pbml0U291cmNlKCksIHRoaXMubWVudSA9IHQoXCI8dWw+XCIpLmFwcGVuZFRvKHRoaXMuX2FwcGVuZFRvKCkpLm1lbnUoeyByb2xlOiBudWxsIH0pLmhpZGUoKS5tZW51KFwiaW5zdGFuY2VcIiksIHRoaXMuX2FkZENsYXNzKHRoaXMubWVudS5lbGVtZW50LCBcInVpLWF1dG9jb21wbGV0ZVwiLCBcInVpLWZyb250XCIpLCB0aGlzLl9vbih0aGlzLm1lbnUuZWxlbWVudCwgeyBtb3VzZWRvd246IGZ1bmN0aW9uKGUpIHsgZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLmNhbmNlbEJsdXIgPSAhMCwgdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7IGRlbGV0ZSB0aGlzLmNhbmNlbEJsdXIsIHRoaXMuZWxlbWVudFswXSAhPT0gdC51aS5zYWZlQWN0aXZlRWxlbWVudCh0aGlzLmRvY3VtZW50WzBdKSAmJiB0aGlzLmVsZW1lbnQudHJpZ2dlcihcImZvY3VzXCIpIH0pIH0sIG1lbnVmb2N1czogZnVuY3Rpb24oZSwgaSkgeyB2YXIgcywgbjsgcmV0dXJuIHRoaXMuaXNOZXdNZW51ICYmICh0aGlzLmlzTmV3TWVudSA9ICExLCBlLm9yaWdpbmFsRXZlbnQgJiYgL15tb3VzZS8udGVzdChlLm9yaWdpbmFsRXZlbnQudHlwZSkpID8gKHRoaXMubWVudS5ibHVyKCksIHRoaXMuZG9jdW1lbnQub25lKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKCkgeyB0KGUudGFyZ2V0KS50cmlnZ2VyKGUub3JpZ2luYWxFdmVudCkgfSksIHZvaWQgMCkgOiAobiA9IGkuaXRlbS5kYXRhKFwidWktYXV0b2NvbXBsZXRlLWl0ZW1cIiksICExICE9PSB0aGlzLl90cmlnZ2VyKFwiZm9jdXNcIiwgZSwgeyBpdGVtOiBuIH0pICYmIGUub3JpZ2luYWxFdmVudCAmJiAvXmtleS8udGVzdChlLm9yaWdpbmFsRXZlbnQudHlwZSkgJiYgdGhpcy5fdmFsdWUobi52YWx1ZSksIHMgPSBpLml0ZW0uYXR0cihcImFyaWEtbGFiZWxcIikgfHwgbi52YWx1ZSwgcyAmJiB0LnRyaW0ocykubGVuZ3RoICYmICh0aGlzLmxpdmVSZWdpb24uY2hpbGRyZW4oKS5oaWRlKCksIHQoXCI8ZGl2PlwiKS50ZXh0KHMpLmFwcGVuZFRvKHRoaXMubGl2ZVJlZ2lvbikpLCB2b2lkIDApIH0sIG1lbnVzZWxlY3Q6IGZ1bmN0aW9uKGUsIGkpIHsgdmFyIHMgPSBpLml0ZW0uZGF0YShcInVpLWF1dG9jb21wbGV0ZS1pdGVtXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSB0aGlzLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50WzBdICE9PSB0LnVpLnNhZmVBY3RpdmVFbGVtZW50KHRoaXMuZG9jdW1lbnRbMF0pICYmICh0aGlzLmVsZW1lbnQudHJpZ2dlcihcImZvY3VzXCIpLCB0aGlzLnByZXZpb3VzID0gbiwgdGhpcy5fZGVsYXkoZnVuY3Rpb24oKSB7IHRoaXMucHJldmlvdXMgPSBuLCB0aGlzLnNlbGVjdGVkSXRlbSA9IHMgfSkpLCAhMSAhPT0gdGhpcy5fdHJpZ2dlcihcInNlbGVjdFwiLCBlLCB7IGl0ZW06IHMgfSkgJiYgdGhpcy5fdmFsdWUocy52YWx1ZSksIHRoaXMudGVybSA9IHRoaXMuX3ZhbHVlKCksIHRoaXMuY2xvc2UoZSksIHRoaXMuc2VsZWN0ZWRJdGVtID0gcyB9IH0pLCB0aGlzLmxpdmVSZWdpb24gPSB0KFwiPGRpdj5cIiwgeyByb2xlOiBcInN0YXR1c1wiLCBcImFyaWEtbGl2ZVwiOiBcImFzc2VydGl2ZVwiLCBcImFyaWEtcmVsZXZhbnRcIjogXCJhZGRpdGlvbnNcIiB9KS5hcHBlbmRUbyh0aGlzLmRvY3VtZW50WzBdLmJvZHkpLCB0aGlzLl9hZGRDbGFzcyh0aGlzLmxpdmVSZWdpb24sIG51bGwsIFwidWktaGVscGVyLWhpZGRlbi1hY2Nlc3NpYmxlXCIpLCB0aGlzLl9vbih0aGlzLndpbmRvdywgeyBiZWZvcmV1bmxvYWQ6IGZ1bmN0aW9uKCkgeyB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cihcImF1dG9jb21wbGV0ZVwiKSB9IH0pIH0sIF9kZXN0cm95OiBmdW5jdGlvbigpIHsgY2xlYXJUaW1lb3V0KHRoaXMuc2VhcmNoaW5nKSwgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHIoXCJhdXRvY29tcGxldGVcIiksIHRoaXMubWVudS5lbGVtZW50LnJlbW92ZSgpLCB0aGlzLmxpdmVSZWdpb24ucmVtb3ZlKCkgfSwgX3NldE9wdGlvbjogZnVuY3Rpb24odCwgZSkgeyB0aGlzLl9zdXBlcih0LCBlKSwgXCJzb3VyY2VcIiA9PT0gdCAmJiB0aGlzLl9pbml0U291cmNlKCksIFwiYXBwZW5kVG9cIiA9PT0gdCAmJiB0aGlzLm1lbnUuZWxlbWVudC5hcHBlbmRUbyh0aGlzLl9hcHBlbmRUbygpKSwgXCJkaXNhYmxlZFwiID09PSB0ICYmIGUgJiYgdGhpcy54aHIgJiYgdGhpcy54aHIuYWJvcnQoKSB9LCBfaXNFdmVudFRhcmdldEluV2lkZ2V0OiBmdW5jdGlvbihlKSB7IHZhciBpID0gdGhpcy5tZW51LmVsZW1lbnRbMF07IHJldHVybiBlLnRhcmdldCA9PT0gdGhpcy5lbGVtZW50WzBdIHx8IGUudGFyZ2V0ID09PSBpIHx8IHQuY29udGFpbnMoaSwgZS50YXJnZXQpIH0sIF9jbG9zZU9uQ2xpY2tPdXRzaWRlOiBmdW5jdGlvbih0KSB7IHRoaXMuX2lzRXZlbnRUYXJnZXRJbldpZGdldCh0KSB8fCB0aGlzLmNsb3NlKCkgfSwgX2FwcGVuZFRvOiBmdW5jdGlvbigpIHsgdmFyIGUgPSB0aGlzLm9wdGlvbnMuYXBwZW5kVG87IHJldHVybiBlICYmIChlID0gZS5qcXVlcnkgfHwgZS5ub2RlVHlwZSA/IHQoZSkgOiB0aGlzLmRvY3VtZW50LmZpbmQoZSkuZXEoMCkpLCBlICYmIGVbMF0gfHwgKGUgPSB0aGlzLmVsZW1lbnQuY2xvc2VzdChcIi51aS1mcm9udCwgZGlhbG9nXCIpKSwgZS5sZW5ndGggfHwgKGUgPSB0aGlzLmRvY3VtZW50WzBdLmJvZHkpLCBlIH0sIF9pbml0U291cmNlOiBmdW5jdGlvbigpIHsgdmFyIGUsIGksIHMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHQuaXNBcnJheSh0aGlzLm9wdGlvbnMuc291cmNlKSA/IChlID0gdGhpcy5vcHRpb25zLnNvdXJjZSwgdGhpcy5zb3VyY2UgPSBmdW5jdGlvbihpLCBzKSB7IHModC51aS5hdXRvY29tcGxldGUuZmlsdGVyKGUsIGkudGVybSkpIH0pIDogXCJzdHJpbmdcIiA9PSB0eXBlb2YgdGhpcy5vcHRpb25zLnNvdXJjZSA/IChpID0gdGhpcy5vcHRpb25zLnNvdXJjZSwgdGhpcy5zb3VyY2UgPSBmdW5jdGlvbihlLCBuKSB7IHMueGhyICYmIHMueGhyLmFib3J0KCksIHMueGhyID0gdC5hamF4KHsgdXJsOiBpLCBkYXRhOiBlLCBkYXRhVHlwZTogXCJqc29uXCIsIHN1Y2Nlc3M6IGZ1bmN0aW9uKHQpIHsgbih0KSB9LCBlcnJvcjogZnVuY3Rpb24oKSB7IG4oW10pIH0gfSkgfSkgOiB0aGlzLnNvdXJjZSA9IHRoaXMub3B0aW9ucy5zb3VyY2UgfSwgX3NlYXJjaFRpbWVvdXQ6IGZ1bmN0aW9uKHQpIHsgY2xlYXJUaW1lb3V0KHRoaXMuc2VhcmNoaW5nKSwgdGhpcy5zZWFyY2hpbmcgPSB0aGlzLl9kZWxheShmdW5jdGlvbigpIHsgdmFyIGUgPSB0aGlzLnRlcm0gPT09IHRoaXMuX3ZhbHVlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gdGhpcy5tZW51LmVsZW1lbnQuaXMoXCI6dmlzaWJsZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSB0LmFsdEtleSB8fCB0LmN0cmxLZXkgfHwgdC5tZXRhS2V5IHx8IHQuc2hpZnRLZXk7XG4gICAgICAgICAgICAgICAgICAgICghZSB8fCBlICYmICFpICYmICFzKSAmJiAodGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsLCB0aGlzLnNlYXJjaChudWxsLCB0KSkgfSwgdGhpcy5vcHRpb25zLmRlbGF5KSB9LCBzZWFyY2g6IGZ1bmN0aW9uKHQsIGUpIHsgcmV0dXJuIHQgPSBudWxsICE9IHQgPyB0IDogdGhpcy5fdmFsdWUoKSwgdGhpcy50ZXJtID0gdGhpcy5fdmFsdWUoKSwgdC5sZW5ndGggPCB0aGlzLm9wdGlvbnMubWluTGVuZ3RoID8gdGhpcy5jbG9zZShlKSA6IHRoaXMuX3RyaWdnZXIoXCJzZWFyY2hcIiwgZSkgIT09ICExID8gdGhpcy5fc2VhcmNoKHQpIDogdm9pZCAwIH0sIF9zZWFyY2g6IGZ1bmN0aW9uKHQpIHsgdGhpcy5wZW5kaW5nKyssIHRoaXMuX2FkZENsYXNzKFwidWktYXV0b2NvbXBsZXRlLWxvYWRpbmdcIiksIHRoaXMuY2FuY2VsU2VhcmNoID0gITEsIHRoaXMuc291cmNlKHsgdGVybTogdCB9LCB0aGlzLl9yZXNwb25zZSgpKSB9LCBfcmVzcG9uc2U6IGZ1bmN0aW9uKCkgeyB2YXIgZSA9ICsrdGhpcy5yZXF1ZXN0SW5kZXg7IHJldHVybiB0LnByb3h5KGZ1bmN0aW9uKHQpIHsgZSA9PT0gdGhpcy5yZXF1ZXN0SW5kZXggJiYgdGhpcy5fX3Jlc3BvbnNlKHQpLCB0aGlzLnBlbmRpbmctLSwgdGhpcy5wZW5kaW5nIHx8IHRoaXMuX3JlbW92ZUNsYXNzKFwidWktYXV0b2NvbXBsZXRlLWxvYWRpbmdcIikgfSwgdGhpcykgfSwgX19yZXNwb25zZTogZnVuY3Rpb24odCkgeyB0ICYmICh0ID0gdGhpcy5fbm9ybWFsaXplKHQpKSwgdGhpcy5fdHJpZ2dlcihcInJlc3BvbnNlXCIsIG51bGwsIHsgY29udGVudDogdCB9KSwgIXRoaXMub3B0aW9ucy5kaXNhYmxlZCAmJiB0ICYmIHQubGVuZ3RoICYmICF0aGlzLmNhbmNlbFNlYXJjaCA/ICh0aGlzLl9zdWdnZXN0KHQpLCB0aGlzLl90cmlnZ2VyKFwib3BlblwiKSkgOiB0aGlzLl9jbG9zZSgpIH0sIGNsb3NlOiBmdW5jdGlvbih0KSB7IHRoaXMuY2FuY2VsU2VhcmNoID0gITAsIHRoaXMuX2Nsb3NlKHQpIH0sIF9jbG9zZTogZnVuY3Rpb24odCkgeyB0aGlzLl9vZmYodGhpcy5kb2N1bWVudCwgXCJtb3VzZWRvd25cIiksIHRoaXMubWVudS5lbGVtZW50LmlzKFwiOnZpc2libGVcIikgJiYgKHRoaXMubWVudS5lbGVtZW50LmhpZGUoKSwgdGhpcy5tZW51LmJsdXIoKSwgdGhpcy5pc05ld01lbnUgPSAhMCwgdGhpcy5fdHJpZ2dlcihcImNsb3NlXCIsIHQpKSB9LCBfY2hhbmdlOiBmdW5jdGlvbih0KSB7IHRoaXMucHJldmlvdXMgIT09IHRoaXMuX3ZhbHVlKCkgJiYgdGhpcy5fdHJpZ2dlcihcImNoYW5nZVwiLCB0LCB7IGl0ZW06IHRoaXMuc2VsZWN0ZWRJdGVtIH0pIH0sIF9ub3JtYWxpemU6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUubGVuZ3RoICYmIGVbMF0ubGFiZWwgJiYgZVswXS52YWx1ZSA/IGUgOiB0Lm1hcChlLCBmdW5jdGlvbihlKSB7IHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiBlID8geyBsYWJlbDogZSwgdmFsdWU6IGUgfSA6IHQuZXh0ZW5kKHt9LCBlLCB7IGxhYmVsOiBlLmxhYmVsIHx8IGUudmFsdWUsIHZhbHVlOiBlLnZhbHVlIHx8IGUubGFiZWwgfSkgfSkgfSwgX3N1Z2dlc3Q6IGZ1bmN0aW9uKGUpIHsgdmFyIGkgPSB0aGlzLm1lbnUuZWxlbWVudC5lbXB0eSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlck1lbnUoaSwgZSksIHRoaXMuaXNOZXdNZW51ID0gITAsIHRoaXMubWVudS5yZWZyZXNoKCksIGkuc2hvdygpLCB0aGlzLl9yZXNpemVNZW51KCksIGkucG9zaXRpb24odC5leHRlbmQoeyBvZjogdGhpcy5lbGVtZW50IH0sIHRoaXMub3B0aW9ucy5wb3NpdGlvbikpLCB0aGlzLm9wdGlvbnMuYXV0b0ZvY3VzICYmIHRoaXMubWVudS5uZXh0KCksIHRoaXMuX29uKHRoaXMuZG9jdW1lbnQsIHsgbW91c2Vkb3duOiBcIl9jbG9zZU9uQ2xpY2tPdXRzaWRlXCIgfSkgfSwgX3Jlc2l6ZU1lbnU6IGZ1bmN0aW9uKCkgeyB2YXIgdCA9IHRoaXMubWVudS5lbGVtZW50O1xuICAgICAgICAgICAgICAgIHQub3V0ZXJXaWR0aChNYXRoLm1heCh0LndpZHRoKFwiXCIpLm91dGVyV2lkdGgoKSArIDEsIHRoaXMuZWxlbWVudC5vdXRlcldpZHRoKCkpKSB9LCBfcmVuZGVyTWVudTogZnVuY3Rpb24oZSwgaSkgeyB2YXIgcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdC5lYWNoKGksIGZ1bmN0aW9uKHQsIGkpIHsgcy5fcmVuZGVySXRlbURhdGEoZSwgaSkgfSkgfSwgX3JlbmRlckl0ZW1EYXRhOiBmdW5jdGlvbih0LCBlKSB7IHJldHVybiB0aGlzLl9yZW5kZXJJdGVtKHQsIGUpLmRhdGEoXCJ1aS1hdXRvY29tcGxldGUtaXRlbVwiLCBlKSB9LCBfcmVuZGVySXRlbTogZnVuY3Rpb24oZSwgaSkgeyByZXR1cm4gdChcIjxsaT5cIikuYXBwZW5kKHQoXCI8ZGl2PlwiKS50ZXh0KGkubGFiZWwpKS5hcHBlbmRUbyhlKSB9LCBfbW92ZTogZnVuY3Rpb24odCwgZSkgeyByZXR1cm4gdGhpcy5tZW51LmVsZW1lbnQuaXMoXCI6dmlzaWJsZVwiKSA/IHRoaXMubWVudS5pc0ZpcnN0SXRlbSgpICYmIC9ecHJldmlvdXMvLnRlc3QodCkgfHwgdGhpcy5tZW51LmlzTGFzdEl0ZW0oKSAmJiAvXm5leHQvLnRlc3QodCkgPyAodGhpcy5pc011bHRpTGluZSB8fCB0aGlzLl92YWx1ZSh0aGlzLnRlcm0pLCB0aGlzLm1lbnUuYmx1cigpLCB2b2lkIDApIDogKHRoaXMubWVudVt0XShlKSwgdm9pZCAwKSA6ICh0aGlzLnNlYXJjaChudWxsLCBlKSwgdm9pZCAwKSB9LCB3aWRnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5tZW51LmVsZW1lbnQgfSwgX3ZhbHVlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudmFsdWVNZXRob2QuYXBwbHkodGhpcy5lbGVtZW50LCBhcmd1bWVudHMpIH0sIF9rZXlFdmVudDogZnVuY3Rpb24odCwgZSkge1xuICAgICAgICAgICAgICAgICghdGhpcy5pc011bHRpTGluZSB8fCB0aGlzLm1lbnUuZWxlbWVudC5pcyhcIjp2aXNpYmxlXCIpKSAmJiAodGhpcy5fbW92ZSh0LCBlKSwgZS5wcmV2ZW50RGVmYXVsdCgpKSB9LCBfaXNDb250ZW50RWRpdGFibGU6IGZ1bmN0aW9uKHQpIHsgaWYgKCF0Lmxlbmd0aCkgcmV0dXJuICExOyB2YXIgZSA9IHQucHJvcChcImNvbnRlbnRFZGl0YWJsZVwiKTsgcmV0dXJuIFwiaW5oZXJpdFwiID09PSBlID8gdGhpcy5faXNDb250ZW50RWRpdGFibGUodC5wYXJlbnQoKSkgOiBcInRydWVcIiA9PT0gZSB9IH0pLCB0LmV4dGVuZCh0LnVpLmF1dG9jb21wbGV0ZSwgeyBlc2NhcGVSZWdleDogZnVuY3Rpb24odCkgeyByZXR1cm4gdC5yZXBsYWNlKC9bXFwtXFxbXFxde30oKSorPy4sXFxcXFxcXiR8I1xcc10vZywgXCJcXFxcJCZcIikgfSwgZmlsdGVyOiBmdW5jdGlvbihlLCBpKSB7IHZhciBzID0gUmVnRXhwKHQudWkuYXV0b2NvbXBsZXRlLmVzY2FwZVJlZ2V4KGkpLCBcImlcIik7IHJldHVybiB0LmdyZXAoZSwgZnVuY3Rpb24odCkgeyByZXR1cm4gcy50ZXN0KHQubGFiZWwgfHwgdC52YWx1ZSB8fCB0KSB9KSB9IH0pLCB0LndpZGdldChcInVpLmF1dG9jb21wbGV0ZVwiLCB0LnVpLmF1dG9jb21wbGV0ZSwgeyBvcHRpb25zOiB7IG1lc3NhZ2VzOiB7IG5vUmVzdWx0czogXCJObyBzZWFyY2ggcmVzdWx0cy5cIiwgcmVzdWx0czogZnVuY3Rpb24odCkgeyByZXR1cm4gdCArICh0ID4gMSA/IFwiIHJlc3VsdHMgYXJlXCIgOiBcIiByZXN1bHQgaXNcIikgKyBcIiBhdmFpbGFibGUsIHVzZSB1cCBhbmQgZG93biBhcnJvdyBrZXlzIHRvIG5hdmlnYXRlLlwiIH0gfSB9LCBfX3Jlc3BvbnNlOiBmdW5jdGlvbihlKSB7IHZhciBpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1cGVyQXBwbHkoYXJndW1lbnRzKSwgdGhpcy5vcHRpb25zLmRpc2FibGVkIHx8IHRoaXMuY2FuY2VsU2VhcmNoIHx8IChpID0gZSAmJiBlLmxlbmd0aCA/IHRoaXMub3B0aW9ucy5tZXNzYWdlcy5yZXN1bHRzKGUubGVuZ3RoKSA6IHRoaXMub3B0aW9ucy5tZXNzYWdlcy5ub1Jlc3VsdHMsIHRoaXMubGl2ZVJlZ2lvbi5jaGlsZHJlbigpLmhpZGUoKSwgdChcIjxkaXY+XCIpLnRleHQoaSkuYXBwZW5kVG8odGhpcy5saXZlUmVnaW9uKSkgfSB9KSwgdC51aS5hdXRvY29tcGxldGU7XG4gICAgdmFyIHMgPSBcInVpLWVmZmVjdHMtXCIsXG4gICAgICAgIG4gPSBcInVpLWVmZmVjdHMtc3R5bGVcIixcbiAgICAgICAgbyA9IFwidWktZWZmZWN0cy1hbmltYXRlZFwiLFxuICAgICAgICBhID0gdDtcbiAgICB0LmVmZmVjdHMgPSB7IGVmZmVjdDoge30gfSxcbiAgICAgICAgZnVuY3Rpb24odCwgZSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gaSh0LCBlLCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSB1W2UudHlwZV0gfHwge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gdCA/IGkgfHwgIWUuZGVmID8gbnVsbCA6IGUuZGVmIDogKHQgPSBzLmZsb29yID8gfn50IDogcGFyc2VGbG9hdCh0KSwgaXNOYU4odCkgPyBlLmRlZiA6IHMubW9kID8gKHQgKyBzLm1vZCkgJSBzLm1vZCA6IDAgPiB0ID8gMCA6IHQgPiBzLm1heCA/IHMubWF4IDogdClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcyhpKSB7IHZhciBzID0gaCgpLFxuICAgICAgICAgICAgICAgICAgICBuID0gcy5fcmdiYSA9IFtdOyByZXR1cm4gaSA9IGkudG9Mb3dlckNhc2UoKSwgZihsLCBmdW5jdGlvbih0LCBvKSB7IHZhciBhLCByID0gby5yZS5leGVjKGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHIgJiYgby5wYXJzZShyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSBvLnNwYWNlIHx8IFwicmdiYVwiOyByZXR1cm4gbCA/IChhID0gc1toXShsKSwgc1tjW2hdLmNhY2hlXSA9IGFbY1toXS5jYWNoZV0sIG4gPSBzLl9yZ2JhID0gYS5fcmdiYSwgITEpIDogZSB9KSwgbi5sZW5ndGggPyAoXCIwLDAsMCwwXCIgPT09IG4uam9pbigpICYmIHQuZXh0ZW5kKG4sIG8udHJhbnNwYXJlbnQpLCBzKSA6IG9baV0gfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBuKHQsIGUsIGkpIHsgcmV0dXJuIGkgPSAoaSArIDEpICUgMSwgMSA+IDYgKiBpID8gdCArIDYgKiAoZSAtIHQpICogaSA6IDEgPiAyICogaSA/IGUgOiAyID4gMyAqIGkgPyB0ICsgNiAqIChlIC0gdCkgKiAoMiAvIDMgLSBpKSA6IHQgfVxuICAgICAgICAgICAgdmFyIG8sIGEgPSBcImJhY2tncm91bmRDb2xvciBib3JkZXJCb3R0b21Db2xvciBib3JkZXJMZWZ0Q29sb3IgYm9yZGVyUmlnaHRDb2xvciBib3JkZXJUb3BDb2xvciBjb2xvciBjb2x1bW5SdWxlQ29sb3Igb3V0bGluZUNvbG9yIHRleHREZWNvcmF0aW9uQ29sb3IgdGV4dEVtcGhhc2lzQ29sb3JcIixcbiAgICAgICAgICAgICAgICByID0gL14oW1xcLStdKT1cXHMqKFxcZCtcXC4/XFxkKikvLFxuICAgICAgICAgICAgICAgIGwgPSBbeyByZTogL3JnYmE/XFwoXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccyooPzosXFxzKihcXGQ/KD86XFwuXFxkKyk/KVxccyopP1xcKS8sIHBhcnNlOiBmdW5jdGlvbih0KSB7IHJldHVybiBbdFsxXSwgdFsyXSwgdFszXSwgdFs0XV0gfSB9LCB7IHJlOiAvcmdiYT9cXChcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFwlXFxzKixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFwlXFxzKixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pXFwlXFxzKig/OixcXHMqKFxcZD8oPzpcXC5cXGQrKT8pXFxzKik/XFwpLywgcGFyc2U6IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIFsyLjU1ICogdFsxXSwgMi41NSAqIHRbMl0sIDIuNTUgKiB0WzNdLCB0WzRdXSB9IH0sIHsgcmU6IC8jKFthLWYwLTldezJ9KShbYS1mMC05XXsyfSkoW2EtZjAtOV17Mn0pLywgcGFyc2U6IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIFtwYXJzZUludCh0WzFdLCAxNiksIHBhcnNlSW50KHRbMl0sIDE2KSwgcGFyc2VJbnQodFszXSwgMTYpXSB9IH0sIHsgcmU6IC8jKFthLWYwLTldKShbYS1mMC05XSkoW2EtZjAtOV0pLywgcGFyc2U6IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIFtwYXJzZUludCh0WzFdICsgdFsxXSwgMTYpLCBwYXJzZUludCh0WzJdICsgdFsyXSwgMTYpLCBwYXJzZUludCh0WzNdICsgdFszXSwgMTYpXSB9IH0sIHsgcmU6IC9oc2xhP1xcKFxccyooXFxkKyg/OlxcLlxcZCspPylcXHMqLFxccyooXFxkKyg/OlxcLlxcZCspPylcXCVcXHMqLFxccyooXFxkKyg/OlxcLlxcZCspPylcXCVcXHMqKD86LFxccyooXFxkPyg/OlxcLlxcZCspPylcXHMqKT9cXCkvLCBzcGFjZTogXCJoc2xhXCIsIHBhcnNlOiBmdW5jdGlvbih0KSB7IHJldHVybiBbdFsxXSwgdFsyXSAvIDEwMCwgdFszXSAvIDEwMCwgdFs0XV0gfSB9XSxcbiAgICAgICAgICAgICAgICBoID0gdC5Db2xvciA9IGZ1bmN0aW9uKGUsIGksIHMsIG4pIHsgcmV0dXJuIG5ldyB0LkNvbG9yLmZuLnBhcnNlKGUsIGksIHMsIG4pIH0sXG4gICAgICAgICAgICAgICAgYyA9IHsgcmdiYTogeyBwcm9wczogeyByZWQ6IHsgaWR4OiAwLCB0eXBlOiBcImJ5dGVcIiB9LCBncmVlbjogeyBpZHg6IDEsIHR5cGU6IFwiYnl0ZVwiIH0sIGJsdWU6IHsgaWR4OiAyLCB0eXBlOiBcImJ5dGVcIiB9IH0gfSwgaHNsYTogeyBwcm9wczogeyBodWU6IHsgaWR4OiAwLCB0eXBlOiBcImRlZ3JlZXNcIiB9LCBzYXR1cmF0aW9uOiB7IGlkeDogMSwgdHlwZTogXCJwZXJjZW50XCIgfSwgbGlnaHRuZXNzOiB7IGlkeDogMiwgdHlwZTogXCJwZXJjZW50XCIgfSB9IH0gfSxcbiAgICAgICAgICAgICAgICB1ID0geyBcImJ5dGVcIjogeyBmbG9vcjogITAsIG1heDogMjU1IH0sIHBlcmNlbnQ6IHsgbWF4OiAxIH0sIGRlZ3JlZXM6IHsgbW9kOiAzNjAsIGZsb29yOiAhMCB9IH0sXG4gICAgICAgICAgICAgICAgZCA9IGguc3VwcG9ydCA9IHt9LFxuICAgICAgICAgICAgICAgIHAgPSB0KFwiPHA+XCIpWzBdLFxuICAgICAgICAgICAgICAgIGYgPSB0LmVhY2g7XG4gICAgICAgICAgICBwLnN0eWxlLmNzc1RleHQgPSBcImJhY2tncm91bmQtY29sb3I6cmdiYSgxLDEsMSwuNSlcIiwgZC5yZ2JhID0gcC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IuaW5kZXhPZihcInJnYmFcIikgPiAtMSwgZihjLCBmdW5jdGlvbih0LCBlKSB7IGUuY2FjaGUgPSBcIl9cIiArIHQsIGUucHJvcHMuYWxwaGEgPSB7IGlkeDogMywgdHlwZTogXCJwZXJjZW50XCIsIGRlZjogMSB9IH0pLCBoLmZuID0gdC5leHRlbmQoaC5wcm90b3R5cGUsIHsgcGFyc2U6IGZ1bmN0aW9uKG4sIGEsIHIsIGwpIHsgaWYgKG4gPT09IGUpIHJldHVybiB0aGlzLl9yZ2JhID0gW251bGwsIG51bGwsIG51bGwsIG51bGxdLCB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAobi5qcXVlcnkgfHwgbi5ub2RlVHlwZSkgJiYgKG4gPSB0KG4pLmNzcyhhKSwgYSA9IGUpOyB2YXIgdSA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBkID0gdC50eXBlKG4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHRoaXMuX3JnYmEgPSBbXTsgcmV0dXJuIGEgIT09IGUgJiYgKG4gPSBbbiwgYSwgciwgbF0sIGQgPSBcImFycmF5XCIpLCBcInN0cmluZ1wiID09PSBkID8gdGhpcy5wYXJzZShzKG4pIHx8IG8uX2RlZmF1bHQpIDogXCJhcnJheVwiID09PSBkID8gKGYoYy5yZ2JhLnByb3BzLCBmdW5jdGlvbih0LCBlKSB7IHBbZS5pZHhdID0gaShuW2UuaWR4XSwgZSkgfSksIHRoaXMpIDogXCJvYmplY3RcIiA9PT0gZCA/IChuIGluc3RhbmNlb2YgaCA/IGYoYywgZnVuY3Rpb24odCwgZSkgeyBuW2UuY2FjaGVdICYmICh1W2UuY2FjaGVdID0gbltlLmNhY2hlXS5zbGljZSgpKSB9KSA6IGYoYywgZnVuY3Rpb24oZSwgcykgeyB2YXIgbyA9IHMuY2FjaGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmKHMucHJvcHMsIGZ1bmN0aW9uKHQsIGUpIHsgaWYgKCF1W29dICYmIHMudG8pIHsgaWYgKFwiYWxwaGFcIiA9PT0gdCB8fCBudWxsID09IG5bdF0pIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdVtvXSA9IHMudG8odS5fcmdiYSkgfSB1W29dW2UuaWR4XSA9IGkoblt0XSwgZSwgITApIH0pLCB1W29dICYmIDAgPiB0LmluQXJyYXkobnVsbCwgdVtvXS5zbGljZSgwLCAzKSkgJiYgKHVbb11bM10gPSAxLCBzLmZyb20gJiYgKHUuX3JnYmEgPSBzLmZyb20odVtvXSkpKSB9KSwgdGhpcykgOiBlIH0sIGlzOiBmdW5jdGlvbih0KSB7IHZhciBpID0gaCh0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHMgPSAhMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSB0aGlzOyByZXR1cm4gZihjLCBmdW5jdGlvbih0LCBvKSB7IHZhciBhLCByID0gaVtvLmNhY2hlXTsgcmV0dXJuIHIgJiYgKGEgPSBuW28uY2FjaGVdIHx8IG8udG8gJiYgby50byhuLl9yZ2JhKSB8fCBbXSwgZihvLnByb3BzLCBmdW5jdGlvbih0LCBpKSB7IHJldHVybiBudWxsICE9IHJbaS5pZHhdID8gcyA9IHJbaS5pZHhdID09PSBhW2kuaWR4XSA6IGUgfSkpLCBzIH0pLCBzIH0sIF9zcGFjZTogZnVuY3Rpb24oKSB7IHZhciB0ID0gW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gdGhpczsgcmV0dXJuIGYoYywgZnVuY3Rpb24oaSwgcykgeyBlW3MuY2FjaGVdICYmIHQucHVzaChpKSB9KSwgdC5wb3AoKSB9LCB0cmFuc2l0aW9uOiBmdW5jdGlvbih0LCBlKSB7IHZhciBzID0gaCh0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBzLl9zcGFjZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbyA9IGNbbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gMCA9PT0gdGhpcy5hbHBoYSgpID8gaChcInRyYW5zcGFyZW50XCIpIDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBhW28uY2FjaGVdIHx8IG8udG8oYS5fcmdiYSksXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gci5zbGljZSgpOyByZXR1cm4gcyA9IHNbby5jYWNoZV0sIGYoby5wcm9wcywgZnVuY3Rpb24odCwgbikgeyB2YXIgbyA9IG4uaWR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSByW29dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSBzW29dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB1W24udHlwZV0gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBoICYmIChudWxsID09PSBhID8gbFtvXSA9IGggOiAoYy5tb2QgJiYgKGggLSBhID4gYy5tb2QgLyAyID8gYSArPSBjLm1vZCA6IGEgLSBoID4gYy5tb2QgLyAyICYmIChhIC09IGMubW9kKSksIGxbb10gPSBpKChoIC0gYSkgKiBlICsgYSwgbikpKSB9KSwgdGhpc1tuXShsKSB9LCBibGVuZDogZnVuY3Rpb24oZSkgeyBpZiAoMSA9PT0gdGhpcy5fcmdiYVszXSkgcmV0dXJuIHRoaXM7IHZhciBpID0gdGhpcy5fcmdiYS5zbGljZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IGkucG9wKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gaChlKS5fcmdiYTsgcmV0dXJuIGgodC5tYXAoaSwgZnVuY3Rpb24odCwgZSkgeyByZXR1cm4gKDEgLSBzKSAqIG5bZV0gKyBzICogdCB9KSkgfSwgdG9SZ2JhU3RyaW5nOiBmdW5jdGlvbigpIHsgdmFyIGUgPSBcInJnYmEoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gdC5tYXAodGhpcy5fcmdiYSwgZnVuY3Rpb24odCwgZSkgeyByZXR1cm4gbnVsbCA9PSB0ID8gZSA+IDIgPyAxIDogMCA6IHQgfSk7IHJldHVybiAxID09PSBpWzNdICYmIChpLnBvcCgpLCBlID0gXCJyZ2IoXCIpLCBlICsgaS5qb2luKCkgKyBcIilcIiB9LCB0b0hzbGFTdHJpbmc6IGZ1bmN0aW9uKCkgeyB2YXIgZSA9IFwiaHNsYShcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSB0Lm1hcCh0aGlzLmhzbGEoKSwgZnVuY3Rpb24odCwgZSkgeyByZXR1cm4gbnVsbCA9PSB0ICYmICh0ID0gZSA+IDIgPyAxIDogMCksIGUgJiYgMyA+IGUgJiYgKHQgPSBNYXRoLnJvdW5kKDEwMCAqIHQpICsgXCIlXCIpLCB0IH0pOyByZXR1cm4gMSA9PT0gaVszXSAmJiAoaS5wb3AoKSwgZSA9IFwiaHNsKFwiKSwgZSArIGkuam9pbigpICsgXCIpXCIgfSwgdG9IZXhTdHJpbmc6IGZ1bmN0aW9uKGUpIHsgdmFyIGkgPSB0aGlzLl9yZ2JhLnNsaWNlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gaS5wb3AoKTsgcmV0dXJuIGUgJiYgaS5wdXNoKH5+KDI1NSAqIHMpKSwgXCIjXCIgKyB0Lm1hcChpLCBmdW5jdGlvbih0KSB7IHJldHVybiB0ID0gKHQgfHwgMCkudG9TdHJpbmcoMTYpLCAxID09PSB0Lmxlbmd0aCA/IFwiMFwiICsgdCA6IHQgfSkuam9pbihcIlwiKSB9LCB0b1N0cmluZzogZnVuY3Rpb24oKSB7IHJldHVybiAwID09PSB0aGlzLl9yZ2JhWzNdID8gXCJ0cmFuc3BhcmVudFwiIDogdGhpcy50b1JnYmFTdHJpbmcoKSB9IH0pLCBoLmZuLnBhcnNlLnByb3RvdHlwZSA9IGguZm4sIGMuaHNsYS50byA9IGZ1bmN0aW9uKHQpIHsgaWYgKG51bGwgPT0gdFswXSB8fCBudWxsID09IHRbMV0gfHwgbnVsbCA9PSB0WzJdKSByZXR1cm4gW251bGwsIG51bGwsIG51bGwsIHRbM11dOyB2YXIgZSwgaSwgcyA9IHRbMF0gLyAyNTUsXG4gICAgICAgICAgICAgICAgICAgIG4gPSB0WzFdIC8gMjU1LFxuICAgICAgICAgICAgICAgICAgICBvID0gdFsyXSAvIDI1NSxcbiAgICAgICAgICAgICAgICAgICAgYSA9IHRbM10sXG4gICAgICAgICAgICAgICAgICAgIHIgPSBNYXRoLm1heChzLCBuLCBvKSxcbiAgICAgICAgICAgICAgICAgICAgbCA9IE1hdGgubWluKHMsIG4sIG8pLFxuICAgICAgICAgICAgICAgICAgICBoID0gciAtIGwsXG4gICAgICAgICAgICAgICAgICAgIGMgPSByICsgbCxcbiAgICAgICAgICAgICAgICAgICAgdSA9IC41ICogYzsgcmV0dXJuIGUgPSBsID09PSByID8gMCA6IHMgPT09IHIgPyA2MCAqIChuIC0gbykgLyBoICsgMzYwIDogbiA9PT0gciA/IDYwICogKG8gLSBzKSAvIGggKyAxMjAgOiA2MCAqIChzIC0gbikgLyBoICsgMjQwLCBpID0gMCA9PT0gaCA/IDAgOiAuNSA+PSB1ID8gaCAvIGMgOiBoIC8gKDIgLSBjKSwgW01hdGgucm91bmQoZSkgJSAzNjAsIGksIHUsIG51bGwgPT0gYSA/IDEgOiBhXSB9LCBjLmhzbGEuZnJvbSA9IGZ1bmN0aW9uKHQpIHsgaWYgKG51bGwgPT0gdFswXSB8fCBudWxsID09IHRbMV0gfHwgbnVsbCA9PSB0WzJdKSByZXR1cm4gW251bGwsIG51bGwsIG51bGwsIHRbM11dOyB2YXIgZSA9IHRbMF0gLyAzNjAsXG4gICAgICAgICAgICAgICAgICAgIGkgPSB0WzFdLFxuICAgICAgICAgICAgICAgICAgICBzID0gdFsyXSxcbiAgICAgICAgICAgICAgICAgICAgbyA9IHRbM10sXG4gICAgICAgICAgICAgICAgICAgIGEgPSAuNSA+PSBzID8gcyAqICgxICsgaSkgOiBzICsgaSAtIHMgKiBpLFxuICAgICAgICAgICAgICAgICAgICByID0gMiAqIHMgLSBhOyByZXR1cm4gW01hdGgucm91bmQoMjU1ICogbihyLCBhLCBlICsgMSAvIDMpKSwgTWF0aC5yb3VuZCgyNTUgKiBuKHIsIGEsIGUpKSwgTWF0aC5yb3VuZCgyNTUgKiBuKHIsIGEsIGUgLSAxIC8gMykpLCBvXSB9LCBmKGMsIGZ1bmN0aW9uKHMsIG4pIHsgdmFyIG8gPSBuLnByb3BzLFxuICAgICAgICAgICAgICAgICAgICBhID0gbi5jYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgbCA9IG4udG8sXG4gICAgICAgICAgICAgICAgICAgIGMgPSBuLmZyb207XG4gICAgICAgICAgICAgICAgaC5mbltzXSA9IGZ1bmN0aW9uKHMpIHsgaWYgKGwgJiYgIXRoaXNbYV0gJiYgKHRoaXNbYV0gPSBsKHRoaXMuX3JnYmEpKSwgcyA9PT0gZSkgcmV0dXJuIHRoaXNbYV0uc2xpY2UoKTsgdmFyIG4sIHIgPSB0LnR5cGUocyksXG4gICAgICAgICAgICAgICAgICAgICAgICB1ID0gXCJhcnJheVwiID09PSByIHx8IFwib2JqZWN0XCIgPT09IHIgPyBzIDogYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHRoaXNbYV0uc2xpY2UoKTsgcmV0dXJuIGYobywgZnVuY3Rpb24odCwgZSkgeyB2YXIgcyA9IHVbXCJvYmplY3RcIiA9PT0gciA/IHQgOiBlLmlkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsID09IHMgJiYgKHMgPSBkW2UuaWR4XSksIGRbZS5pZHhdID0gaShzLCBlKSB9KSwgYyA/IChuID0gaChjKGQpKSwgblthXSA9IGQsIG4pIDogaChkKSB9LCBmKG8sIGZ1bmN0aW9uKGUsIGkpIHsgaC5mbltlXSB8fCAoaC5mbltlXSA9IGZ1bmN0aW9uKG4pIHsgdmFyIG8sIGEgPSB0LnR5cGUobiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IFwiYWxwaGFcIiA9PT0gZSA/IHRoaXMuX2hzbGEgPyBcImhzbGFcIiA6IFwicmdiYVwiIDogcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoID0gdGhpc1tsXSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBoW2kuaWR4XTsgcmV0dXJuIFwidW5kZWZpbmVkXCIgPT09IGEgPyBjIDogKFwiZnVuY3Rpb25cIiA9PT0gYSAmJiAobiA9IG4uY2FsbCh0aGlzLCBjKSwgYSA9IHQudHlwZShuKSksIG51bGwgPT0gbiAmJiBpLmVtcHR5ID8gdGhpcyA6IChcInN0cmluZ1wiID09PSBhICYmIChvID0gci5leGVjKG4pLCBvICYmIChuID0gYyArIHBhcnNlRmxvYXQob1syXSkgKiAoXCIrXCIgPT09IG9bMV0gPyAxIDogLTEpKSksIGhbaS5pZHhdID0gbiwgdGhpc1tsXShoKSkpIH0pIH0pIH0pLCBoLmhvb2sgPSBmdW5jdGlvbihlKSB7IHZhciBpID0gZS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgICAgICAgZihpLCBmdW5jdGlvbihlLCBpKSB7IHQuY3NzSG9va3NbaV0gPSB7IHNldDogZnVuY3Rpb24oZSwgbikgeyB2YXIgbywgYSwgciA9IFwiXCI7IGlmIChcInRyYW5zcGFyZW50XCIgIT09IG4gJiYgKFwic3RyaW5nXCIgIT09IHQudHlwZShuKSB8fCAobyA9IHMobikpKSkgeyBpZiAobiA9IGgobyB8fCBuKSwgIWQucmdiYSAmJiAxICE9PSBuLl9yZ2JhWzNdKSB7IGZvciAoYSA9IFwiYmFja2dyb3VuZENvbG9yXCIgPT09IGkgPyBlLnBhcmVudE5vZGUgOiBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcIlwiID09PSByIHx8IFwidHJhbnNwYXJlbnRcIiA9PT0gcikgJiYgYSAmJiBhLnN0eWxlOykgdHJ5IHsgciA9IHQuY3NzKGEsIFwiYmFja2dyb3VuZENvbG9yXCIpLCBhID0gYS5wYXJlbnROb2RlIH0gY2F0Y2ggKGwpIHt9IG4gPSBuLmJsZW5kKHIgJiYgXCJ0cmFuc3BhcmVudFwiICE9PSByID8gciA6IFwiX2RlZmF1bHRcIikgfSBuID0gbi50b1JnYmFTdHJpbmcoKSB9IHRyeSB7IGUuc3R5bGVbaV0gPSBuIH0gY2F0Y2ggKGwpIHt9IH0gfSwgdC5meC5zdGVwW2ldID0gZnVuY3Rpb24oZSkgeyBlLmNvbG9ySW5pdCB8fCAoZS5zdGFydCA9IGgoZS5lbGVtLCBpKSwgZS5lbmQgPSBoKGUuZW5kKSwgZS5jb2xvckluaXQgPSAhMCksIHQuY3NzSG9va3NbaV0uc2V0KGUuZWxlbSwgZS5zdGFydC50cmFuc2l0aW9uKGUuZW5kLCBlLnBvcykpIH0gfSkgfSwgaC5ob29rKGEpLCB0LmNzc0hvb2tzLmJvcmRlckNvbG9yID0geyBleHBhbmQ6IGZ1bmN0aW9uKHQpIHsgdmFyIGUgPSB7fTsgcmV0dXJuIGYoW1wiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCJdLCBmdW5jdGlvbihpLCBzKSB7IGVbXCJib3JkZXJcIiArIHMgKyBcIkNvbG9yXCJdID0gdCB9KSwgZSB9IH0sIG8gPSB0LkNvbG9yLm5hbWVzID0geyBhcXVhOiBcIiMwMGZmZmZcIiwgYmxhY2s6IFwiIzAwMDAwMFwiLCBibHVlOiBcIiMwMDAwZmZcIiwgZnVjaHNpYTogXCIjZmYwMGZmXCIsIGdyYXk6IFwiIzgwODA4MFwiLCBncmVlbjogXCIjMDA4MDAwXCIsIGxpbWU6IFwiIzAwZmYwMFwiLCBtYXJvb246IFwiIzgwMDAwMFwiLCBuYXZ5OiBcIiMwMDAwODBcIiwgb2xpdmU6IFwiIzgwODAwMFwiLCBwdXJwbGU6IFwiIzgwMDA4MFwiLCByZWQ6IFwiI2ZmMDAwMFwiLCBzaWx2ZXI6IFwiI2MwYzBjMFwiLCB0ZWFsOiBcIiMwMDgwODBcIiwgd2hpdGU6IFwiI2ZmZmZmZlwiLCB5ZWxsb3c6IFwiI2ZmZmYwMFwiLCB0cmFuc3BhcmVudDogW251bGwsIG51bGwsIG51bGwsIDBdLCBfZGVmYXVsdDogXCIjZmZmZmZmXCIgfVxuICAgICAgICB9KGEpLFxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGUoZSkgeyB2YXIgaSwgcywgbiA9IGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA/IGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGUsIG51bGwpIDogZS5jdXJyZW50U3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIG8gPSB7fTsgaWYgKG4gJiYgbi5sZW5ndGggJiYgblswXSAmJiBuW25bMF1dKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHMgPSBuLmxlbmd0aDsgcy0tOykgaSA9IG5bc10sIFwic3RyaW5nXCIgPT0gdHlwZW9mIG5baV0gJiYgKG9bdC5jYW1lbENhc2UoaSldID0gbltpXSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gbikgXCJzdHJpbmdcIiA9PSB0eXBlb2YgbltpXSAmJiAob1tpXSA9IG5baV0pOyByZXR1cm4gbyB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGkoZSwgaSkgeyB2YXIgcywgbywgYSA9IHt9OyBmb3IgKHMgaW4gaSkgbyA9IGlbc10sIGVbc10gIT09IG8gJiYgKG5bc10gfHwgKHQuZnguc3RlcFtzXSB8fCAhaXNOYU4ocGFyc2VGbG9hdChvKSkpICYmIChhW3NdID0gbykpOyByZXR1cm4gYSB9IHZhciBzID0gW1wiYWRkXCIsIFwicmVtb3ZlXCIsIFwidG9nZ2xlXCJdLFxuICAgICAgICAgICAgICAgIG4gPSB7IGJvcmRlcjogMSwgYm9yZGVyQm90dG9tOiAxLCBib3JkZXJDb2xvcjogMSwgYm9yZGVyTGVmdDogMSwgYm9yZGVyUmlnaHQ6IDEsIGJvcmRlclRvcDogMSwgYm9yZGVyV2lkdGg6IDEsIG1hcmdpbjogMSwgcGFkZGluZzogMSB9O1xuICAgICAgICAgICAgdC5lYWNoKFtcImJvcmRlckxlZnRTdHlsZVwiLCBcImJvcmRlclJpZ2h0U3R5bGVcIiwgXCJib3JkZXJCb3R0b21TdHlsZVwiLCBcImJvcmRlclRvcFN0eWxlXCJdLCBmdW5jdGlvbihlLCBpKSB7IHQuZnguc3RlcFtpXSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgKFwibm9uZVwiICE9PSB0LmVuZCAmJiAhdC5zZXRBdHRyIHx8IDEgPT09IHQucG9zICYmICF0LnNldEF0dHIpICYmIChhLnN0eWxlKHQuZWxlbSwgaSwgdC5lbmQpLCB0LnNldEF0dHIgPSAhMCkgfSB9KSwgdC5mbi5hZGRCYWNrIHx8ICh0LmZuLmFkZEJhY2sgPSBmdW5jdGlvbih0KSB7IHJldHVybiB0aGlzLmFkZChudWxsID09IHQgPyB0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKHQpKSB9KSwgdC5lZmZlY3RzLmFuaW1hdGVDbGFzcyA9IGZ1bmN0aW9uKG4sIG8sIGEsIHIpIHsgdmFyIGwgPSB0LnNwZWVkKG8sIGEsIHIpOyByZXR1cm4gdGhpcy5xdWV1ZShmdW5jdGlvbigpIHsgdmFyIG8sIGEgPSB0KHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgciA9IGEuYXR0cihcImNsYXNzXCIpIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gbC5jaGlsZHJlbiA/IGEuZmluZChcIipcIikuYWRkQmFjaygpIDogYTtcbiAgICAgICAgICAgICAgICAgICAgaCA9IGgubWFwKGZ1bmN0aW9uKCkgeyB2YXIgaSA9IHQodGhpcyk7IHJldHVybiB7IGVsOiBpLCBzdGFydDogZSh0aGlzKSB9IH0pLCBvID0gZnVuY3Rpb24oKSB7IHQuZWFjaChzLCBmdW5jdGlvbih0LCBlKSB7IG5bZV0gJiYgYVtlICsgXCJDbGFzc1wiXShuW2VdKSB9KSB9LCBvKCksIGggPSBoLm1hcChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZW5kID0gZSh0aGlzLmVsWzBdKSwgdGhpcy5kaWZmID0gaSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCksIHRoaXMgfSksIGEuYXR0cihcImNsYXNzXCIsIHIpLCBoID0gaC5tYXAoZnVuY3Rpb24oKSB7IHZhciBlID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gdC5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSB0LmV4dGVuZCh7fSwgbCwgeyBxdWV1ZTogITEsIGNvbXBsZXRlOiBmdW5jdGlvbigpIHsgaS5yZXNvbHZlKGUpIH0gfSk7IHJldHVybiB0aGlzLmVsLmFuaW1hdGUodGhpcy5kaWZmLCBzKSwgaS5wcm9taXNlKCkgfSksIHQud2hlbi5hcHBseSh0LCBoLmdldCgpKS5kb25lKGZ1bmN0aW9uKCkgeyBvKCksIHQuZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKCkgeyB2YXIgZSA9IHRoaXMuZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5lYWNoKHRoaXMuZGlmZiwgZnVuY3Rpb24odCkgeyBlLmNzcyh0LCBcIlwiKSB9KSB9KSwgbC5jb21wbGV0ZS5jYWxsKGFbMF0pIH0pIH0pIH0sIHQuZm4uZXh0ZW5kKHsgYWRkQ2xhc3M6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGZ1bmN0aW9uKGksIHMsIG4sIG8pIHsgcmV0dXJuIHMgPyB0LmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmNhbGwodGhpcywgeyBhZGQ6IGkgfSwgcywgbiwgbykgOiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfSB9KHQuZm4uYWRkQ2xhc3MpLCByZW1vdmVDbGFzczogZnVuY3Rpb24oZSkgeyByZXR1cm4gZnVuY3Rpb24oaSwgcywgbiwgbykgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyB0LmVmZmVjdHMuYW5pbWF0ZUNsYXNzLmNhbGwodGhpcywgeyByZW1vdmU6IGkgfSwgcywgbiwgbykgOiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfSB9KHQuZm4ucmVtb3ZlQ2xhc3MpLCB0b2dnbGVDbGFzczogZnVuY3Rpb24oZSkgeyByZXR1cm4gZnVuY3Rpb24oaSwgcywgbiwgbywgYSkgeyByZXR1cm4gXCJib29sZWFuXCIgPT0gdHlwZW9mIHMgfHwgdm9pZCAwID09PSBzID8gbiA/IHQuZWZmZWN0cy5hbmltYXRlQ2xhc3MuY2FsbCh0aGlzLCBzID8geyBhZGQ6IGkgfSA6IHsgcmVtb3ZlOiBpIH0sIG4sIG8sIGEpIDogZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdC5lZmZlY3RzLmFuaW1hdGVDbGFzcy5jYWxsKHRoaXMsIHsgdG9nZ2xlOiBpIH0sIHMsIG4sIG8pIH0gfSh0LmZuLnRvZ2dsZUNsYXNzKSwgc3dpdGNoQ2xhc3M6IGZ1bmN0aW9uKGUsIGksIHMsIG4sIG8pIHsgcmV0dXJuIHQuZWZmZWN0cy5hbmltYXRlQ2xhc3MuY2FsbCh0aGlzLCB7IGFkZDogaSwgcmVtb3ZlOiBlIH0sIHMsIG4sIG8pIH0gfSkgfSgpLFxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGUoZSwgaSwgcywgbikgeyByZXR1cm4gdC5pc1BsYWluT2JqZWN0KGUpICYmIChpID0gZSwgZSA9IGUuZWZmZWN0KSwgZSA9IHsgZWZmZWN0OiBlIH0sIG51bGwgPT0gaSAmJiAoaSA9IHt9KSwgdC5pc0Z1bmN0aW9uKGkpICYmIChuID0gaSwgcyA9IG51bGwsIGkgPSB7fSksIChcIm51bWJlclwiID09IHR5cGVvZiBpIHx8IHQuZnguc3BlZWRzW2ldKSAmJiAobiA9IHMsIHMgPSBpLCBpID0ge30pLCB0LmlzRnVuY3Rpb24ocykgJiYgKG4gPSBzLCBzID0gbnVsbCksIGkgJiYgdC5leHRlbmQoZSwgaSksIHMgPSBzIHx8IGkuZHVyYXRpb24sIGUuZHVyYXRpb24gPSB0LmZ4Lm9mZiA/IDAgOiBcIm51bWJlclwiID09IHR5cGVvZiBzID8gcyA6IHMgaW4gdC5meC5zcGVlZHMgPyB0LmZ4LnNwZWVkc1tzXSA6IHQuZnguc3BlZWRzLl9kZWZhdWx0LCBlLmNvbXBsZXRlID0gbiB8fCBpLmNvbXBsZXRlLCBlIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaShlKSB7IHJldHVybiAhZSB8fCBcIm51bWJlclwiID09IHR5cGVvZiBlIHx8IHQuZnguc3BlZWRzW2VdID8gITAgOiBcInN0cmluZ1wiICE9IHR5cGVvZiBlIHx8IHQuZWZmZWN0cy5lZmZlY3RbZV0gPyB0LmlzRnVuY3Rpb24oZSkgPyAhMCA6IFwib2JqZWN0XCIgIT0gdHlwZW9mIGUgfHwgZS5lZmZlY3QgPyAhMSA6ICEwIDogITAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBhKHQsIGUpIHsgdmFyIGkgPSBlLm91dGVyV2lkdGgoKSxcbiAgICAgICAgICAgICAgICAgICAgcyA9IGUub3V0ZXJIZWlnaHQoKSxcbiAgICAgICAgICAgICAgICAgICAgbiA9IC9ecmVjdFxcKCgtP1xcZCpcXC4/XFxkKnB4fC0/XFxkKyV8YXV0byksP1xccyooLT9cXGQqXFwuP1xcZCpweHwtP1xcZCslfGF1dG8pLD9cXHMqKC0/XFxkKlxcLj9cXGQqcHh8LT9cXGQrJXxhdXRvKSw/XFxzKigtP1xcZCpcXC4/XFxkKnB4fC0/XFxkKyV8YXV0bylcXCkkLyxcbiAgICAgICAgICAgICAgICAgICAgbyA9IG4uZXhlYyh0KSB8fCBbXCJcIiwgMCwgaSwgcywgMF07IHJldHVybiB7IHRvcDogcGFyc2VGbG9hdChvWzFdKSB8fCAwLCByaWdodDogXCJhdXRvXCIgPT09IG9bMl0gPyBpIDogcGFyc2VGbG9hdChvWzJdKSwgYm90dG9tOiBcImF1dG9cIiA9PT0gb1szXSA/IHMgOiBwYXJzZUZsb2F0KG9bM10pLCBsZWZ0OiBwYXJzZUZsb2F0KG9bNF0pIHx8IDAgfSB9IHQuZXhwciAmJiB0LmV4cHIuZmlsdGVycyAmJiB0LmV4cHIuZmlsdGVycy5hbmltYXRlZCAmJiAodC5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbihlKSB7IHJldHVybiBmdW5jdGlvbihpKSB7IHJldHVybiAhIXQoaSkuZGF0YShvKSB8fCBlKGkpIH0gfSh0LmV4cHIuZmlsdGVycy5hbmltYXRlZCkpLCB0LnVpQmFja0NvbXBhdCAhPT0gITEgJiYgdC5leHRlbmQodC5lZmZlY3RzLCB7IHNhdmU6IGZ1bmN0aW9uKHQsIGUpIHsgZm9yICh2YXIgaSA9IDAsIG4gPSBlLmxlbmd0aDsgbiA+IGk7IGkrKykgbnVsbCAhPT0gZVtpXSAmJiB0LmRhdGEocyArIGVbaV0sIHRbMF0uc3R5bGVbZVtpXV0pIH0sIHJlc3RvcmU6IGZ1bmN0aW9uKHQsIGUpIHsgZm9yICh2YXIgaSwgbiA9IDAsIG8gPSBlLmxlbmd0aDsgbyA+IG47IG4rKykgbnVsbCAhPT0gZVtuXSAmJiAoaSA9IHQuZGF0YShzICsgZVtuXSksIHQuY3NzKGVbbl0sIGkpKSB9LCBzZXRNb2RlOiBmdW5jdGlvbih0LCBlKSB7IHJldHVybiBcInRvZ2dsZVwiID09PSBlICYmIChlID0gdC5pcyhcIjpoaWRkZW5cIikgPyBcInNob3dcIiA6IFwiaGlkZVwiKSwgZSB9LCBjcmVhdGVXcmFwcGVyOiBmdW5jdGlvbihlKSB7IGlmIChlLnBhcmVudCgpLmlzKFwiLnVpLWVmZmVjdHMtd3JhcHBlclwiKSkgcmV0dXJuIGUucGFyZW50KCk7IHZhciBpID0geyB3aWR0aDogZS5vdXRlcldpZHRoKCEwKSwgaGVpZ2h0OiBlLm91dGVySGVpZ2h0KCEwKSwgXCJmbG9hdFwiOiBlLmNzcyhcImZsb2F0XCIpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gdChcIjxkaXY+PC9kaXY+XCIpLmFkZENsYXNzKFwidWktZWZmZWN0cy13cmFwcGVyXCIpLmNzcyh7IGZvbnRTaXplOiBcIjEwMCVcIiwgYmFja2dyb3VuZDogXCJ0cmFuc3BhcmVudFwiLCBib3JkZXI6IFwibm9uZVwiLCBtYXJnaW46IDAsIHBhZGRpbmc6IDAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBuID0geyB3aWR0aDogZS53aWR0aCgpLCBoZWlnaHQ6IGUuaGVpZ2h0KCkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50OyB0cnkgeyBvLmlkIH0gY2F0Y2ggKGEpIHsgbyA9IGRvY3VtZW50LmJvZHkgfSByZXR1cm4gZS53cmFwKHMpLCAoZVswXSA9PT0gbyB8fCB0LmNvbnRhaW5zKGVbMF0sIG8pKSAmJiB0KG8pLnRyaWdnZXIoXCJmb2N1c1wiKSwgcyA9IGUucGFyZW50KCksIFwic3RhdGljXCIgPT09IGUuY3NzKFwicG9zaXRpb25cIikgPyAocy5jc3MoeyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH0pLCBlLmNzcyh7IHBvc2l0aW9uOiBcInJlbGF0aXZlXCIgfSkpIDogKHQuZXh0ZW5kKGksIHsgcG9zaXRpb246IGUuY3NzKFwicG9zaXRpb25cIiksIHpJbmRleDogZS5jc3MoXCJ6LWluZGV4XCIpIH0pLCB0LmVhY2goW1widG9wXCIsIFwibGVmdFwiLCBcImJvdHRvbVwiLCBcInJpZ2h0XCJdLCBmdW5jdGlvbih0LCBzKSB7IGlbc10gPSBlLmNzcyhzKSwgaXNOYU4ocGFyc2VJbnQoaVtzXSwgMTApKSAmJiAoaVtzXSA9IFwiYXV0b1wiKSB9KSwgZS5jc3MoeyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLCB0b3A6IDAsIGxlZnQ6IDAsIHJpZ2h0OiBcImF1dG9cIiwgYm90dG9tOiBcImF1dG9cIiB9KSksIGUuY3NzKG4pLCBzLmNzcyhpKS5zaG93KCkgfSwgcmVtb3ZlV3JhcHBlcjogZnVuY3Rpb24oZSkgeyB2YXIgaSA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7IHJldHVybiBlLnBhcmVudCgpLmlzKFwiLnVpLWVmZmVjdHMtd3JhcHBlclwiKSAmJiAoZS5wYXJlbnQoKS5yZXBsYWNlV2l0aChlKSwgKGVbMF0gPT09IGkgfHwgdC5jb250YWlucyhlWzBdLCBpKSkgJiYgdChpKS50cmlnZ2VyKFwiZm9jdXNcIikpLCBlIH0gfSksIHQuZXh0ZW5kKHQuZWZmZWN0cywgeyB2ZXJzaW9uOiBcIjEuMTIuMVwiLCBkZWZpbmU6IGZ1bmN0aW9uKGUsIGksIHMpIHsgcmV0dXJuIHMgfHwgKHMgPSBpLCBpID0gXCJlZmZlY3RcIiksIHQuZWZmZWN0cy5lZmZlY3RbZV0gPSBzLCB0LmVmZmVjdHMuZWZmZWN0W2VdLm1vZGUgPSBpLCBzIH0sIHNjYWxlZERpbWVuc2lvbnM6IGZ1bmN0aW9uKHQsIGUsIGkpIHsgaWYgKDAgPT09IGUpIHJldHVybiB7IGhlaWdodDogMCwgd2lkdGg6IDAsIG91dGVySGVpZ2h0OiAwLCBvdXRlcldpZHRoOiAwIH07IHZhciBzID0gXCJob3Jpem9udGFsXCIgIT09IGkgPyAoZSB8fCAxMDApIC8gMTAwIDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBcInZlcnRpY2FsXCIgIT09IGkgPyAoZSB8fCAxMDApIC8gMTAwIDogMTsgcmV0dXJuIHsgaGVpZ2h0OiB0LmhlaWdodCgpICogbiwgd2lkdGg6IHQud2lkdGgoKSAqIHMsIG91dGVySGVpZ2h0OiB0Lm91dGVySGVpZ2h0KCkgKiBuLCBvdXRlcldpZHRoOiB0Lm91dGVyV2lkdGgoKSAqIHMgfSB9LCBjbGlwVG9Cb3g6IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHsgd2lkdGg6IHQuY2xpcC5yaWdodCAtIHQuY2xpcC5sZWZ0LCBoZWlnaHQ6IHQuY2xpcC5ib3R0b20gLSB0LmNsaXAudG9wLCBsZWZ0OiB0LmNsaXAubGVmdCwgdG9wOiB0LmNsaXAudG9wIH0gfSwgdW5zaGlmdDogZnVuY3Rpb24odCwgZSwgaSkgeyB2YXIgcyA9IHQucXVldWUoKTtcbiAgICAgICAgICAgICAgICAgICAgZSA+IDEgJiYgcy5zcGxpY2UuYXBwbHkocywgWzEsIDBdLmNvbmNhdChzLnNwbGljZShlLCBpKSkpLCB0LmRlcXVldWUoKSB9LCBzYXZlU3R5bGU6IGZ1bmN0aW9uKHQpIHsgdC5kYXRhKG4sIHRbMF0uc3R5bGUuY3NzVGV4dCkgfSwgcmVzdG9yZVN0eWxlOiBmdW5jdGlvbih0KSB7IHRbMF0uc3R5bGUuY3NzVGV4dCA9IHQuZGF0YShuKSB8fCBcIlwiLCB0LnJlbW92ZURhdGEobikgfSwgbW9kZTogZnVuY3Rpb24odCwgZSkgeyB2YXIgaSA9IHQuaXMoXCI6aGlkZGVuXCIpOyByZXR1cm4gXCJ0b2dnbGVcIiA9PT0gZSAmJiAoZSA9IGkgPyBcInNob3dcIiA6IFwiaGlkZVwiKSwgKGkgPyBcImhpZGVcIiA9PT0gZSA6IFwic2hvd1wiID09PSBlKSAmJiAoZSA9IFwibm9uZVwiKSwgZSB9LCBnZXRCYXNlbGluZTogZnVuY3Rpb24odCwgZSkgeyB2YXIgaSwgczsgc3dpdGNoICh0WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDA7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAuNTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDE7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gdFswXSAvIGUuaGVpZ2h0IH0gc3dpdGNoICh0WzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSAwOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gLjU7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IDE7IGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gdFsxXSAvIGUud2lkdGggfSByZXR1cm4geyB4OiBzLCB5OiBpIH0gfSwgY3JlYXRlUGxhY2Vob2xkZXI6IGZ1bmN0aW9uKGUpIHsgdmFyIGksIG4gPSBlLmNzcyhcInBvc2l0aW9uXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbyA9IGUucG9zaXRpb24oKTsgcmV0dXJuIGUuY3NzKHsgbWFyZ2luVG9wOiBlLmNzcyhcIm1hcmdpblRvcFwiKSwgbWFyZ2luQm90dG9tOiBlLmNzcyhcIm1hcmdpbkJvdHRvbVwiKSwgbWFyZ2luTGVmdDogZS5jc3MoXCJtYXJnaW5MZWZ0XCIpLCBtYXJnaW5SaWdodDogZS5jc3MoXCJtYXJnaW5SaWdodFwiKSB9KS5vdXRlcldpZHRoKGUub3V0ZXJXaWR0aCgpKS5vdXRlckhlaWdodChlLm91dGVySGVpZ2h0KCkpLCAvXihzdGF0aWN8cmVsYXRpdmUpLy50ZXN0KG4pICYmIChuID0gXCJhYnNvbHV0ZVwiLCBpID0gdChcIjxcIiArIGVbMF0ubm9kZU5hbWUgKyBcIj5cIikuaW5zZXJ0QWZ0ZXIoZSkuY3NzKHsgZGlzcGxheTogL14oaW5saW5lfHJ1YnkpLy50ZXN0KGUuY3NzKFwiZGlzcGxheVwiKSkgPyBcImlubGluZS1ibG9ja1wiIDogXCJibG9ja1wiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBtYXJnaW5Ub3A6IGUuY3NzKFwibWFyZ2luVG9wXCIpLCBtYXJnaW5Cb3R0b206IGUuY3NzKFwibWFyZ2luQm90dG9tXCIpLCBtYXJnaW5MZWZ0OiBlLmNzcyhcIm1hcmdpbkxlZnRcIiksIG1hcmdpblJpZ2h0OiBlLmNzcyhcIm1hcmdpblJpZ2h0XCIpLCBcImZsb2F0XCI6IGUuY3NzKFwiZmxvYXRcIikgfSkub3V0ZXJXaWR0aChlLm91dGVyV2lkdGgoKSkub3V0ZXJIZWlnaHQoZS5vdXRlckhlaWdodCgpKS5hZGRDbGFzcyhcInVpLWVmZmVjdHMtcGxhY2Vob2xkZXJcIiksIGUuZGF0YShzICsgXCJwbGFjZWhvbGRlclwiLCBpKSksIGUuY3NzKHsgcG9zaXRpb246IG4sIGxlZnQ6IG8ubGVmdCwgdG9wOiBvLnRvcCB9KSwgaSB9LCByZW1vdmVQbGFjZWhvbGRlcjogZnVuY3Rpb24odCkgeyB2YXIgZSA9IHMgKyBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gdC5kYXRhKGUpO1xuICAgICAgICAgICAgICAgICAgICBpICYmIChpLnJlbW92ZSgpLCB0LnJlbW92ZURhdGEoZSkpIH0sIGNsZWFuVXA6IGZ1bmN0aW9uKGUpIHsgdC5lZmZlY3RzLnJlc3RvcmVTdHlsZShlKSwgdC5lZmZlY3RzLnJlbW92ZVBsYWNlaG9sZGVyKGUpIH0sIHNldFRyYW5zaXRpb246IGZ1bmN0aW9uKGUsIGksIHMsIG4pIHsgcmV0dXJuIG4gPSBuIHx8IHt9LCB0LmVhY2goaSwgZnVuY3Rpb24odCwgaSkgeyB2YXIgbyA9IGUuY3NzVW5pdChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9bMF0gPiAwICYmIChuW2ldID0gb1swXSAqIHMgKyBvWzFdKSB9KSwgbiB9IH0pLCB0LmZuLmV4dGVuZCh7IGVmZmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGkoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gaSgpIHsgbC5yZW1vdmVEYXRhKG8pLCB0LmVmZmVjdHMuY2xlYW5VcChsKSwgXCJoaWRlXCIgPT09IHMubW9kZSAmJiBsLmhpZGUoKSwgcigpIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcigpIHsgdC5pc0Z1bmN0aW9uKGgpICYmIGguY2FsbChsWzBdKSwgdC5pc0Z1bmN0aW9uKGUpICYmIGUoKSB9IHZhciBsID0gdCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMubW9kZSA9IHUuc2hpZnQoKSwgdC51aUJhY2tDb21wYXQgPT09ICExIHx8IGEgPyBcIm5vbmVcIiA9PT0gcy5tb2RlID8gKGxbY10oKSwgcigpKSA6IG4uY2FsbChsWzBdLCBzLCBpKSA6IChsLmlzKFwiOmhpZGRlblwiKSA/IFwiaGlkZVwiID09PSBjIDogXCJzaG93XCIgPT09IGMpID8gKGxbY10oKSwgcigpKSA6IG4uY2FsbChsWzBdLCBzLCByKSB9IHZhciBzID0gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IHQuZWZmZWN0cy5lZmZlY3Rbcy5lZmZlY3RdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IG4ubW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBzLnF1ZXVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHIgfHwgXCJmeFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHMuY29tcGxldGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gcy5tb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdSA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IGZ1bmN0aW9uKGUpIHsgdmFyIGkgPSB0KHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gdC5lZmZlY3RzLm1vZGUoaSwgYykgfHwgYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLmRhdGEobywgITApLCB1LnB1c2gocyksIGEgJiYgKFwic2hvd1wiID09PSBzIHx8IHMgPT09IGEgJiYgXCJoaWRlXCIgPT09IHMpICYmIGkuc2hvdygpLCBhICYmIFwibm9uZVwiID09PSBzIHx8IHQuZWZmZWN0cy5zYXZlU3R5bGUoaSksIHQuaXNGdW5jdGlvbihlKSAmJiBlKCkgfTsgcmV0dXJuIHQuZngub2ZmIHx8ICFuID8gYyA/IHRoaXNbY10ocy5kdXJhdGlvbiwgaCkgOiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IGggJiYgaC5jYWxsKHRoaXMpIH0pIDogciA9PT0gITEgPyB0aGlzLmVhY2goZCkuZWFjaChpKSA6IHRoaXMucXVldWUobCwgZCkucXVldWUobCwgaSkgfSwgc2hvdzogZnVuY3Rpb24odCkgeyByZXR1cm4gZnVuY3Rpb24ocykgeyBpZiAoaShzKSkgcmV0dXJuIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgdmFyIG4gPSBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuLm1vZGUgPSBcInNob3dcIiwgdGhpcy5lZmZlY3QuY2FsbCh0aGlzLCBuKSB9IH0odC5mbi5zaG93KSwgaGlkZTogZnVuY3Rpb24odCkgeyByZXR1cm4gZnVuY3Rpb24ocykgeyBpZiAoaShzKSkgcmV0dXJuIHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgdmFyIG4gPSBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHJldHVybiBuLm1vZGUgPSBcImhpZGVcIiwgdGhpcy5lZmZlY3QuY2FsbCh0aGlzLCBuKSB9IH0odC5mbi5oaWRlKSwgdG9nZ2xlOiBmdW5jdGlvbih0KSB7IHJldHVybiBmdW5jdGlvbihzKSB7IGlmIChpKHMpIHx8IFwiYm9vbGVhblwiID09IHR5cGVvZiBzKSByZXR1cm4gdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB2YXIgbiA9IGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgcmV0dXJuIG4ubW9kZSA9IFwidG9nZ2xlXCIsIHRoaXMuZWZmZWN0LmNhbGwodGhpcywgbikgfSB9KHQuZm4udG9nZ2xlKSwgY3NzVW5pdDogZnVuY3Rpb24oZSkgeyB2YXIgaSA9IHRoaXMuY3NzKGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IFtdOyByZXR1cm4gdC5lYWNoKFtcImVtXCIsIFwicHhcIiwgXCIlXCIsIFwicHRcIl0sIGZ1bmN0aW9uKHQsIGUpIHsgaS5pbmRleE9mKGUpID4gMCAmJiAocyA9IFtwYXJzZUZsb2F0KGkpLCBlXSkgfSksIHMgfSwgY3NzQ2xpcDogZnVuY3Rpb24odCkgeyByZXR1cm4gdCA/IHRoaXMuY3NzKFwiY2xpcFwiLCBcInJlY3QoXCIgKyB0LnRvcCArIFwicHggXCIgKyB0LnJpZ2h0ICsgXCJweCBcIiArIHQuYm90dG9tICsgXCJweCBcIiArIHQubGVmdCArIFwicHgpXCIpIDogYSh0aGlzLmNzcyhcImNsaXBcIiksIHRoaXMpIH0sIHRyYW5zZmVyOiBmdW5jdGlvbihlLCBpKSB7IHZhciBzID0gdCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSB0KGUudG8pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbyA9IFwiZml4ZWRcIiA9PT0gbi5jc3MoXCJwb3NpdGlvblwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSB0KFwiYm9keVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBvID8gYS5zY3JvbGxUb3AoKSA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gbyA/IGEuc2Nyb2xsTGVmdCgpIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSBuLm9mZnNldCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHsgdG9wOiBoLnRvcCAtIHIsIGxlZnQ6IGgubGVmdCAtIGwsIGhlaWdodDogbi5pbm5lckhlaWdodCgpLCB3aWR0aDogbi5pbm5lcldpZHRoKCkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHUgPSBzLm9mZnNldCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZCA9IHQoXCI8ZGl2IGNsYXNzPSd1aS1lZmZlY3RzLXRyYW5zZmVyJz48L2Rpdj5cIikuYXBwZW5kVG8oXCJib2R5XCIpLmFkZENsYXNzKGUuY2xhc3NOYW1lKS5jc3MoeyB0b3A6IHUudG9wIC0gciwgbGVmdDogdS5sZWZ0IC0gbCwgaGVpZ2h0OiBzLmlubmVySGVpZ2h0KCksIHdpZHRoOiBzLmlubmVyV2lkdGgoKSwgcG9zaXRpb246IG8gPyBcImZpeGVkXCIgOiBcImFic29sdXRlXCIgfSkuYW5pbWF0ZShjLCBlLmR1cmF0aW9uLCBlLmVhc2luZywgZnVuY3Rpb24oKSB7IGQucmVtb3ZlKCksIHQuaXNGdW5jdGlvbihpKSAmJiBpKCkgfSkgfSB9KSwgdC5meC5zdGVwLmNsaXAgPSBmdW5jdGlvbihlKSB7IGUuY2xpcEluaXQgfHwgKGUuc3RhcnQgPSB0KGUuZWxlbSkuY3NzQ2xpcCgpLCBcInN0cmluZ1wiID09IHR5cGVvZiBlLmVuZCAmJiAoZS5lbmQgPSBhKGUuZW5kLCBlLmVsZW0pKSwgZS5jbGlwSW5pdCA9ICEwKSwgdChlLmVsZW0pLmNzc0NsaXAoeyB0b3A6IGUucG9zICogKGUuZW5kLnRvcCAtIGUuc3RhcnQudG9wKSArIGUuc3RhcnQudG9wLCByaWdodDogZS5wb3MgKiAoZS5lbmQucmlnaHQgLSBlLnN0YXJ0LnJpZ2h0KSArIGUuc3RhcnQucmlnaHQsIGJvdHRvbTogZS5wb3MgKiAoZS5lbmQuYm90dG9tIC0gZS5zdGFydC5ib3R0b20pICsgZS5zdGFydC5ib3R0b20sIGxlZnQ6IGUucG9zICogKGUuZW5kLmxlZnQgLSBlLnN0YXJ0LmxlZnQpICsgZS5zdGFydC5sZWZ0IH0pIH0gfSgpLFxuICAgICAgICBmdW5jdGlvbigpIHsgdmFyIGUgPSB7fTtcbiAgICAgICAgICAgIHQuZWFjaChbXCJRdWFkXCIsIFwiQ3ViaWNcIiwgXCJRdWFydFwiLCBcIlF1aW50XCIsIFwiRXhwb1wiXSwgZnVuY3Rpb24odCwgaSkgeyBlW2ldID0gZnVuY3Rpb24oZSkgeyByZXR1cm4gTWF0aC5wb3coZSwgdCArIDIpIH0gfSksIHQuZXh0ZW5kKGUsIHsgU2luZTogZnVuY3Rpb24odCkgeyByZXR1cm4gMSAtIE1hdGguY29zKHQgKiBNYXRoLlBJIC8gMikgfSwgQ2lyYzogZnVuY3Rpb24odCkgeyByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpIH0sIEVsYXN0aWM6IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIDAgPT09IHQgfHwgMSA9PT0gdCA/IHQgOiAtTWF0aC5wb3coMiwgOCAqICh0IC0gMSkpICogTWF0aC5zaW4oKDgwICogKHQgLSAxKSAtIDcuNSkgKiBNYXRoLlBJIC8gMTUpIH0sIEJhY2s6IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHQgKiB0ICogKDMgKiB0IC0gMikgfSwgQm91bmNlOiBmdW5jdGlvbih0KSB7IGZvciAodmFyIGUsIGkgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgKChlID0gTWF0aC5wb3coMiwgLS1pKSkgLSAxKSAvIDExID4gdDspOyByZXR1cm4gMSAvIE1hdGgucG93KDQsIDMgLSBpKSAtIDcuNTYyNSAqIE1hdGgucG93KCgzICogZSAtIDIpIC8gMjIgLSB0LCAyKSB9IH0pLCB0LmVhY2goZSwgZnVuY3Rpb24oZSwgaSkgeyB0LmVhc2luZ1tcImVhc2VJblwiICsgZV0gPSBpLCB0LmVhc2luZ1tcImVhc2VPdXRcIiArIGVdID0gZnVuY3Rpb24odCkgeyByZXR1cm4gMSAtIGkoMSAtIHQpIH0sIHQuZWFzaW5nW1wiZWFzZUluT3V0XCIgKyBlXSA9IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIC41ID4gdCA/IGkoMiAqIHQpIC8gMiA6IDEgLSBpKC0yICogdCArIDIpIC8gMiB9IH0pIH0oKSwgdC5lZmZlY3RzLCB0LmVmZmVjdHMuZGVmaW5lKFwic2xpZGVcIiwgXCJzaG93XCIsIGZ1bmN0aW9uKGUsIGkpIHsgdmFyIHMsIG4sIG8gPSB0KHRoaXMpLFxuICAgICAgICAgICAgICAgIGEgPSB7IHVwOiBbXCJib3R0b21cIiwgXCJ0b3BcIl0sIGRvd246IFtcInRvcFwiLCBcImJvdHRvbVwiXSwgbGVmdDogW1wicmlnaHRcIiwgXCJsZWZ0XCJdLCByaWdodDogW1wibGVmdFwiLCBcInJpZ2h0XCJdIH0sXG4gICAgICAgICAgICAgICAgciA9IGUubW9kZSxcbiAgICAgICAgICAgICAgICBsID0gZS5kaXJlY3Rpb24gfHwgXCJsZWZ0XCIsXG4gICAgICAgICAgICAgICAgaCA9IFwidXBcIiA9PT0gbCB8fCBcImRvd25cIiA9PT0gbCA/IFwidG9wXCIgOiBcImxlZnRcIixcbiAgICAgICAgICAgICAgICBjID0gXCJ1cFwiID09PSBsIHx8IFwibGVmdFwiID09PSBsLFxuICAgICAgICAgICAgICAgIHUgPSBlLmRpc3RhbmNlIHx8IG9bXCJ0b3BcIiA9PT0gaCA/IFwib3V0ZXJIZWlnaHRcIiA6IFwib3V0ZXJXaWR0aFwiXSghMCksXG4gICAgICAgICAgICAgICAgZCA9IHt9O1xuICAgICAgICAgICAgdC5lZmZlY3RzLmNyZWF0ZVBsYWNlaG9sZGVyKG8pLCBzID0gby5jc3NDbGlwKCksIG4gPSBvLnBvc2l0aW9uKClbaF0sIGRbaF0gPSAoYyA/IC0xIDogMSkgKiB1ICsgbiwgZC5jbGlwID0gby5jc3NDbGlwKCksIGQuY2xpcFthW2xdWzFdXSA9IGQuY2xpcFthW2xdWzBdXSwgXCJzaG93XCIgPT09IHIgJiYgKG8uY3NzQ2xpcChkLmNsaXApLCBvLmNzcyhoLCBkW2hdKSwgZC5jbGlwID0gcywgZFtoXSA9IG4pLCBvLmFuaW1hdGUoZCwgeyBxdWV1ZTogITEsIGR1cmF0aW9uOiBlLmR1cmF0aW9uLCBlYXNpbmc6IGUuZWFzaW5nLCBjb21wbGV0ZTogaSB9KSB9KVxufSk7Il0sImZpbGUiOiJqcXVlcnktdWkubWluLmpzIn0=
