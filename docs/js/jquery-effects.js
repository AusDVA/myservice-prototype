! function(e, t) { "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function(e) { if (!e.document) throw new Error("jQuery requires a window with a document"); return t(e) } : t(e) }("undefined" != typeof window ? window : this, function(e, t) {
    function n(e) { var t = e.length,
            n = L.type(e); return "function" !== n && !L.isWindow(e) && (!(1 !== e.nodeType || !t) || ("array" === n || 0 === t || "number" == typeof t && t > 0 && t - 1 in e)) }

    function r(e, t, n) { if (L.isFunction(t)) return L.grep(e, function(e, r) { return !!t.call(e, r, e) !== n }); if (t.nodeType) return L.grep(e, function(e) { return e === t !== n }); if ("string" == typeof t) { if (B.test(t)) return L.filter(t, e, n);
            t = L.filter(t, e) } return L.grep(e, function(e) { return w.call(t, e) >= 0 !== n }) }

    function i(e, t) { for (;
            (e = e[t]) && 1 !== e.nodeType;); return e }

    function o(e) { var t = z[e] = {}; return L.each(e.match(Q) || [], function(e, n) { t[n] = !0 }), t }

    function a() { E.removeEventListener("DOMContentLoaded", a, !1), e.removeEventListener("load", a, !1), L.ready() }

    function s() { Object.defineProperty(this.cache = {}, 0, { get: function() { return {} } }), this.expando = L.expando + Math.random() }

    function u(e, t, n) { var r; if (void 0 === n && 1 === e.nodeType)
            if (r = "data-" + t.replace(ee, "-$1").toLowerCase(), "string" == typeof(n = e.getAttribute(r))) { try { n = "true" === n || "false" !== n && ("null" === n ? null : +n + "" === n ? +n : Z.test(n) ? L.parseJSON(n) : n) } catch (e) {} G.set(e, t, n) } else n = void 0; return n }

    function c() { return !0 }

    function l() { return !1 }

    function f() { try { return E.activeElement } catch (e) {} }

    function d(e, t) { return L.nodeName(e, "table") && L.nodeName(11 !== t.nodeType ? t : t.firstChild, "tr") ? e.getElementsByTagName("tbody")[0] || e.appendChild(e.ownerDocument.createElement("tbody")) : e }

    function p(e) { return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e }

    function h(e) { var t = de.exec(e.type); return t ? e.type = t[1] : e.removeAttribute("type"), e }

    function v(e, t) { for (var n = 0, r = e.length; n < r; n++) J.set(e[n], "globalEval", !t || J.get(t[n], "globalEval")) }

    function g(e, t) { var n, r, i, o, a, s, u, c; if (1 === t.nodeType) { if (J.hasData(e) && (o = J.access(e), a = J.set(t, o), c = o.events)) { delete a.handle, a.events = {}; for (i in c)
                    for (n = 0, r = c[i].length; n < r; n++) L.event.add(t, i, c[i][n]) } G.hasData(e) && (s = G.access(e), u = L.extend({}, s), G.set(t, u)) } }

    function m(e, t) { var n = e.getElementsByTagName ? e.getElementsByTagName(t || "*") : e.querySelectorAll ? e.querySelectorAll(t || "*") : []; return void 0 === t || t && L.nodeName(e, t) ? L.merge([e], n) : n }

    function y(e, t) { var n = t.nodeName.toLowerCase(); "input" === n && te.test(e.type) ? t.checked = e.checked : "input" !== n && "textarea" !== n || (t.defaultValue = e.defaultValue) }

    function b(e, t, n, r) { var i; if (L.isArray(t)) L.each(t, function(t, i) { n || ke.test(e) ? r(e, i) : b(e + "[" + ("object" == typeof i ? t : "") + "]", i, n, r) });
        else if (n || "object" !== L.type(t)) r(e, t);
        else
            for (i in t) b(e + "[" + i + "]", t[i], n, r) } var x = [],
        k = x.slice,
        T = x.concat,
        C = x.push,
        w = x.indexOf,
        D = {},
        N = D.toString,
        j = D.hasOwnProperty,
        A = {},
        E = e.document,
        S = "2.1.1 -ajax,-ajax/jsonp,-ajax/load,-ajax/parseJSON,-ajax/parseXML,-ajax/script,-ajax/var/nonce,-ajax/var/rquery,-ajax/xhr,-manipulation/_evalUrl,-css,-css/addGetHookIf,-css/curCSS,-css/defaultDisplay,-css/hiddenVisibleSelectors,-css/support,-css/swap,-css/var/cssExpand,-css/var/getStyles,-css/var/isHidden,-css/var/rmargin,-css/var/rnumnonpx,-effects,-effects/Tween,-effects/animatedSelector,-dimensions,-offset,-deprecated,-event-alias,-wrap",
        L = function(e, t) { return new L.fn.init(e, t) },
        q = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
        O = /^-ms-/,
        F = /-([\da-z])/gi,
        H = function(e, t) { return t.toUpperCase() };
    L.fn = L.prototype = { jquery: S, constructor: L, selector: "", length: 0, toArray: function() { return k.call(this) }, get: function(e) { return null != e ? e < 0 ? this[e + this.length] : this[e] : k.call(this) }, pushStack: function(e) { var t = L.merge(this.constructor(), e); return t.prevObject = this, t.context = this.context, t }, each: function(e, t) { return L.each(this, e, t) }, map: function(e) { return this.pushStack(L.map(this, function(t, n) { return e.call(t, n, t) })) }, slice: function() { return this.pushStack(k.apply(this, arguments)) }, first: function() { return this.eq(0) }, last: function() { return this.eq(-1) }, eq: function(e) { var t = this.length,
                n = +e + (e < 0 ? t : 0); return this.pushStack(n >= 0 && n < t ? [this[n]] : []) }, end: function() { return this.prevObject || this.constructor(null) }, push: C, sort: x.sort, splice: x.splice }, L.extend = L.fn.extend = function() { var e, t, n, r, i, o, a = arguments[0] || {},
            s = 1,
            u = arguments.length,
            c = !1; for ("boolean" == typeof a && (c = a, a = arguments[s] || {}, s++), "object" == typeof a || L.isFunction(a) || (a = {}), s === u && (a = this, s--); s < u; s++)
            if (null != (e = arguments[s]))
                for (t in e) n = a[t], a !== (r = e[t]) && (c && r && (L.isPlainObject(r) || (i = L.isArray(r))) ? (i ? (i = !1, o = n && L.isArray(n) ? n : []) : o = n && L.isPlainObject(n) ? n : {}, a[t] = L.extend(c, o, r)) : void 0 !== r && (a[t] = r)); return a }, L.extend({ expando: "jQuery" + (S + Math.random()).replace(/\D/g, ""), isReady: !0, error: function(e) { throw new Error(e) }, noop: function() {}, isFunction: function(e) { return "function" === L.type(e) }, isArray: Array.isArray, isWindow: function(e) { return null != e && e === e.window }, isNumeric: function(e) { return !L.isArray(e) && e - parseFloat(e) >= 0 }, isPlainObject: function(e) { return "object" === L.type(e) && !e.nodeType && !L.isWindow(e) && !(e.constructor && !j.call(e.constructor.prototype, "isPrototypeOf")) }, isEmptyObject: function(e) { var t; for (t in e) return !1; return !0 }, type: function(e) { return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? D[N.call(e)] || "object" : typeof e }, globalEval: function(e) { var t, n = eval;
            (e = L.trim(e)) && (1 === e.indexOf("use strict") ? ((t = E.createElement("script")).text = e, E.head.appendChild(t).parentNode.removeChild(t)) : n(e)) }, camelCase: function(e) { return e.replace(O, "ms-").replace(F, H) }, nodeName: function(e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase() }, each: function(e, t, r) { var i = 0,
                o = e.length,
                a = n(e); if (r) { if (a)
                    for (; i < o && !1 !== t.apply(e[i], r); i++);
                else
                    for (i in e)
                        if (!1 === t.apply(e[i], r)) break } else if (a)
                for (; i < o && !1 !== t.call(e[i], i, e[i]); i++);
            else
                for (i in e)
                    if (!1 === t.call(e[i], i, e[i])) break; return e }, trim: function(e) { return null == e ? "" : (e + "").replace(q, "") }, makeArray: function(e, t) { var r = t || []; return null != e && (n(Object(e)) ? L.merge(r, "string" == typeof e ? [e] : e) : C.call(r, e)), r }, inArray: function(e, t, n) { return null == t ? -1 : w.call(t, e, n) }, merge: function(e, t) { for (var n = +t.length, r = 0, i = e.length; r < n; r++) e[i++] = t[r]; return e.length = i, e }, grep: function(e, t, n) { for (var r = [], i = 0, o = e.length, a = !n; i < o; i++) !t(e[i], i) !== a && r.push(e[i]); return r }, map: function(e, t, r) { var i, o = 0,
                a = e.length,
                s = []; if (n(e))
                for (; o < a; o++) null != (i = t(e[o], o, r)) && s.push(i);
            else
                for (o in e) null != (i = t(e[o], o, r)) && s.push(i); return T.apply([], s) }, guid: 1, proxy: function(e, t) { var n, r, i; if ("string" == typeof t && (n = e[t], t = e, e = n), L.isFunction(e)) return r = k.call(arguments, 2), i = function() { return e.apply(t || this, r.concat(k.call(arguments))) }, i.guid = e.guid = e.guid || L.guid++, i }, now: Date.now, support: A }), L.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(e, t) { D["[object " + t + "]"] = t.toLowerCase() }); var P, M = e.document.documentElement,
        W = M.matches || M.webkitMatchesSelector || M.mozMatchesSelector || M.oMatchesSelector || M.msMatchesSelector,
        $ = function(e, t) { if (e === t) return P = !0, 0; var n = t.compareDocumentPosition && e.compareDocumentPosition && e.compareDocumentPosition(t); return n ? 1 & n ? e === E || L.contains(E, e) ? -1 : t === E || L.contains(E, t) ? 1 : 0 : 4 & n ? -1 : 1 : e.compareDocumentPosition ? -1 : 1 };
    L.extend({ find: function(e, t, n, r) { var i, o, a = 0; if (n = n || [], t = t || E, !e || "string" != typeof e) return n; if (1 !== (o = t.nodeType) && 9 !== o) return []; if (r)
                for (; i = r[a++];) L.find.matchesSelector(i, e) && n.push(i);
            else L.merge(n, t.querySelectorAll(e)); return n }, unique: function(e) { var t, n = [],
                r = 0,
                i = 0; if (P = !1, e.sort($), P) { for (; t = e[r++];) t === e[r] && (i = n.push(r)); for (; i--;) e.splice(n[i], 1) } return e }, text: function(e) { var t, n = "",
                r = 0,
                i = e.nodeType; if (i) { if (1 === i || 9 === i || 11 === i) return e.textContent; if (3 === i || 4 === i) return e.nodeValue } else
                for (; t = e[r++];) n += L.text(t); return n }, contains: function(e, t) { var n = 9 === e.nodeType ? e.documentElement : e,
                r = t && t.parentNode; return e === r || !(!r || 1 !== r.nodeType || !n.contains(r)) }, isXMLDoc: function(e) { return "HTML" !== (e.ownerDocument || e).documentElement.nodeName }, expr: { attrHandle: {}, match: { bool: /^(?:checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped)$/i, needsContext: /^[\x20\t\r\n\f]*[>+~]/ } } }), L.extend(L.find, { matches: function(e, t) { return L.find(e, null, null, t) }, matchesSelector: function(e, t) { return W.call(e, t) }, attr: function(e, t) { return e.getAttribute(t) } }); var _ = L.expr.match.needsContext,
        I = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
        B = /^.[^:#\[\.,]*$/;
    L.filter = function(e, t, n) { var r = t[0]; return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? L.find.matchesSelector(r, e) ? [r] : [] : L.find.matches(e, L.grep(t, function(e) { return 1 === e.nodeType })) }, L.fn.extend({ find: function(e) { var t, n = this.length,
                r = [],
                i = this; if ("string" != typeof e) return this.pushStack(L(e).filter(function() { for (t = 0; t < n; t++)
                    if (L.contains(i[t], this)) return !0 })); for (t = 0; t < n; t++) L.find(e, i[t], r); return r = this.pushStack(n > 1 ? L.unique(r) : r), r.selector = this.selector ? this.selector + " " + e : e, r }, filter: function(e) { return this.pushStack(r(this, e || [], !1)) }, not: function(e) { return this.pushStack(r(this, e || [], !0)) }, is: function(e) { return !!r(this, "string" == typeof e && _.test(e) ? L(e) : e || [], !1).length } }); var X, U = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/;
    (L.fn.init = function(e, t) { var n, r; if (!e) return this; if ("string" == typeof e) { if (!(n = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : U.exec(e)) || !n[1] && t) return !t || t.jquery ? (t || X).find(e) : this.constructor(t).find(e); if (n[1]) { if (t = t instanceof L ? t[0] : t, L.merge(this, L.parseHTML(n[1], t && t.nodeType ? t.ownerDocument || t : E, !0)), I.test(n[1]) && L.isPlainObject(t))
                    for (n in t) L.isFunction(this[n]) ? this[n](t[n]) : this.attr(n, t[n]); return this } return (r = E.getElementById(n[2])) && r.parentNode && (this.length = 1, this[0] = r), this.context = E, this.selector = e, this } return e.nodeType ? (this.context = this[0] = e, this.length = 1, this) : L.isFunction(e) ? void 0 !== X.ready ? X.ready(e) : e(L) : (void 0 !== e.selector && (this.selector = e.selector, this.context = e.context), L.makeArray(e, this)) }).prototype = L.fn, X = L(E); var R = /^(?:parents|prev(?:Until|All))/,
        V = { children: !0, contents: !0, next: !0, prev: !0 };
    L.extend({ dir: function(e, t, n) { for (var r = [], i = void 0 !== n;
                (e = e[t]) && 9 !== e.nodeType;)
                if (1 === e.nodeType) { if (i && L(e).is(n)) break;
                    r.push(e) } return r }, sibling: function(e, t) { for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e); return n } }), L.fn.extend({ has: function(e) { var t = L(e, this),
                n = t.length; return this.filter(function() { for (var e = 0; e < n; e++)
                    if (L.contains(this, t[e])) return !0 }) }, closest: function(e, t) { for (var n, r = 0, i = this.length, o = [], a = _.test(e) || "string" != typeof e ? L(e, t || this.context) : 0; r < i; r++)
                for (n = this[r]; n && n !== t; n = n.parentNode)
                    if (n.nodeType < 11 && (a ? a.index(n) > -1 : 1 === n.nodeType && L.find.matchesSelector(n, e))) { o.push(n); break } return this.pushStack(o.length > 1 ? L.unique(o) : o) }, index: function(e) { return e ? "string" == typeof e ? w.call(L(e), this[0]) : w.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 }, add: function(e, t) { return this.pushStack(L.unique(L.merge(this.get(), L(e, t)))) }, addBack: function(e) { return this.add(null == e ? this.prevObject : this.prevObject.filter(e)) } }), L.each({ parent: function(e) { var t = e.parentNode; return t && 11 !== t.nodeType ? t : null }, parents: function(e) { return L.dir(e, "parentNode") }, parentsUntil: function(e, t, n) { return L.dir(e, "parentNode", n) }, next: function(e) { return i(e, "nextSibling") }, prev: function(e) { return i(e, "previousSibling") }, nextAll: function(e) { return L.dir(e, "nextSibling") }, prevAll: function(e) { return L.dir(e, "previousSibling") }, nextUntil: function(e, t, n) { return L.dir(e, "nextSibling", n) }, prevUntil: function(e, t, n) { return L.dir(e, "previousSibling", n) }, siblings: function(e) { return L.sibling((e.parentNode || {}).firstChild, e) }, children: function(e) { return L.sibling(e.firstChild) }, contents: function(e) { return e.contentDocument || L.merge([], e.childNodes) } }, function(e, t) { L.fn[e] = function(n, r) { var i = L.map(this, t, n); return "Until" !== e.slice(-5) && (r = n), r && "string" == typeof r && (i = L.filter(r, i)), this.length > 1 && (V[e] || L.unique(i), R.test(e) && i.reverse()), this.pushStack(i) } }); var Q = /\S+/g,
        z = {};
    L.Callbacks = function(e) { var t, n, r, i, a, s, u = [],
            c = !(e = "string" == typeof e ? z[e] || o(e) : L.extend({}, e)).once && [],
            l = function(o) { for (t = e.memory && o, n = !0, s = i || 0, i = 0, a = u.length, r = !0; u && s < a; s++)
                    if (!1 === u[s].apply(o[0], o[1]) && e.stopOnFalse) { t = !1; break } r = !1, u && (c ? c.length && l(c.shift()) : t ? u = [] : f.disable()) },
            f = { add: function() { if (u) { var n = u.length;! function t(n) { L.each(n, function(n, r) { var i = L.type(r); "function" === i ? e.unique && f.has(r) || u.push(r) : r && r.length && "string" !== i && t(r) }) }(arguments), r ? a = u.length : t && (i = n, l(t)) } return this }, remove: function() { return u && L.each(arguments, function(e, t) { for (var n;
                            (n = L.inArray(t, u, n)) > -1;) u.splice(n, 1), r && (n <= a && a--, n <= s && s--) }), this }, has: function(e) { return e ? L.inArray(e, u) > -1 : !(!u || !u.length) }, empty: function() { return u = [], a = 0, this }, disable: function() { return u = c = t = void 0, this }, disabled: function() { return !u }, lock: function() { return c = void 0, t || f.disable(), this }, locked: function() { return !c }, fireWith: function(e, t) { return !u || n && !c || (t = [e, (t = t || []).slice ? t.slice() : t], r ? c.push(t) : l(t)), this }, fire: function() { return f.fireWith(this, arguments), this }, fired: function() { return !!n } }; return f }, L.extend({ Deferred: function(e) { var t = [
                    ["resolve", "done", L.Callbacks("once memory"), "resolved"],
                    ["reject", "fail", L.Callbacks("once memory"), "rejected"],
                    ["notify", "progress", L.Callbacks("memory")]
                ],
                n = "pending",
                r = { state: function() { return n }, always: function() { return i.done(arguments).fail(arguments), this }, then: function() { var e = arguments; return L.Deferred(function(n) { L.each(t, function(t, o) { var a = L.isFunction(e[t]) && e[t];
                                i[o[1]](function() { var e = a && a.apply(this, arguments);
                                    e && L.isFunction(e.promise) ? e.promise().done(n.resolve).fail(n.reject).progress(n.notify) : n[o[0] + "With"](this === r ? n.promise() : this, a ? [e] : arguments) }) }), e = null }).promise() }, promise: function(e) { return null != e ? L.extend(e, r) : r } },
                i = {}; return r.pipe = r.then, L.each(t, function(e, o) { var a = o[2],
                    s = o[3];
                r[o[1]] = a.add, s && a.add(function() { n = s }, t[1 ^ e][2].disable, t[2][2].lock), i[o[0]] = function() { return i[o[0] + "With"](this === i ? r : this, arguments), this }, i[o[0] + "With"] = a.fireWith }), r.promise(i), e && e.call(i, i), i }, when: function(e) { var t, n, r, i = 0,
                o = k.call(arguments),
                a = o.length,
                s = 1 !== a || e && L.isFunction(e.promise) ? a : 0,
                u = 1 === s ? e : L.Deferred(),
                c = function(e, n, r) { return function(i) { n[e] = this, r[e] = arguments.length > 1 ? k.call(arguments) : i, r === t ? u.notifyWith(n, r) : --s || u.resolveWith(n, r) } }; if (a > 1)
                for (t = new Array(a), n = new Array(a), r = new Array(a); i < a; i++) o[i] && L.isFunction(o[i].promise) ? o[i].promise().done(c(i, r, o)).fail(u.reject).progress(c(i, n, t)) : --s; return s || u.resolveWith(r, o), u.promise() } }); var Y;
    L.fn.ready = function(e) { return L.ready.promise().done(e), this }, L.extend({ isReady: !1, readyWait: 1, holdReady: function(e) { e ? L.readyWait++ : L.ready(!0) }, ready: function(e) {
            (!0 === e ? --L.readyWait : L.isReady) || (L.isReady = !0, !0 !== e && --L.readyWait > 0 || (Y.resolveWith(E, [L]), L.fn.triggerHandler && (L(E).triggerHandler("ready"), L(E).off("ready")))) } }), L.ready.promise = function(t) { return Y || (Y = L.Deferred(), "complete" === E.readyState ? setTimeout(L.ready) : (E.addEventListener("DOMContentLoaded", a, !1), e.addEventListener("load", a, !1))), Y.promise(t) }, L.ready.promise(); var K = L.access = function(e, t, n, r, i, o, a) { var s = 0,
            u = e.length,
            c = null == n; if ("object" === L.type(n)) { i = !0; for (s in n) L.access(e, t, s, n[s], !0, o, a) } else if (void 0 !== r && (i = !0, L.isFunction(r) || (a = !0), c && (a ? (t.call(e, r), t = null) : (c = t, t = function(e, t, n) { return c.call(L(e), n) })), t))
            for (; s < u; s++) t(e[s], n, a ? r : r.call(e[s], s, t(e[s], n))); return i ? e : c ? t.call(e) : u ? t(e[0], n) : o };
    L.acceptData = function(e) { return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType }, s.uid = 1, s.accepts = L.acceptData, s.prototype = { key: function(e) { if (!s.accepts(e)) return 0; var t = {},
                n = e[this.expando]; if (!n) { n = s.uid++; try { t[this.expando] = { value: n }, Object.defineProperties(e, t) } catch (r) { t[this.expando] = n, L.extend(e, t) } } return this.cache[n] || (this.cache[n] = {}), n }, set: function(e, t, n) { var r, i = this.key(e),
                o = this.cache[i]; if ("string" == typeof t) o[t] = n;
            else if (L.isEmptyObject(o)) L.extend(this.cache[i], t);
            else
                for (r in t) o[r] = t[r]; return o }, get: function(e, t) { var n = this.cache[this.key(e)]; return void 0 === t ? n : n[t] }, access: function(e, t, n) { var r; return void 0 === t || t && "string" == typeof t && void 0 === n ? (r = this.get(e, t), void 0 !== r ? r : this.get(e, L.camelCase(t))) : (this.set(e, t, n), void 0 !== n ? n : t) }, remove: function(e, t) { var n, r, i, o = this.key(e),
                a = this.cache[o]; if (void 0 === t) this.cache[o] = {};
            else { L.isArray(t) ? r = t.concat(t.map(L.camelCase)) : (i = L.camelCase(t), r = t in a ? [t, i] : (r = i) in a ? [r] : r.match(Q) || []), n = r.length; for (; n--;) delete a[r[n]] } }, hasData: function(e) { return !L.isEmptyObject(this.cache[e[this.expando]] || {}) }, discard: function(e) { e[this.expando] && delete this.cache[e[this.expando]] } }; var J = new s,
        G = new s,
        Z = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        ee = /([A-Z])/g;
    L.extend({ hasData: function(e) { return G.hasData(e) || J.hasData(e) }, data: function(e, t, n) { return G.access(e, t, n) }, removeData: function(e, t) { G.remove(e, t) }, _data: function(e, t, n) { return J.access(e, t, n) }, _removeData: function(e, t) { J.remove(e, t) } }), L.fn.extend({ data: function(e, t) { var n, r, i, o = this[0],
                a = o && o.attributes; if (void 0 === e) { if (this.length && (i = G.get(o), 1 === o.nodeType && !J.get(o, "hasDataAttrs"))) { for (n = a.length; n--;) a[n] && 0 === (r = a[n].name).indexOf("data-") && (r = L.camelCase(r.slice(5)), u(o, r, i[r]));
                    J.set(o, "hasDataAttrs", !0) } return i } return "object" == typeof e ? this.each(function() { G.set(this, e) }) : K(this, function(t) { var n, r = L.camelCase(e); if (o && void 0 === t) { if (void 0 !== (n = G.get(o, e))) return n; if (void 0 !== (n = G.get(o, r))) return n; if (void 0 !== (n = u(o, r, void 0))) return n } else this.each(function() { var n = G.get(this, r);
                    G.set(this, r, t), -1 !== e.indexOf("-") && void 0 !== n && G.set(this, e, t) }) }, null, t, arguments.length > 1, null, !0) }, removeData: function(e) { return this.each(function() { G.remove(this, e) }) } }), L.extend({ queue: function(e, t, n) { var r; if (e) return t = (t || "fx") + "queue", r = J.get(e, t), n && (!r || L.isArray(n) ? r = J.access(e, t, L.makeArray(n)) : r.push(n)), r || [] }, dequeue: function(e, t) { t = t || "fx"; var n = L.queue(e, t),
                r = n.length,
                i = n.shift(),
                o = L._queueHooks(e, t),
                a = function() { L.dequeue(e, t) }; "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, a, o)), !r && o && o.empty.fire() }, _queueHooks: function(e, t) { var n = t + "queueHooks"; return J.get(e, n) || J.access(e, n, { empty: L.Callbacks("once memory").add(function() { J.remove(e, [t + "queue", n]) }) }) } }), L.fn.extend({ queue: function(e, t) { var n = 2; return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? L.queue(this[0], e) : void 0 === t ? this : this.each(function() { var n = L.queue(this, e, t);
                L._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && L.dequeue(this, e) }) }, dequeue: function(e) { return this.each(function() { L.dequeue(this, e) }) }, clearQueue: function(e) { return this.queue(e || "fx", []) }, promise: function(e, t) { var n, r = 1,
                i = L.Deferred(),
                o = this,
                a = this.length,
                s = function() {--r || i.resolveWith(o, [o]) }; for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; a--;)(n = J.get(o[a], e + "queueHooks")) && n.empty && (r++, n.empty.add(s)); return s(), i.promise(t) } }); var te = /^(?:checkbox|radio)$/i;! function() { var e = E.createDocumentFragment().appendChild(E.createElement("div")),
            t = E.createElement("input");
        t.setAttribute("type", "radio"), t.setAttribute("checked", "checked"), t.setAttribute("name", "t"), e.appendChild(t), A.checkClone = e.cloneNode(!0).cloneNode(!0).lastChild.checked, e.innerHTML = "<textarea>x</textarea>", A.noCloneChecked = !!e.cloneNode(!0).lastChild.defaultValue }();
    A.focusinBubbles = "onfocusin" in e; var ne = /^key/,
        re = /^(?:mouse|pointer|contextmenu)|click/,
        ie = /^(?:focusinfocus|focusoutblur)$/,
        oe = /^([^.]*)(?:\.(.+)|)$/;
    L.event = { global: {}, add: function(e, t, n, r, i) { var o, a, s, u, c, l, f, d, p, h, v, g = J.get(e); if (g)
                for (n.handler && (n = (o = n).handler, i = o.selector), n.guid || (n.guid = L.guid++), (u = g.events) || (u = g.events = {}), (a = g.handle) || (a = g.handle = function(t) { return void 0 !== L && L.event.triggered !== t.type ? L.event.dispatch.apply(e, arguments) : void 0 }), c = (t = (t || "").match(Q) || [""]).length; c--;) p = v = (s = oe.exec(t[c]) || [])[1], h = (s[2] || "").split(".").sort(), p && (f = L.event.special[p] || {}, p = (i ? f.delegateType : f.bindType) || p, f = L.event.special[p] || {}, l = L.extend({ type: p, origType: v, data: r, handler: n, guid: n.guid, selector: i, needsContext: i && L.expr.match.needsContext.test(i), namespace: h.join(".") }, o), (d = u[p]) || ((d = u[p] = []).delegateCount = 0, f.setup && !1 !== f.setup.call(e, r, h, a) || e.addEventListener && e.addEventListener(p, a, !1)), f.add && (f.add.call(e, l), l.handler.guid || (l.handler.guid = n.guid)), i ? d.splice(d.delegateCount++, 0, l) : d.push(l), L.event.global[p] = !0) }, remove: function(e, t, n, r, i) { var o, a, s, u, c, l, f, d, p, h, v, g = J.hasData(e) && J.get(e); if (g && (u = g.events)) { for (c = (t = (t || "").match(Q) || [""]).length; c--;)
                    if (s = oe.exec(t[c]) || [], p = v = s[1], h = (s[2] || "").split(".").sort(), p) { for (f = L.event.special[p] || {}, d = u[p = (r ? f.delegateType : f.bindType) || p] || [], s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = d.length; o--;) l = d[o], !i && v !== l.origType || n && n.guid !== l.guid || s && !s.test(l.namespace) || r && r !== l.selector && ("**" !== r || !l.selector) || (d.splice(o, 1), l.selector && d.delegateCount--, f.remove && f.remove.call(e, l));
                        a && !d.length && (f.teardown && !1 !== f.teardown.call(e, h, g.handle) || L.removeEvent(e, p, g.handle), delete u[p]) } else
                        for (p in u) L.event.remove(e, p + t[c], n, r, !0);
                L.isEmptyObject(u) && (delete g.handle, J.remove(e, "events")) } }, trigger: function(t, n, r, i) { var o, a, s, u, c, l, f, d = [r || E],
                p = j.call(t, "type") ? t.type : t,
                h = j.call(t, "namespace") ? t.namespace.split(".") : []; if (a = s = r = r || E, 3 !== r.nodeType && 8 !== r.nodeType && !ie.test(p + L.event.triggered) && (p.indexOf(".") >= 0 && (p = (h = p.split(".")).shift(), h.sort()), c = p.indexOf(":") < 0 && "on" + p, t = t[L.expando] ? t : new L.Event(p, "object" == typeof t && t), t.isTrigger = i ? 2 : 3, t.namespace = h.join("."), t.namespace_re = t.namespace ? new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = r), n = null == n ? [t] : L.makeArray(n, [t]), f = L.event.special[p] || {}, i || !f.trigger || !1 !== f.trigger.apply(r, n))) { if (!i && !f.noBubble && !L.isWindow(r)) { for (u = f.delegateType || p, ie.test(u + p) || (a = a.parentNode); a; a = a.parentNode) d.push(a), s = a;
                    s === (r.ownerDocument || E) && d.push(s.defaultView || s.parentWindow || e) } for (o = 0;
                    (a = d[o++]) && !t.isPropagationStopped();) t.type = o > 1 ? u : f.bindType || p, (l = (J.get(a, "events") || {})[t.type] && J.get(a, "handle")) && l.apply(a, n), (l = c && a[c]) && l.apply && L.acceptData(a) && (t.result = l.apply(a, n), !1 === t.result && t.preventDefault()); return t.type = p, i || t.isDefaultPrevented() || f._default && !1 !== f._default.apply(d.pop(), n) || !L.acceptData(r) || c && L.isFunction(r[p]) && !L.isWindow(r) && ((s = r[c]) && (r[c] = null), L.event.triggered = p, r[p](), L.event.triggered = void 0, s && (r[c] = s)), t.result } }, dispatch: function(e) { e = L.event.fix(e); var t, n, r, i, o, a = [],
                s = k.call(arguments),
                u = (J.get(this, "events") || {})[e.type] || [],
                c = L.event.special[e.type] || {}; if (s[0] = e, e.delegateTarget = this, !c.preDispatch || !1 !== c.preDispatch.call(this, e)) { for (a = L.event.handlers.call(this, e, u), t = 0;
                    (i = a[t++]) && !e.isPropagationStopped();)
                    for (e.currentTarget = i.elem, n = 0;
                        (o = i.handlers[n++]) && !e.isImmediatePropagationStopped();) e.namespace_re && !e.namespace_re.test(o.namespace) || (e.handleObj = o, e.data = o.data, void 0 !== (r = ((L.event.special[o.origType] || {}).handle || o.handler).apply(i.elem, s)) && !1 === (e.result = r) && (e.preventDefault(), e.stopPropagation())); return c.postDispatch && c.postDispatch.call(this, e), e.result } }, handlers: function(e, t) { var n, r, i, o, a = [],
                s = t.delegateCount,
                u = e.target; if (s && u.nodeType && (!e.button || "click" !== e.type))
                for (; u !== this; u = u.parentNode || this)
                    if (!0 !== u.disabled || "click" !== e.type) { for (r = [], n = 0; n < s; n++) void 0 === r[i = (o = t[n]).selector + " "] && (r[i] = o.needsContext ? L(i, this).index(u) >= 0 : L.find(i, this, null, [u]).length), r[i] && r.push(o);
                        r.length && a.push({ elem: u, handlers: r }) } return s < t.length && a.push({ elem: this, handlers: t.slice(s) }), a }, props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "), fixHooks: {}, keyHooks: { props: "char charCode key keyCode".split(" "), filter: function(e, t) { return null == e.which && (e.which = null != t.charCode ? t.charCode : t.keyCode), e } }, mouseHooks: { props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "), filter: function(e, t) { var n, r, i, o = t.button; return null == e.pageX && null != t.clientX && (r = (n = e.target.ownerDocument || E).documentElement, i = n.body, e.pageX = t.clientX + (r && r.scrollLeft || i && i.scrollLeft || 0) - (r && r.clientLeft || i && i.clientLeft || 0), e.pageY = t.clientY + (r && r.scrollTop || i && i.scrollTop || 0) - (r && r.clientTop || i && i.clientTop || 0)), e.which || void 0 === o || (e.which = 1 & o ? 1 : 2 & o ? 3 : 4 & o ? 2 : 0), e } }, fix: function(e) { if (e[L.expando]) return e; var t, n, r, i = e.type,
                o = e,
                a = this.fixHooks[i]; for (a || (this.fixHooks[i] = a = re.test(i) ? this.mouseHooks : ne.test(i) ? this.keyHooks : {}), r = a.props ? this.props.concat(a.props) : this.props, e = new L.Event(o), t = r.length; t--;) e[n = r[t]] = o[n]; return e.target || (e.target = E), 3 === e.target.nodeType && (e.target = e.target.parentNode), a.filter ? a.filter(e, o) : e }, special: { load: { noBubble: !0 }, focus: { trigger: function() { if (this !== f() && this.focus) return this.focus(), !1 }, delegateType: "focusin" }, blur: { trigger: function() { if (this === f() && this.blur) return this.blur(), !1 }, delegateType: "focusout" }, click: { trigger: function() { if ("checkbox" === this.type && this.click && L.nodeName(this, "input")) return this.click(), !1 }, _default: function(e) { return L.nodeName(e.target, "a") } }, beforeunload: { postDispatch: function(e) { void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result) } } }, simulate: function(e, t, n, r) { var i = L.extend(new L.Event, n, { type: e, isSimulated: !0, originalEvent: {} });
            r ? L.event.trigger(i, null, t) : L.event.dispatch.call(t, i), i.isDefaultPrevented() && n.preventDefault() } }, L.removeEvent = function(e, t, n) { e.removeEventListener && e.removeEventListener(t, n, !1) }, L.Event = function(e, t) { if (!(this instanceof L.Event)) return new L.Event(e, t);
        e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? c : l) : this.type = e, t && L.extend(this, t), this.timeStamp = e && e.timeStamp || L.now(), this[L.expando] = !0 }, L.Event.prototype = { isDefaultPrevented: l, isPropagationStopped: l, isImmediatePropagationStopped: l, preventDefault: function() { var e = this.originalEvent;
            this.isDefaultPrevented = c, e && e.preventDefault && e.preventDefault() }, stopPropagation: function() { var e = this.originalEvent;
            this.isPropagationStopped = c, e && e.stopPropagation && e.stopPropagation() }, stopImmediatePropagation: function() { var e = this.originalEvent;
            this.isImmediatePropagationStopped = c, e && e.stopImmediatePropagation && e.stopImmediatePropagation(), this.stopPropagation() } }, L.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function(e, t) { L.event.special[e] = { delegateType: t, bindType: t, handle: function(e) { var n, r = this,
                    i = e.relatedTarget,
                    o = e.handleObj; return i && (i === r || L.contains(r, i)) || (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n } } }), A.focusinBubbles || L.each({ focus: "focusin", blur: "focusout" }, function(e, t) { var n = function(e) { L.event.simulate(t, e.target, L.event.fix(e), !0) };
        L.event.special[t] = { setup: function() { var r = this.ownerDocument || this,
                    i = J.access(r, t);
                i || r.addEventListener(e, n, !0), J.access(r, t, (i || 0) + 1) }, teardown: function() { var r = this.ownerDocument || this,
                    i = J.access(r, t) - 1;
                i ? J.access(r, t, i) : (r.removeEventListener(e, n, !0), J.remove(r, t)) } } }), L.fn.extend({ on: function(e, t, n, r, i) { var o, a; if ("object" == typeof e) { "string" != typeof t && (n = n || t, t = void 0); for (a in e) this.on(a, t, n, e[a], i); return this } if (null == n && null == r ? (r = t, n = t = void 0) : null == r && ("string" == typeof t ? (r = n, n = void 0) : (r = n, n = t, t = void 0)), !1 === r) r = l;
            else if (!r) return this; return 1 === i && (o = r, (r = function(e) { return L().off(e), o.apply(this, arguments) }).guid = o.guid || (o.guid = L.guid++)), this.each(function() { L.event.add(this, e, r, n, t) }) }, one: function(e, t, n, r) { return this.on(e, t, n, r, 1) }, off: function(e, t, n) { var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, L(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this; if ("object" == typeof e) { for (i in e) this.off(i, t, e[i]); return this } return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = l), this.each(function() { L.event.remove(this, e, n, t) }) }, trigger: function(e, t) { return this.each(function() { L.event.trigger(e, t, this) }) }, triggerHandler: function(e, t) { var n = this[0]; if (n) return L.event.trigger(e, t, n, !0) } }); var ae = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
        se = /<([\w:]+)/,
        ue = /<|&#?\w+;/,
        ce = /<(?:script|style|link)/i,
        le = /checked\s*(?:[^=]|=\s*.checked.)/i,
        fe = /^$|\/(?:java|ecma)script/i,
        de = /^true\/(.*)/,
        pe = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
        he = { option: [1, "<select multiple='multiple'>", "</select>"], thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] };
    he.optgroup = he.option, he.tbody = he.tfoot = he.colgroup = he.caption = he.thead, he.th = he.td, L.extend({ clone: function(e, t, n) { var r, i, o, a, s = e.cloneNode(!0),
                    u = L.contains(e.ownerDocument, e); if (!(A.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || L.isXMLDoc(e)))
                    for (a = m(s), r = 0, i = (o = m(e)).length; r < i; r++) y(o[r], a[r]); if (t)
                    if (n)
                        for (o = o || m(e), a = a || m(s), r = 0, i = o.length; r < i; r++) g(o[r], a[r]);
                    else g(e, s); return (a = m(s, "script")).length > 0 && v(a, !u && m(e, "script")), s }, buildFragment: function(e, t, n, r) { for (var i, o, a, s, u, c, l = t.createDocumentFragment(), f = [], d = 0, p = e.length; d < p; d++)
                    if ((i = e[d]) || 0 === i)
                        if ("object" === L.type(i)) L.merge(f, i.nodeType ? [i] : i);
                        else if (ue.test(i)) { for (o = o || l.appendChild(t.createElement("div")), a = (se.exec(i) || ["", ""])[1].toLowerCase(), s = he[a] || he._default, o.innerHTML = s[1] + i.replace(ae, "<$1></$2>") + s[2], c = s[0]; c--;) o = o.lastChild;
                    L.merge(f, o.childNodes), (o = l.firstChild).textContent = "" } else f.push(t.createTextNode(i)); for (l.textContent = "", d = 0; i = f[d++];)
                    if ((!r || -1 === L.inArray(i, r)) && (u = L.contains(i.ownerDocument, i), o = m(l.appendChild(i), "script"), u && v(o), n))
                        for (c = 0; i = o[c++];) fe.test(i.type || "") && n.push(i); return l }, cleanData: function(e) { for (var t, n, r, i, o = L.event.special, a = 0; void 0 !== (n = e[a]); a++) { if (L.acceptData(n) && (i = n[J.expando]) && (t = J.cache[i])) { if (t.events)
                            for (r in t.events) o[r] ? L.event.remove(n, r) : L.removeEvent(n, r, t.handle);
                        J.cache[i] && delete J.cache[i] } delete G.cache[n[G.expando]] } } }), L.fn.extend({ text: function(e) { return K(this, function(e) { return void 0 === e ? L.text(this) : this.empty().each(function() { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e) }) }, null, e, arguments.length) }, append: function() { return this.domManip(arguments, function(e) { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || d(this, e).appendChild(e) }) }, prepend: function() { return this.domManip(arguments, function(e) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var t = d(this, e);
                        t.insertBefore(e, t.firstChild) } }) }, before: function() { return this.domManip(arguments, function(e) { this.parentNode && this.parentNode.insertBefore(e, this) }) }, after: function() { return this.domManip(arguments, function(e) { this.parentNode && this.parentNode.insertBefore(e, this.nextSibling) }) }, remove: function(e, t) { for (var n, r = e ? L.filter(e, this) : this, i = 0; null != (n = r[i]); i++) t || 1 !== n.nodeType || L.cleanData(m(n)), n.parentNode && (t && L.contains(n.ownerDocument, n) && v(m(n, "script")), n.parentNode.removeChild(n)); return this }, empty: function() { for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (L.cleanData(m(e, !1)), e.textContent = ""); return this }, clone: function(e, t) { return e = null != e && e, t = null == t ? e : t, this.map(function() { return L.clone(this, e, t) }) }, html: function(e) { return K(this, function(e) { var t = this[0] || {},
                        n = 0,
                        r = this.length; if (void 0 === e && 1 === t.nodeType) return t.innerHTML; if ("string" == typeof e && !ce.test(e) && !he[(se.exec(e) || ["", ""])[1].toLowerCase()]) { e = e.replace(ae, "<$1></$2>"); try { for (; n < r; n++) 1 === (t = this[n] || {}).nodeType && (L.cleanData(m(t, !1)), t.innerHTML = e);
                            t = 0 } catch (e) {} } t && this.empty().append(e) }, null, e, arguments.length) }, replaceWith: function() { var e = arguments[0]; return this.domManip(arguments, function(t) { e = this.parentNode, L.cleanData(m(this)), e && e.replaceChild(t, this) }), e && (e.length || e.nodeType) ? this : this.remove() }, detach: function(e) { return this.remove(e, !0) }, domManip: function(e, t) { e = T.apply([], e); var n, r, i, o, a, s, u = 0,
                    c = this.length,
                    l = this,
                    f = c - 1,
                    d = e[0],
                    v = L.isFunction(d); if (v || c > 1 && "string" == typeof d && !A.checkClone && le.test(d)) return this.each(function(n) { var r = l.eq(n);
                    v && (e[0] = d.call(this, n, r.html())), r.domManip(e, t) }); if (c && (n = L.buildFragment(e, this[0].ownerDocument, !1, this), r = n.firstChild, 1 === n.childNodes.length && (n = r), r)) { for (o = (i = L.map(m(n, "script"), p)).length; u < c; u++) a = n, u !== f && (a = L.clone(a, !0, !0), o && L.merge(i, m(a, "script"))), t.call(this[u], a, u); if (o)
                        for (s = i[i.length - 1].ownerDocument, L.map(i, h), u = 0; u < o; u++) a = i[u], fe.test(a.type || "") && !J.access(a, "globalEval") && L.contains(s, a) && (a.src ? L._evalUrl && L._evalUrl(a.src) : L.globalEval(a.textContent.replace(pe, ""))) } return this } }), L.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function(e, t) { L.fn[e] = function(e) { for (var n, r = [], i = L(e), o = i.length - 1, a = 0; a <= o; a++) n = a === o ? this : this.clone(!0), L(i[a])[t](n), C.apply(r, n.get()); return this.pushStack(r) } }), L.fn.delay = function(e, t) { return e = L.fx ? L.fx.speeds[e] || e : e, t = t || "fx", this.queue(t, function(t, n) { var r = setTimeout(t, e);
                n.stop = function() { clearTimeout(r) } }) },
        function() { var e = E.createElement("input"),
                t = E.createElement("select"),
                n = t.appendChild(E.createElement("option"));
            e.type = "checkbox", A.checkOn = "" !== e.value, A.optSelected = n.selected, t.disabled = !0, A.optDisabled = !n.disabled, (e = E.createElement("input")).value = "t", e.type = "radio", A.radioValue = "t" === e.value }(); var ve, ge = L.expr.attrHandle;
    L.fn.extend({ attr: function(e, t) { return K(this, L.attr, e, t, arguments.length > 1) }, removeAttr: function(e) { return this.each(function() { L.removeAttr(this, e) }) } }), L.extend({ attr: function(e, t, n) { var r, i, o = e.nodeType; if (e && 3 !== o && 8 !== o && 2 !== o) return void 0 === e.getAttribute ? L.prop(e, t, n) : (1 === o && L.isXMLDoc(e) || (t = t.toLowerCase(), r = L.attrHooks[t] || (L.expr.match.bool.test(t) ? ve : void 0)), void 0 === n ? r && "get" in r && null !== (i = r.get(e, t)) ? i : (i = L.find.attr(e, t), null == i ? void 0 : i) : null !== n ? r && "set" in r && void 0 !== (i = r.set(e, n, t)) ? i : (e.setAttribute(t, n + ""), n) : void L.removeAttr(e, t)) }, removeAttr: function(e, t) { var n, r, i = 0,
                o = t && t.match(Q); if (o && 1 === e.nodeType)
                for (; n = o[i++];) r = L.propFix[n] || n, L.expr.match.bool.test(n) && (e[r] = !1), e.removeAttribute(n) }, attrHooks: { type: { set: function(e, t) { if (!A.radioValue && "radio" === t && L.nodeName(e, "input")) { var n = e.value; return e.setAttribute("type", t), n && (e.value = n), t } } } } }), ve = { set: function(e, t, n) { return !1 === t ? L.removeAttr(e, n) : e.setAttribute(n, n), n } }, L.each(L.expr.match.bool.source.match(/\w+/g), function(e, t) { var n = ge[t] || L.find.attr;
        ge[t] = function(e, t, r) { var i, o; return r || (o = ge[t], ge[t] = i, i = null != n(e, t, r) ? t.toLowerCase() : null, ge[t] = o), i } }); var me = /^(?:input|select|textarea|button)$/i;
    L.fn.extend({ prop: function(e, t) { return K(this, L.prop, e, t, arguments.length > 1) }, removeProp: function(e) { return this.each(function() { delete this[L.propFix[e] || e] }) } }), L.extend({ propFix: { for: "htmlFor", class: "className" }, prop: function(e, t, n) { var r, i, o = e.nodeType; if (e && 3 !== o && 8 !== o && 2 !== o) return (1 !== o || !L.isXMLDoc(e)) && (t = L.propFix[t] || t, i = L.propHooks[t]), void 0 !== n ? i && "set" in i && void 0 !== (r = i.set(e, n, t)) ? r : e[t] = n : i && "get" in i && null !== (r = i.get(e, t)) ? r : e[t] }, propHooks: { tabIndex: { get: function(e) { return e.hasAttribute("tabindex") || me.test(e.nodeName) || e.href ? e.tabIndex : -1 } } } }), A.optSelected || (L.propHooks.selected = { get: function(e) { var t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null } }), L.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() { L.propFix[this.toLowerCase()] = this }); var ye = /[\t\r\n\f]/g;
    L.fn.extend({ addClass: function(e) { var t, n, r, i, o, a, s = "string" == typeof e && e,
                u = 0,
                c = this.length; if (L.isFunction(e)) return this.each(function(t) { L(this).addClass(e.call(this, t, this.className)) }); if (s)
                for (t = (e || "").match(Q) || []; u < c; u++)
                    if (n = this[u], r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(ye, " ") : " ")) { for (o = 0; i = t[o++];) r.indexOf(" " + i + " ") < 0 && (r += i + " ");
                        a = L.trim(r), n.className !== a && (n.className = a) } return this }, removeClass: function(e) { var t, n, r, i, o, a, s = 0 === arguments.length || "string" == typeof e && e,
                u = 0,
                c = this.length; if (L.isFunction(e)) return this.each(function(t) { L(this).removeClass(e.call(this, t, this.className)) }); if (s)
                for (t = (e || "").match(Q) || []; u < c; u++)
                    if (n = this[u], r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(ye, " ") : "")) { for (o = 0; i = t[o++];)
                            for (; r.indexOf(" " + i + " ") >= 0;) r = r.replace(" " + i + " ", " ");
                        a = e ? L.trim(r) : "", n.className !== a && (n.className = a) } return this }, toggleClass: function(e, t) { var n = typeof e; return "boolean" == typeof t && "string" === n ? t ? this.addClass(e) : this.removeClass(e) : L.isFunction(e) ? this.each(function(n) { L(this).toggleClass(e.call(this, n, this.className, t), t) }) : this.each(function() { if ("string" === n)
                    for (var t, r = 0, i = L(this), o = e.match(Q) || []; t = o[r++];) i.hasClass(t) ? i.removeClass(t) : i.addClass(t);
                else "undefined" !== n && "boolean" !== n || (this.className && J.set(this, "__className__", this.className), this.className = this.className || !1 === e ? "" : J.get(this, "__className__") || "") }) }, hasClass: function(e) { for (var t = " " + e + " ", n = 0, r = this.length; n < r; n++)
                if (1 === this[n].nodeType && (" " + this[n].className + " ").replace(ye, " ").indexOf(t) >= 0) return !0; return !1 } }); var be = /\r/g;
    L.fn.extend({ val: function(e) { var t, n, r, i = this[0]; { if (arguments.length) return r = L.isFunction(e), this.each(function(n) { var i;
                    1 === this.nodeType && (null == (i = r ? e.call(this, n, L(this).val()) : e) ? i = "" : "number" == typeof i ? i += "" : L.isArray(i) && (i = L.map(i, function(e) { return null == e ? "" : e + "" })), (t = L.valHooks[this.type] || L.valHooks[this.nodeName.toLowerCase()]) && "set" in t && void 0 !== t.set(this, i, "value") || (this.value = i)) }); if (i) return (t = L.valHooks[i.type] || L.valHooks[i.nodeName.toLowerCase()]) && "get" in t && void 0 !== (n = t.get(i, "value")) ? n : (n = i.value, "string" == typeof n ? n.replace(be, "") : null == n ? "" : n) } } }), L.extend({ valHooks: { option: { get: function(e) { var t = L.find.attr(e, "value"); return null != t ? t : L.trim(L.text(e)) } }, select: { get: function(e) { for (var t, n, r = e.options, i = e.selectedIndex, o = "select-one" === e.type || i < 0, a = o ? null : [], s = o ? i + 1 : r.length, u = i < 0 ? s : o ? i : 0; u < s; u++)
                        if (((n = r[u]).selected || u === i) && (A.optDisabled ? !n.disabled : null === n.getAttribute("disabled")) && (!n.parentNode.disabled || !L.nodeName(n.parentNode, "optgroup"))) { if (t = L(n).val(), o) return t;
                            a.push(t) } return a }, set: function(e, t) { for (var n, r, i = e.options, o = L.makeArray(t), a = i.length; a--;)((r = i[a]).selected = L.inArray(r.value, o) >= 0) && (n = !0); return n || (e.selectedIndex = -1), o } } } }), L.each(["radio", "checkbox"], function() { L.valHooks[this] = { set: function(e, t) { if (L.isArray(t)) return e.checked = L.inArray(L(e).val(), t) >= 0 } }, A.checkOn || (L.valHooks[this].get = function(e) { return null === e.getAttribute("value") ? "on" : e.value }) }), L.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(e, t) { L.fn[t] = function(e, n) { return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t) } }), L.fn.extend({ hover: function(e, t) { return this.mouseenter(e).mouseleave(t || e) }, bind: function(e, t, n) { return this.on(e, null, t, n) }, unbind: function(e, t) { return this.off(e, null, t) }, delegate: function(e, t, n, r) { return this.on(t, e, n, r) }, undelegate: function(e, t, n) { return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n) } }); var xe = /%20/g,
        ke = /\[\]$/,
        Te = /\r?\n/g,
        Ce = /^(?:submit|button|image|reset|file)$/i,
        we = /^(?:input|select|textarea|keygen)/i;
    L.param = function(e, t) { var n, r = [],
            i = function(e, t) { t = L.isFunction(t) ? t() : null == t ? "" : t, r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(t) }; if (void 0 === t && (t = L.ajaxSettings && L.ajaxSettings.traditional), L.isArray(e) || e.jquery && !L.isPlainObject(e)) L.each(e, function() { i(this.name, this.value) });
        else
            for (n in e) b(n, e[n], t, i); return r.join("&").replace(xe, "+") }, L.fn.extend({ serialize: function() { return L.param(this.serializeArray()) }, serializeArray: function() { return this.map(function() { var e = L.prop(this, "elements"); return e ? L.makeArray(e) : this }).filter(function() { var e = this.type; return this.name && !L(this).is(":disabled") && we.test(this.nodeName) && !Ce.test(e) && (this.checked || !te.test(e)) }).map(function(e, t) { var n = L(this).val(); return null == n ? null : L.isArray(n) ? L.map(n, function(e) { return { name: t.name, value: e.replace(Te, "\r\n") } }) : { name: t.name, value: n.replace(Te, "\r\n") } }).get() } }), L.parseHTML = function(e, t, n) { if (!e || "string" != typeof e) return null; "boolean" == typeof t && (n = t, t = !1), t = t || E; var r = I.exec(e),
            i = !n && []; return r ? [t.createElement(r[1])] : (r = L.buildFragment([e], t, i), i && i.length && L(i).remove(), L.merge([], r.childNodes)) }, "function" == typeof define && define.amd && define("jquery", [], function() { return L }); var De = e.jQuery,
        Ne = e.$; return L.noConflict = function(t) { return e.$ === L && (e.$ = Ne), t && e.jQuery === L && (e.jQuery = De), L }, void 0 === t && (e.jQuery = e.$ = L), L });
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJqcXVlcnktZWZmZWN0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIhIGZ1bmN0aW9uKGUsIHQpIHsgXCJvYmplY3RcIiA9PSB0eXBlb2YgbW9kdWxlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIG1vZHVsZS5leHBvcnRzID8gbW9kdWxlLmV4cG9ydHMgPSBlLmRvY3VtZW50ID8gdChlLCAhMCkgOiBmdW5jdGlvbihlKSB7IGlmICghZS5kb2N1bWVudCkgdGhyb3cgbmV3IEVycm9yKFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiKTsgcmV0dXJuIHQoZSkgfSA6IHQoZSkgfShcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbihlLCB0KSB7XG4gICAgZnVuY3Rpb24gbihlKSB7IHZhciB0ID0gZS5sZW5ndGgsXG4gICAgICAgICAgICBuID0gTC50eXBlKGUpOyByZXR1cm4gXCJmdW5jdGlvblwiICE9PSBuICYmICFMLmlzV2luZG93KGUpICYmICghKDEgIT09IGUubm9kZVR5cGUgfHwgIXQpIHx8IChcImFycmF5XCIgPT09IG4gfHwgMCA9PT0gdCB8fCBcIm51bWJlclwiID09IHR5cGVvZiB0ICYmIHQgPiAwICYmIHQgLSAxIGluIGUpKSB9XG5cbiAgICBmdW5jdGlvbiByKGUsIHQsIG4pIHsgaWYgKEwuaXNGdW5jdGlvbih0KSkgcmV0dXJuIEwuZ3JlcChlLCBmdW5jdGlvbihlLCByKSB7IHJldHVybiAhIXQuY2FsbChlLCByLCBlKSAhPT0gbiB9KTsgaWYgKHQubm9kZVR5cGUpIHJldHVybiBMLmdyZXAoZSwgZnVuY3Rpb24oZSkgeyByZXR1cm4gZSA9PT0gdCAhPT0gbiB9KTsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQpIHsgaWYgKEIudGVzdCh0KSkgcmV0dXJuIEwuZmlsdGVyKHQsIGUsIG4pO1xuICAgICAgICAgICAgdCA9IEwuZmlsdGVyKHQsIGUpIH0gcmV0dXJuIEwuZ3JlcChlLCBmdW5jdGlvbihlKSB7IHJldHVybiB3LmNhbGwodCwgZSkgPj0gMCAhPT0gbiB9KSB9XG5cbiAgICBmdW5jdGlvbiBpKGUsIHQpIHsgZm9yICg7XG4gICAgICAgICAgICAoZSA9IGVbdF0pICYmIDEgIT09IGUubm9kZVR5cGU7KTsgcmV0dXJuIGUgfVxuXG4gICAgZnVuY3Rpb24gbyhlKSB7IHZhciB0ID0geltlXSA9IHt9OyByZXR1cm4gTC5lYWNoKGUubWF0Y2goUSkgfHwgW10sIGZ1bmN0aW9uKGUsIG4pIHsgdFtuXSA9ICEwIH0pLCB0IH1cblxuICAgIGZ1bmN0aW9uIGEoKSB7IEUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgYSwgITEpLCBlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGEsICExKSwgTC5yZWFkeSgpIH1cblxuICAgIGZ1bmN0aW9uIHMoKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmNhY2hlID0ge30sIDAsIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHt9IH0gfSksIHRoaXMuZXhwYW5kbyA9IEwuZXhwYW5kbyArIE1hdGgucmFuZG9tKCkgfVxuXG4gICAgZnVuY3Rpb24gdShlLCB0LCBuKSB7IHZhciByOyBpZiAodm9pZCAwID09PSBuICYmIDEgPT09IGUubm9kZVR5cGUpXG4gICAgICAgICAgICBpZiAociA9IFwiZGF0YS1cIiArIHQucmVwbGFjZShlZSwgXCItJDFcIikudG9Mb3dlckNhc2UoKSwgXCJzdHJpbmdcIiA9PSB0eXBlb2YobiA9IGUuZ2V0QXR0cmlidXRlKHIpKSkgeyB0cnkgeyBuID0gXCJ0cnVlXCIgPT09IG4gfHwgXCJmYWxzZVwiICE9PSBuICYmIChcIm51bGxcIiA9PT0gbiA/IG51bGwgOiArbiArIFwiXCIgPT09IG4gPyArbiA6IFoudGVzdChuKSA/IEwucGFyc2VKU09OKG4pIDogbikgfSBjYXRjaCAoZSkge30gRy5zZXQoZSwgdCwgbikgfSBlbHNlIG4gPSB2b2lkIDA7IHJldHVybiBuIH1cblxuICAgIGZ1bmN0aW9uIGMoKSB7IHJldHVybiAhMCB9XG5cbiAgICBmdW5jdGlvbiBsKCkgeyByZXR1cm4gITEgfVxuXG4gICAgZnVuY3Rpb24gZigpIHsgdHJ5IHsgcmV0dXJuIEUuYWN0aXZlRWxlbWVudCB9IGNhdGNoIChlKSB7fSB9XG5cbiAgICBmdW5jdGlvbiBkKGUsIHQpIHsgcmV0dXJuIEwubm9kZU5hbWUoZSwgXCJ0YWJsZVwiKSAmJiBMLm5vZGVOYW1lKDExICE9PSB0Lm5vZGVUeXBlID8gdCA6IHQuZmlyc3RDaGlsZCwgXCJ0clwiKSA/IGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0Ym9keVwiKVswXSB8fCBlLmFwcGVuZENoaWxkKGUub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGJvZHlcIikpIDogZSB9XG5cbiAgICBmdW5jdGlvbiBwKGUpIHsgcmV0dXJuIGUudHlwZSA9IChudWxsICE9PSBlLmdldEF0dHJpYnV0ZShcInR5cGVcIikpICsgXCIvXCIgKyBlLnR5cGUsIGUgfVxuXG4gICAgZnVuY3Rpb24gaChlKSB7IHZhciB0ID0gZGUuZXhlYyhlLnR5cGUpOyByZXR1cm4gdCA/IGUudHlwZSA9IHRbMV0gOiBlLnJlbW92ZUF0dHJpYnV0ZShcInR5cGVcIiksIGUgfVxuXG4gICAgZnVuY3Rpb24gdihlLCB0KSB7IGZvciAodmFyIG4gPSAwLCByID0gZS5sZW5ndGg7IG4gPCByOyBuKyspIEouc2V0KGVbbl0sIFwiZ2xvYmFsRXZhbFwiLCAhdCB8fCBKLmdldCh0W25dLCBcImdsb2JhbEV2YWxcIikpIH1cblxuICAgIGZ1bmN0aW9uIGcoZSwgdCkgeyB2YXIgbiwgciwgaSwgbywgYSwgcywgdSwgYzsgaWYgKDEgPT09IHQubm9kZVR5cGUpIHsgaWYgKEouaGFzRGF0YShlKSAmJiAobyA9IEouYWNjZXNzKGUpLCBhID0gSi5zZXQodCwgbyksIGMgPSBvLmV2ZW50cykpIHsgZGVsZXRlIGEuaGFuZGxlLCBhLmV2ZW50cyA9IHt9OyBmb3IgKGkgaW4gYylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChuID0gMCwgciA9IGNbaV0ubGVuZ3RoOyBuIDwgcjsgbisrKSBMLmV2ZW50LmFkZCh0LCBpLCBjW2ldW25dKSB9IEcuaGFzRGF0YShlKSAmJiAocyA9IEcuYWNjZXNzKGUpLCB1ID0gTC5leHRlbmQoe30sIHMpLCBHLnNldCh0LCB1KSkgfSB9XG5cbiAgICBmdW5jdGlvbiBtKGUsIHQpIHsgdmFyIG4gPSBlLmdldEVsZW1lbnRzQnlUYWdOYW1lID8gZS5nZXRFbGVtZW50c0J5VGFnTmFtZSh0IHx8IFwiKlwiKSA6IGUucXVlcnlTZWxlY3RvckFsbCA/IGUucXVlcnlTZWxlY3RvckFsbCh0IHx8IFwiKlwiKSA6IFtdOyByZXR1cm4gdm9pZCAwID09PSB0IHx8IHQgJiYgTC5ub2RlTmFtZShlLCB0KSA/IEwubWVyZ2UoW2VdLCBuKSA6IG4gfVxuXG4gICAgZnVuY3Rpb24geShlLCB0KSB7IHZhciBuID0gdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOyBcImlucHV0XCIgPT09IG4gJiYgdGUudGVzdChlLnR5cGUpID8gdC5jaGVja2VkID0gZS5jaGVja2VkIDogXCJpbnB1dFwiICE9PSBuICYmIFwidGV4dGFyZWFcIiAhPT0gbiB8fCAodC5kZWZhdWx0VmFsdWUgPSBlLmRlZmF1bHRWYWx1ZSkgfVxuXG4gICAgZnVuY3Rpb24gYihlLCB0LCBuLCByKSB7IHZhciBpOyBpZiAoTC5pc0FycmF5KHQpKSBMLmVhY2godCwgZnVuY3Rpb24odCwgaSkgeyBuIHx8IGtlLnRlc3QoZSkgPyByKGUsIGkpIDogYihlICsgXCJbXCIgKyAoXCJvYmplY3RcIiA9PSB0eXBlb2YgaSA/IHQgOiBcIlwiKSArIFwiXVwiLCBpLCBuLCByKSB9KTtcbiAgICAgICAgZWxzZSBpZiAobiB8fCBcIm9iamVjdFwiICE9PSBMLnR5cGUodCkpIHIoZSwgdCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAoaSBpbiB0KSBiKGUgKyBcIltcIiArIGkgKyBcIl1cIiwgdFtpXSwgbiwgcikgfSB2YXIgeCA9IFtdLFxuICAgICAgICBrID0geC5zbGljZSxcbiAgICAgICAgVCA9IHguY29uY2F0LFxuICAgICAgICBDID0geC5wdXNoLFxuICAgICAgICB3ID0geC5pbmRleE9mLFxuICAgICAgICBEID0ge30sXG4gICAgICAgIE4gPSBELnRvU3RyaW5nLFxuICAgICAgICBqID0gRC5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgICAgQSA9IHt9LFxuICAgICAgICBFID0gZS5kb2N1bWVudCxcbiAgICAgICAgUyA9IFwiMi4xLjEgLWFqYXgsLWFqYXgvanNvbnAsLWFqYXgvbG9hZCwtYWpheC9wYXJzZUpTT04sLWFqYXgvcGFyc2VYTUwsLWFqYXgvc2NyaXB0LC1hamF4L3Zhci9ub25jZSwtYWpheC92YXIvcnF1ZXJ5LC1hamF4L3hociwtbWFuaXB1bGF0aW9uL19ldmFsVXJsLC1jc3MsLWNzcy9hZGRHZXRIb29rSWYsLWNzcy9jdXJDU1MsLWNzcy9kZWZhdWx0RGlzcGxheSwtY3NzL2hpZGRlblZpc2libGVTZWxlY3RvcnMsLWNzcy9zdXBwb3J0LC1jc3Mvc3dhcCwtY3NzL3Zhci9jc3NFeHBhbmQsLWNzcy92YXIvZ2V0U3R5bGVzLC1jc3MvdmFyL2lzSGlkZGVuLC1jc3MvdmFyL3JtYXJnaW4sLWNzcy92YXIvcm51bW5vbnB4LC1lZmZlY3RzLC1lZmZlY3RzL1R3ZWVuLC1lZmZlY3RzL2FuaW1hdGVkU2VsZWN0b3IsLWRpbWVuc2lvbnMsLW9mZnNldCwtZGVwcmVjYXRlZCwtZXZlbnQtYWxpYXMsLXdyYXBcIixcbiAgICAgICAgTCA9IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIG5ldyBMLmZuLmluaXQoZSwgdCkgfSxcbiAgICAgICAgcSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxcbiAgICAgICAgTyA9IC9eLW1zLS8sXG4gICAgICAgIEYgPSAvLShbXFxkYS16XSkvZ2ksXG4gICAgICAgIEggPSBmdW5jdGlvbihlLCB0KSB7IHJldHVybiB0LnRvVXBwZXJDYXNlKCkgfTtcbiAgICBMLmZuID0gTC5wcm90b3R5cGUgPSB7IGpxdWVyeTogUywgY29uc3RydWN0b3I6IEwsIHNlbGVjdG9yOiBcIlwiLCBsZW5ndGg6IDAsIHRvQXJyYXk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gay5jYWxsKHRoaXMpIH0sIGdldDogZnVuY3Rpb24oZSkgeyByZXR1cm4gbnVsbCAhPSBlID8gZSA8IDAgPyB0aGlzW2UgKyB0aGlzLmxlbmd0aF0gOiB0aGlzW2VdIDogay5jYWxsKHRoaXMpIH0sIHB1c2hTdGFjazogZnVuY3Rpb24oZSkgeyB2YXIgdCA9IEwubWVyZ2UodGhpcy5jb25zdHJ1Y3RvcigpLCBlKTsgcmV0dXJuIHQucHJldk9iamVjdCA9IHRoaXMsIHQuY29udGV4dCA9IHRoaXMuY29udGV4dCwgdCB9LCBlYWNoOiBmdW5jdGlvbihlLCB0KSB7IHJldHVybiBMLmVhY2godGhpcywgZSwgdCkgfSwgbWFwOiBmdW5jdGlvbihlKSB7IHJldHVybiB0aGlzLnB1c2hTdGFjayhMLm1hcCh0aGlzLCBmdW5jdGlvbih0LCBuKSB7IHJldHVybiBlLmNhbGwodCwgbiwgdCkgfSkpIH0sIHNsaWNlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucHVzaFN0YWNrKGsuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgfSwgZmlyc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5lcSgwKSB9LCBsYXN0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZXEoLTEpIH0sIGVxOiBmdW5jdGlvbihlKSB7IHZhciB0ID0gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbiA9ICtlICsgKGUgPCAwID8gdCA6IDApOyByZXR1cm4gdGhpcy5wdXNoU3RhY2sobiA+PSAwICYmIG4gPCB0ID8gW3RoaXNbbl1dIDogW10pIH0sIGVuZDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcihudWxsKSB9LCBwdXNoOiBDLCBzb3J0OiB4LnNvcnQsIHNwbGljZTogeC5zcGxpY2UgfSwgTC5leHRlbmQgPSBMLmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkgeyB2YXIgZSwgdCwgbiwgciwgaSwgbywgYSA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgICAgIHMgPSAxLFxuICAgICAgICAgICAgdSA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBjID0gITE7IGZvciAoXCJib29sZWFuXCIgPT0gdHlwZW9mIGEgJiYgKGMgPSBhLCBhID0gYXJndW1lbnRzW3NdIHx8IHt9LCBzKyspLCBcIm9iamVjdFwiID09IHR5cGVvZiBhIHx8IEwuaXNGdW5jdGlvbihhKSB8fCAoYSA9IHt9KSwgcyA9PT0gdSAmJiAoYSA9IHRoaXMsIHMtLSk7IHMgPCB1OyBzKyspXG4gICAgICAgICAgICBpZiAobnVsbCAhPSAoZSA9IGFyZ3VtZW50c1tzXSkpXG4gICAgICAgICAgICAgICAgZm9yICh0IGluIGUpIG4gPSBhW3RdLCBhICE9PSAociA9IGVbdF0pICYmIChjICYmIHIgJiYgKEwuaXNQbGFpbk9iamVjdChyKSB8fCAoaSA9IEwuaXNBcnJheShyKSkpID8gKGkgPyAoaSA9ICExLCBvID0gbiAmJiBMLmlzQXJyYXkobikgPyBuIDogW10pIDogbyA9IG4gJiYgTC5pc1BsYWluT2JqZWN0KG4pID8gbiA6IHt9LCBhW3RdID0gTC5leHRlbmQoYywgbywgcikpIDogdm9pZCAwICE9PSByICYmIChhW3RdID0gcikpOyByZXR1cm4gYSB9LCBMLmV4dGVuZCh7IGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoUyArIE1hdGgucmFuZG9tKCkpLnJlcGxhY2UoL1xcRC9nLCBcIlwiKSwgaXNSZWFkeTogITAsIGVycm9yOiBmdW5jdGlvbihlKSB7IHRocm93IG5ldyBFcnJvcihlKSB9LCBub29wOiBmdW5jdGlvbigpIHt9LCBpc0Z1bmN0aW9uOiBmdW5jdGlvbihlKSB7IHJldHVybiBcImZ1bmN0aW9uXCIgPT09IEwudHlwZShlKSB9LCBpc0FycmF5OiBBcnJheS5pc0FycmF5LCBpc1dpbmRvdzogZnVuY3Rpb24oZSkgeyByZXR1cm4gbnVsbCAhPSBlICYmIGUgPT09IGUud2luZG93IH0sIGlzTnVtZXJpYzogZnVuY3Rpb24oZSkgeyByZXR1cm4gIUwuaXNBcnJheShlKSAmJiBlIC0gcGFyc2VGbG9hdChlKSA+PSAwIH0sIGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIFwib2JqZWN0XCIgPT09IEwudHlwZShlKSAmJiAhZS5ub2RlVHlwZSAmJiAhTC5pc1dpbmRvdyhlKSAmJiAhKGUuY29uc3RydWN0b3IgJiYgIWouY2FsbChlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIpKSB9LCBpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbihlKSB7IHZhciB0OyBmb3IgKHQgaW4gZSkgcmV0dXJuICExOyByZXR1cm4gITAgfSwgdHlwZTogZnVuY3Rpb24oZSkgeyByZXR1cm4gbnVsbCA9PSBlID8gZSArIFwiXCIgOiBcIm9iamVjdFwiID09IHR5cGVvZiBlIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSA/IERbTi5jYWxsKGUpXSB8fCBcIm9iamVjdFwiIDogdHlwZW9mIGUgfSwgZ2xvYmFsRXZhbDogZnVuY3Rpb24oZSkgeyB2YXIgdCwgbiA9IGV2YWw7XG4gICAgICAgICAgICAoZSA9IEwudHJpbShlKSkgJiYgKDEgPT09IGUuaW5kZXhPZihcInVzZSBzdHJpY3RcIikgPyAoKHQgPSBFLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpLnRleHQgPSBlLCBFLmhlYWQuYXBwZW5kQ2hpbGQodCkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KSkgOiBuKGUpKSB9LCBjYW1lbENhc2U6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUucmVwbGFjZShPLCBcIm1zLVwiKS5yZXBsYWNlKEYsIEgpIH0sIG5vZGVOYW1lOiBmdW5jdGlvbihlLCB0KSB7IHJldHVybiBlLm5vZGVOYW1lICYmIGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gdC50b0xvd2VyQ2FzZSgpIH0sIGVhY2g6IGZ1bmN0aW9uKGUsIHQsIHIpIHsgdmFyIGkgPSAwLFxuICAgICAgICAgICAgICAgIG8gPSBlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBhID0gbihlKTsgaWYgKHIpIHsgaWYgKGEpXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbyAmJiAhMSAhPT0gdC5hcHBseShlW2ldLCByKTsgaSsrKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSBpbiBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCExID09PSB0LmFwcGx5KGVbaV0sIHIpKSBicmVhayB9IGVsc2UgaWYgKGEpXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBvICYmICExICE9PSB0LmNhbGwoZVtpXSwgaSwgZVtpXSk7IGkrKyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm9yIChpIGluIGUpXG4gICAgICAgICAgICAgICAgICAgIGlmICghMSA9PT0gdC5jYWxsKGVbaV0sIGksIGVbaV0pKSBicmVhazsgcmV0dXJuIGUgfSwgdHJpbTogZnVuY3Rpb24oZSkgeyByZXR1cm4gbnVsbCA9PSBlID8gXCJcIiA6IChlICsgXCJcIikucmVwbGFjZShxLCBcIlwiKSB9LCBtYWtlQXJyYXk6IGZ1bmN0aW9uKGUsIHQpIHsgdmFyIHIgPSB0IHx8IFtdOyByZXR1cm4gbnVsbCAhPSBlICYmIChuKE9iamVjdChlKSkgPyBMLm1lcmdlKHIsIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyBbZV0gOiBlKSA6IEMuY2FsbChyLCBlKSksIHIgfSwgaW5BcnJheTogZnVuY3Rpb24oZSwgdCwgbikgeyByZXR1cm4gbnVsbCA9PSB0ID8gLTEgOiB3LmNhbGwodCwgZSwgbikgfSwgbWVyZ2U6IGZ1bmN0aW9uKGUsIHQpIHsgZm9yICh2YXIgbiA9ICt0Lmxlbmd0aCwgciA9IDAsIGkgPSBlLmxlbmd0aDsgciA8IG47IHIrKykgZVtpKytdID0gdFtyXTsgcmV0dXJuIGUubGVuZ3RoID0gaSwgZSB9LCBncmVwOiBmdW5jdGlvbihlLCB0LCBuKSB7IGZvciAodmFyIHIgPSBbXSwgaSA9IDAsIG8gPSBlLmxlbmd0aCwgYSA9ICFuOyBpIDwgbzsgaSsrKSAhdChlW2ldLCBpKSAhPT0gYSAmJiByLnB1c2goZVtpXSk7IHJldHVybiByIH0sIG1hcDogZnVuY3Rpb24oZSwgdCwgcikgeyB2YXIgaSwgbyA9IDAsXG4gICAgICAgICAgICAgICAgYSA9IGUubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHMgPSBbXTsgaWYgKG4oZSkpXG4gICAgICAgICAgICAgICAgZm9yICg7IG8gPCBhOyBvKyspIG51bGwgIT0gKGkgPSB0KGVbb10sIG8sIHIpKSAmJiBzLnB1c2goaSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZm9yIChvIGluIGUpIG51bGwgIT0gKGkgPSB0KGVbb10sIG8sIHIpKSAmJiBzLnB1c2goaSk7IHJldHVybiBULmFwcGx5KFtdLCBzKSB9LCBndWlkOiAxLCBwcm94eTogZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiwgciwgaTsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgJiYgKG4gPSBlW3RdLCB0ID0gZSwgZSA9IG4pLCBMLmlzRnVuY3Rpb24oZSkpIHJldHVybiByID0gay5jYWxsKGFyZ3VtZW50cywgMiksIGkgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGUuYXBwbHkodCB8fCB0aGlzLCByLmNvbmNhdChrLmNhbGwoYXJndW1lbnRzKSkpIH0sIGkuZ3VpZCA9IGUuZ3VpZCA9IGUuZ3VpZCB8fCBMLmd1aWQrKywgaSB9LCBub3c6IERhdGUubm93LCBzdXBwb3J0OiBBIH0pLCBMLmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yXCIuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbihlLCB0KSB7IERbXCJbb2JqZWN0IFwiICsgdCArIFwiXVwiXSA9IHQudG9Mb3dlckNhc2UoKSB9KTsgdmFyIFAsIE0gPSBlLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgVyA9IE0ubWF0Y2hlcyB8fCBNLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBNLm1vek1hdGNoZXNTZWxlY3RvciB8fCBNLm9NYXRjaGVzU2VsZWN0b3IgfHwgTS5tc01hdGNoZXNTZWxlY3RvcixcbiAgICAgICAgJCA9IGZ1bmN0aW9uKGUsIHQpIHsgaWYgKGUgPT09IHQpIHJldHVybiBQID0gITAsIDA7IHZhciBuID0gdC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24odCk7IHJldHVybiBuID8gMSAmIG4gPyBlID09PSBFIHx8IEwuY29udGFpbnMoRSwgZSkgPyAtMSA6IHQgPT09IEUgfHwgTC5jb250YWlucyhFLCB0KSA/IDEgOiAwIDogNCAmIG4gPyAtMSA6IDEgOiBlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uID8gLTEgOiAxIH07XG4gICAgTC5leHRlbmQoeyBmaW5kOiBmdW5jdGlvbihlLCB0LCBuLCByKSB7IHZhciBpLCBvLCBhID0gMDsgaWYgKG4gPSBuIHx8IFtdLCB0ID0gdCB8fCBFLCAhZSB8fCBcInN0cmluZ1wiICE9IHR5cGVvZiBlKSByZXR1cm4gbjsgaWYgKDEgIT09IChvID0gdC5ub2RlVHlwZSkgJiYgOSAhPT0gbykgcmV0dXJuIFtdOyBpZiAocilcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA9IHJbYSsrXTspIEwuZmluZC5tYXRjaGVzU2VsZWN0b3IoaSwgZSkgJiYgbi5wdXNoKGkpO1xuICAgICAgICAgICAgZWxzZSBMLm1lcmdlKG4sIHQucXVlcnlTZWxlY3RvckFsbChlKSk7IHJldHVybiBuIH0sIHVuaXF1ZTogZnVuY3Rpb24oZSkgeyB2YXIgdCwgbiA9IFtdLFxuICAgICAgICAgICAgICAgIHIgPSAwLFxuICAgICAgICAgICAgICAgIGkgPSAwOyBpZiAoUCA9ICExLCBlLnNvcnQoJCksIFApIHsgZm9yICg7IHQgPSBlW3IrK107KSB0ID09PSBlW3JdICYmIChpID0gbi5wdXNoKHIpKTsgZm9yICg7IGktLTspIGUuc3BsaWNlKG5baV0sIDEpIH0gcmV0dXJuIGUgfSwgdGV4dDogZnVuY3Rpb24oZSkgeyB2YXIgdCwgbiA9IFwiXCIsXG4gICAgICAgICAgICAgICAgciA9IDAsXG4gICAgICAgICAgICAgICAgaSA9IGUubm9kZVR5cGU7IGlmIChpKSB7IGlmICgxID09PSBpIHx8IDkgPT09IGkgfHwgMTEgPT09IGkpIHJldHVybiBlLnRleHRDb250ZW50OyBpZiAoMyA9PT0gaSB8fCA0ID09PSBpKSByZXR1cm4gZS5ub2RlVmFsdWUgfSBlbHNlXG4gICAgICAgICAgICAgICAgZm9yICg7IHQgPSBlW3IrK107KSBuICs9IEwudGV4dCh0KTsgcmV0dXJuIG4gfSwgY29udGFpbnM6IGZ1bmN0aW9uKGUsIHQpIHsgdmFyIG4gPSA5ID09PSBlLm5vZGVUeXBlID8gZS5kb2N1bWVudEVsZW1lbnQgOiBlLFxuICAgICAgICAgICAgICAgIHIgPSB0ICYmIHQucGFyZW50Tm9kZTsgcmV0dXJuIGUgPT09IHIgfHwgISghciB8fCAxICE9PSByLm5vZGVUeXBlIHx8ICFuLmNvbnRhaW5zKHIpKSB9LCBpc1hNTERvYzogZnVuY3Rpb24oZSkgeyByZXR1cm4gXCJIVE1MXCIgIT09IChlLm93bmVyRG9jdW1lbnQgfHwgZSkuZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lIH0sIGV4cHI6IHsgYXR0ckhhbmRsZToge30sIG1hdGNoOiB7IGJvb2w6IC9eKD86Y2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWQpJC9pLCBuZWVkc0NvbnRleHQ6IC9eW1xceDIwXFx0XFxyXFxuXFxmXSpbPit+XS8gfSB9IH0pLCBMLmV4dGVuZChMLmZpbmQsIHsgbWF0Y2hlczogZnVuY3Rpb24oZSwgdCkgeyByZXR1cm4gTC5maW5kKGUsIG51bGwsIG51bGwsIHQpIH0sIG1hdGNoZXNTZWxlY3RvcjogZnVuY3Rpb24oZSwgdCkgeyByZXR1cm4gVy5jYWxsKGUsIHQpIH0sIGF0dHI6IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIGUuZ2V0QXR0cmlidXRlKHQpIH0gfSk7IHZhciBfID0gTC5leHByLm1hdGNoLm5lZWRzQ29udGV4dCxcbiAgICAgICAgSSA9IC9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLyxcbiAgICAgICAgQiA9IC9eLlteOiNcXFtcXC4sXSokLztcbiAgICBMLmZpbHRlciA9IGZ1bmN0aW9uKGUsIHQsIG4pIHsgdmFyIHIgPSB0WzBdOyByZXR1cm4gbiAmJiAoZSA9IFwiOm5vdChcIiArIGUgKyBcIilcIiksIDEgPT09IHQubGVuZ3RoICYmIDEgPT09IHIubm9kZVR5cGUgPyBMLmZpbmQubWF0Y2hlc1NlbGVjdG9yKHIsIGUpID8gW3JdIDogW10gOiBMLmZpbmQubWF0Y2hlcyhlLCBMLmdyZXAodCwgZnVuY3Rpb24oZSkgeyByZXR1cm4gMSA9PT0gZS5ub2RlVHlwZSB9KSkgfSwgTC5mbi5leHRlbmQoeyBmaW5kOiBmdW5jdGlvbihlKSB7IHZhciB0LCBuID0gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgciA9IFtdLFxuICAgICAgICAgICAgICAgIGkgPSB0aGlzOyBpZiAoXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSkgcmV0dXJuIHRoaXMucHVzaFN0YWNrKEwoZSkuZmlsdGVyKGZ1bmN0aW9uKCkgeyBmb3IgKHQgPSAwOyB0IDwgbjsgdCsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoTC5jb250YWlucyhpW3RdLCB0aGlzKSkgcmV0dXJuICEwIH0pKTsgZm9yICh0ID0gMDsgdCA8IG47IHQrKykgTC5maW5kKGUsIGlbdF0sIHIpOyByZXR1cm4gciA9IHRoaXMucHVzaFN0YWNrKG4gPiAxID8gTC51bmlxdWUocikgOiByKSwgci5zZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yICsgXCIgXCIgKyBlIDogZSwgciB9LCBmaWx0ZXI6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHIodGhpcywgZSB8fCBbXSwgITEpKSB9LCBub3Q6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHIodGhpcywgZSB8fCBbXSwgITApKSB9LCBpczogZnVuY3Rpb24oZSkgeyByZXR1cm4gISFyKHRoaXMsIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgXy50ZXN0KGUpID8gTChlKSA6IGUgfHwgW10sICExKS5sZW5ndGggfSB9KTsgdmFyIFgsIFUgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0qKSkkLztcbiAgICAoTC5mbi5pbml0ID0gZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiwgcjsgaWYgKCFlKSByZXR1cm4gdGhpczsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHsgaWYgKCEobiA9IFwiPFwiID09PSBlWzBdICYmIFwiPlwiID09PSBlW2UubGVuZ3RoIC0gMV0gJiYgZS5sZW5ndGggPj0gMyA/IFtudWxsLCBlLCBudWxsXSA6IFUuZXhlYyhlKSkgfHwgIW5bMV0gJiYgdCkgcmV0dXJuICF0IHx8IHQuanF1ZXJ5ID8gKHQgfHwgWCkuZmluZChlKSA6IHRoaXMuY29uc3RydWN0b3IodCkuZmluZChlKTsgaWYgKG5bMV0pIHsgaWYgKHQgPSB0IGluc3RhbmNlb2YgTCA/IHRbMF0gOiB0LCBMLm1lcmdlKHRoaXMsIEwucGFyc2VIVE1MKG5bMV0sIHQgJiYgdC5ub2RlVHlwZSA/IHQub3duZXJEb2N1bWVudCB8fCB0IDogRSwgITApKSwgSS50ZXN0KG5bMV0pICYmIEwuaXNQbGFpbk9iamVjdCh0KSlcbiAgICAgICAgICAgICAgICAgICAgZm9yIChuIGluIHQpIEwuaXNGdW5jdGlvbih0aGlzW25dKSA/IHRoaXNbbl0odFtuXSkgOiB0aGlzLmF0dHIobiwgdFtuXSk7IHJldHVybiB0aGlzIH0gcmV0dXJuIChyID0gRS5nZXRFbGVtZW50QnlJZChuWzJdKSkgJiYgci5wYXJlbnROb2RlICYmICh0aGlzLmxlbmd0aCA9IDEsIHRoaXNbMF0gPSByKSwgdGhpcy5jb250ZXh0ID0gRSwgdGhpcy5zZWxlY3RvciA9IGUsIHRoaXMgfSByZXR1cm4gZS5ub2RlVHlwZSA/ICh0aGlzLmNvbnRleHQgPSB0aGlzWzBdID0gZSwgdGhpcy5sZW5ndGggPSAxLCB0aGlzKSA6IEwuaXNGdW5jdGlvbihlKSA/IHZvaWQgMCAhPT0gWC5yZWFkeSA/IFgucmVhZHkoZSkgOiBlKEwpIDogKHZvaWQgMCAhPT0gZS5zZWxlY3RvciAmJiAodGhpcy5zZWxlY3RvciA9IGUuc2VsZWN0b3IsIHRoaXMuY29udGV4dCA9IGUuY29udGV4dCksIEwubWFrZUFycmF5KGUsIHRoaXMpKSB9KS5wcm90b3R5cGUgPSBMLmZuLCBYID0gTChFKTsgdmFyIFIgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcbiAgICAgICAgViA9IHsgY2hpbGRyZW46ICEwLCBjb250ZW50czogITAsIG5leHQ6ICEwLCBwcmV2OiAhMCB9O1xuICAgIEwuZXh0ZW5kKHsgZGlyOiBmdW5jdGlvbihlLCB0LCBuKSB7IGZvciAodmFyIHIgPSBbXSwgaSA9IHZvaWQgMCAhPT0gbjtcbiAgICAgICAgICAgICAgICAoZSA9IGVbdF0pICYmIDkgIT09IGUubm9kZVR5cGU7KVxuICAgICAgICAgICAgICAgIGlmICgxID09PSBlLm5vZGVUeXBlKSB7IGlmIChpICYmIEwoZSkuaXMobikpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICByLnB1c2goZSkgfSByZXR1cm4gciB9LCBzaWJsaW5nOiBmdW5jdGlvbihlLCB0KSB7IGZvciAodmFyIG4gPSBbXTsgZTsgZSA9IGUubmV4dFNpYmxpbmcpIDEgPT09IGUubm9kZVR5cGUgJiYgZSAhPT0gdCAmJiBuLnB1c2goZSk7IHJldHVybiBuIH0gfSksIEwuZm4uZXh0ZW5kKHsgaGFzOiBmdW5jdGlvbihlKSB7IHZhciB0ID0gTChlLCB0aGlzKSxcbiAgICAgICAgICAgICAgICBuID0gdC5sZW5ndGg7IHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpIHsgZm9yICh2YXIgZSA9IDA7IGUgPCBuOyBlKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChMLmNvbnRhaW5zKHRoaXMsIHRbZV0pKSByZXR1cm4gITAgfSkgfSwgY2xvc2VzdDogZnVuY3Rpb24oZSwgdCkgeyBmb3IgKHZhciBuLCByID0gMCwgaSA9IHRoaXMubGVuZ3RoLCBvID0gW10sIGEgPSBfLnRlc3QoZSkgfHwgXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSA/IEwoZSwgdCB8fCB0aGlzLmNvbnRleHQpIDogMDsgciA8IGk7IHIrKylcbiAgICAgICAgICAgICAgICBmb3IgKG4gPSB0aGlzW3JdOyBuICYmIG4gIT09IHQ7IG4gPSBuLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGlmIChuLm5vZGVUeXBlIDwgMTEgJiYgKGEgPyBhLmluZGV4KG4pID4gLTEgOiAxID09PSBuLm5vZGVUeXBlICYmIEwuZmluZC5tYXRjaGVzU2VsZWN0b3IobiwgZSkpKSB7IG8ucHVzaChuKTsgYnJlYWsgfSByZXR1cm4gdGhpcy5wdXNoU3RhY2soby5sZW5ndGggPiAxID8gTC51bmlxdWUobykgOiBvKSB9LCBpbmRleDogZnVuY3Rpb24oZSkgeyByZXR1cm4gZSA/IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgPyB3LmNhbGwoTChlKSwgdGhpc1swXSkgOiB3LmNhbGwodGhpcywgZS5qcXVlcnkgPyBlWzBdIDogZSkgOiB0aGlzWzBdICYmIHRoaXNbMF0ucGFyZW50Tm9kZSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTEgfSwgYWRkOiBmdW5jdGlvbihlLCB0KSB7IHJldHVybiB0aGlzLnB1c2hTdGFjayhMLnVuaXF1ZShMLm1lcmdlKHRoaXMuZ2V0KCksIEwoZSwgdCkpKSkgfSwgYWRkQmFjazogZnVuY3Rpb24oZSkgeyByZXR1cm4gdGhpcy5hZGQobnVsbCA9PSBlID8gdGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihlKSkgfSB9KSwgTC5lYWNoKHsgcGFyZW50OiBmdW5jdGlvbihlKSB7IHZhciB0ID0gZS5wYXJlbnROb2RlOyByZXR1cm4gdCAmJiAxMSAhPT0gdC5ub2RlVHlwZSA/IHQgOiBudWxsIH0sIHBhcmVudHM6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIEwuZGlyKGUsIFwicGFyZW50Tm9kZVwiKSB9LCBwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgcmV0dXJuIEwuZGlyKGUsIFwicGFyZW50Tm9kZVwiLCBuKSB9LCBuZXh0OiBmdW5jdGlvbihlKSB7IHJldHVybiBpKGUsIFwibmV4dFNpYmxpbmdcIikgfSwgcHJldjogZnVuY3Rpb24oZSkgeyByZXR1cm4gaShlLCBcInByZXZpb3VzU2libGluZ1wiKSB9LCBuZXh0QWxsOiBmdW5jdGlvbihlKSB7IHJldHVybiBMLmRpcihlLCBcIm5leHRTaWJsaW5nXCIpIH0sIHByZXZBbGw6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIEwuZGlyKGUsIFwicHJldmlvdXNTaWJsaW5nXCIpIH0sIG5leHRVbnRpbDogZnVuY3Rpb24oZSwgdCwgbikgeyByZXR1cm4gTC5kaXIoZSwgXCJuZXh0U2libGluZ1wiLCBuKSB9LCBwcmV2VW50aWw6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgcmV0dXJuIEwuZGlyKGUsIFwicHJldmlvdXNTaWJsaW5nXCIsIG4pIH0sIHNpYmxpbmdzOiBmdW5jdGlvbihlKSB7IHJldHVybiBMLnNpYmxpbmcoKGUucGFyZW50Tm9kZSB8fCB7fSkuZmlyc3RDaGlsZCwgZSkgfSwgY2hpbGRyZW46IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIEwuc2libGluZyhlLmZpcnN0Q2hpbGQpIH0sIGNvbnRlbnRzOiBmdW5jdGlvbihlKSB7IHJldHVybiBlLmNvbnRlbnREb2N1bWVudCB8fCBMLm1lcmdlKFtdLCBlLmNoaWxkTm9kZXMpIH0gfSwgZnVuY3Rpb24oZSwgdCkgeyBMLmZuW2VdID0gZnVuY3Rpb24obiwgcikgeyB2YXIgaSA9IEwubWFwKHRoaXMsIHQsIG4pOyByZXR1cm4gXCJVbnRpbFwiICE9PSBlLnNsaWNlKC01KSAmJiAociA9IG4pLCByICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIHIgJiYgKGkgPSBMLmZpbHRlcihyLCBpKSksIHRoaXMubGVuZ3RoID4gMSAmJiAoVltlXSB8fCBMLnVuaXF1ZShpKSwgUi50ZXN0KGUpICYmIGkucmV2ZXJzZSgpKSwgdGhpcy5wdXNoU3RhY2soaSkgfSB9KTsgdmFyIFEgPSAvXFxTKy9nLFxuICAgICAgICB6ID0ge307XG4gICAgTC5DYWxsYmFja3MgPSBmdW5jdGlvbihlKSB7IHZhciB0LCBuLCByLCBpLCBhLCBzLCB1ID0gW10sXG4gICAgICAgICAgICBjID0gIShlID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IHpbZV0gfHwgbyhlKSA6IEwuZXh0ZW5kKHt9LCBlKSkub25jZSAmJiBbXSxcbiAgICAgICAgICAgIGwgPSBmdW5jdGlvbihvKSB7IGZvciAodCA9IGUubWVtb3J5ICYmIG8sIG4gPSAhMCwgcyA9IGkgfHwgMCwgaSA9IDAsIGEgPSB1Lmxlbmd0aCwgciA9ICEwOyB1ICYmIHMgPCBhOyBzKyspXG4gICAgICAgICAgICAgICAgICAgIGlmICghMSA9PT0gdVtzXS5hcHBseShvWzBdLCBvWzFdKSAmJiBlLnN0b3BPbkZhbHNlKSB7IHQgPSAhMTsgYnJlYWsgfSByID0gITEsIHUgJiYgKGMgPyBjLmxlbmd0aCAmJiBsKGMuc2hpZnQoKSkgOiB0ID8gdSA9IFtdIDogZi5kaXNhYmxlKCkpIH0sXG4gICAgICAgICAgICBmID0geyBhZGQ6IGZ1bmN0aW9uKCkgeyBpZiAodSkgeyB2YXIgbiA9IHUubGVuZ3RoOyEgZnVuY3Rpb24gdChuKSB7IEwuZWFjaChuLCBmdW5jdGlvbihuLCByKSB7IHZhciBpID0gTC50eXBlKHIpOyBcImZ1bmN0aW9uXCIgPT09IGkgPyBlLnVuaXF1ZSAmJiBmLmhhcyhyKSB8fCB1LnB1c2gocikgOiByICYmIHIubGVuZ3RoICYmIFwic3RyaW5nXCIgIT09IGkgJiYgdChyKSB9KSB9KGFyZ3VtZW50cyksIHIgPyBhID0gdS5sZW5ndGggOiB0ICYmIChpID0gbiwgbCh0KSkgfSByZXR1cm4gdGhpcyB9LCByZW1vdmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdSAmJiBMLmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihlLCB0KSB7IGZvciAodmFyIG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG4gPSBMLmluQXJyYXkodCwgdSwgbikpID4gLTE7KSB1LnNwbGljZShuLCAxKSwgciAmJiAobiA8PSBhICYmIGEtLSwgbiA8PSBzICYmIHMtLSkgfSksIHRoaXMgfSwgaGFzOiBmdW5jdGlvbihlKSB7IHJldHVybiBlID8gTC5pbkFycmF5KGUsIHUpID4gLTEgOiAhKCF1IHx8ICF1Lmxlbmd0aCkgfSwgZW1wdHk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdSA9IFtdLCBhID0gMCwgdGhpcyB9LCBkaXNhYmxlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHUgPSBjID0gdCA9IHZvaWQgMCwgdGhpcyB9LCBkaXNhYmxlZDogZnVuY3Rpb24oKSB7IHJldHVybiAhdSB9LCBsb2NrOiBmdW5jdGlvbigpIHsgcmV0dXJuIGMgPSB2b2lkIDAsIHQgfHwgZi5kaXNhYmxlKCksIHRoaXMgfSwgbG9ja2VkOiBmdW5jdGlvbigpIHsgcmV0dXJuICFjIH0sIGZpcmVXaXRoOiBmdW5jdGlvbihlLCB0KSB7IHJldHVybiAhdSB8fCBuICYmICFjIHx8ICh0ID0gW2UsICh0ID0gdCB8fCBbXSkuc2xpY2UgPyB0LnNsaWNlKCkgOiB0XSwgciA/IGMucHVzaCh0KSA6IGwodCkpLCB0aGlzIH0sIGZpcmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZi5maXJlV2l0aCh0aGlzLCBhcmd1bWVudHMpLCB0aGlzIH0sIGZpcmVkOiBmdW5jdGlvbigpIHsgcmV0dXJuICEhbiB9IH07IHJldHVybiBmIH0sIEwuZXh0ZW5kKHsgRGVmZXJyZWQ6IGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSBbXG4gICAgICAgICAgICAgICAgICAgIFtcInJlc29sdmVcIiwgXCJkb25lXCIsIEwuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFwicmVzb2x2ZWRcIl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInJlamVjdFwiLCBcImZhaWxcIiwgTC5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgXCJyZWplY3RlZFwiXSxcbiAgICAgICAgICAgICAgICAgICAgW1wibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgTC5DYWxsYmFja3MoXCJtZW1vcnlcIildXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBuID0gXCJwZW5kaW5nXCIsXG4gICAgICAgICAgICAgICAgciA9IHsgc3RhdGU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbiB9LCBhbHdheXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gaS5kb25lKGFyZ3VtZW50cykuZmFpbChhcmd1bWVudHMpLCB0aGlzIH0sIHRoZW46IGZ1bmN0aW9uKCkgeyB2YXIgZSA9IGFyZ3VtZW50czsgcmV0dXJuIEwuRGVmZXJyZWQoZnVuY3Rpb24obikgeyBMLmVhY2godCwgZnVuY3Rpb24odCwgbykgeyB2YXIgYSA9IEwuaXNGdW5jdGlvbihlW3RdKSAmJiBlW3RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpW29bMV1dKGZ1bmN0aW9uKCkgeyB2YXIgZSA9IGEgJiYgYS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZSAmJiBMLmlzRnVuY3Rpb24oZS5wcm9taXNlKSA/IGUucHJvbWlzZSgpLmRvbmUobi5yZXNvbHZlKS5mYWlsKG4ucmVqZWN0KS5wcm9ncmVzcyhuLm5vdGlmeSkgOiBuW29bMF0gKyBcIldpdGhcIl0odGhpcyA9PT0gciA/IG4ucHJvbWlzZSgpIDogdGhpcywgYSA/IFtlXSA6IGFyZ3VtZW50cykgfSkgfSksIGUgPSBudWxsIH0pLnByb21pc2UoKSB9LCBwcm9taXNlOiBmdW5jdGlvbihlKSB7IHJldHVybiBudWxsICE9IGUgPyBMLmV4dGVuZChlLCByKSA6IHIgfSB9LFxuICAgICAgICAgICAgICAgIGkgPSB7fTsgcmV0dXJuIHIucGlwZSA9IHIudGhlbiwgTC5lYWNoKHQsIGZ1bmN0aW9uKGUsIG8pIHsgdmFyIGEgPSBvWzJdLFxuICAgICAgICAgICAgICAgICAgICBzID0gb1szXTtcbiAgICAgICAgICAgICAgICByW29bMV1dID0gYS5hZGQsIHMgJiYgYS5hZGQoZnVuY3Rpb24oKSB7IG4gPSBzIH0sIHRbMSBeIGVdWzJdLmRpc2FibGUsIHRbMl1bMl0ubG9jayksIGlbb1swXV0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIGlbb1swXSArIFwiV2l0aFwiXSh0aGlzID09PSBpID8gciA6IHRoaXMsIGFyZ3VtZW50cyksIHRoaXMgfSwgaVtvWzBdICsgXCJXaXRoXCJdID0gYS5maXJlV2l0aCB9KSwgci5wcm9taXNlKGkpLCBlICYmIGUuY2FsbChpLCBpKSwgaSB9LCB3aGVuOiBmdW5jdGlvbihlKSB7IHZhciB0LCBuLCByLCBpID0gMCxcbiAgICAgICAgICAgICAgICBvID0gay5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgYSA9IG8ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHMgPSAxICE9PSBhIHx8IGUgJiYgTC5pc0Z1bmN0aW9uKGUucHJvbWlzZSkgPyBhIDogMCxcbiAgICAgICAgICAgICAgICB1ID0gMSA9PT0gcyA/IGUgOiBMLkRlZmVycmVkKCksXG4gICAgICAgICAgICAgICAgYyA9IGZ1bmN0aW9uKGUsIG4sIHIpIHsgcmV0dXJuIGZ1bmN0aW9uKGkpIHsgbltlXSA9IHRoaXMsIHJbZV0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGsuY2FsbChhcmd1bWVudHMpIDogaSwgciA9PT0gdCA/IHUubm90aWZ5V2l0aChuLCByKSA6IC0tcyB8fCB1LnJlc29sdmVXaXRoKG4sIHIpIH0gfTsgaWYgKGEgPiAxKVxuICAgICAgICAgICAgICAgIGZvciAodCA9IG5ldyBBcnJheShhKSwgbiA9IG5ldyBBcnJheShhKSwgciA9IG5ldyBBcnJheShhKTsgaSA8IGE7IGkrKykgb1tpXSAmJiBMLmlzRnVuY3Rpb24ob1tpXS5wcm9taXNlKSA/IG9baV0ucHJvbWlzZSgpLmRvbmUoYyhpLCByLCBvKSkuZmFpbCh1LnJlamVjdCkucHJvZ3Jlc3MoYyhpLCBuLCB0KSkgOiAtLXM7IHJldHVybiBzIHx8IHUucmVzb2x2ZVdpdGgociwgbyksIHUucHJvbWlzZSgpIH0gfSk7IHZhciBZO1xuICAgIEwuZm4ucmVhZHkgPSBmdW5jdGlvbihlKSB7IHJldHVybiBMLnJlYWR5LnByb21pc2UoKS5kb25lKGUpLCB0aGlzIH0sIEwuZXh0ZW5kKHsgaXNSZWFkeTogITEsIHJlYWR5V2FpdDogMSwgaG9sZFJlYWR5OiBmdW5jdGlvbihlKSB7IGUgPyBMLnJlYWR5V2FpdCsrIDogTC5yZWFkeSghMCkgfSwgcmVhZHk6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICghMCA9PT0gZSA/IC0tTC5yZWFkeVdhaXQgOiBMLmlzUmVhZHkpIHx8IChMLmlzUmVhZHkgPSAhMCwgITAgIT09IGUgJiYgLS1MLnJlYWR5V2FpdCA+IDAgfHwgKFkucmVzb2x2ZVdpdGgoRSwgW0xdKSwgTC5mbi50cmlnZ2VySGFuZGxlciAmJiAoTChFKS50cmlnZ2VySGFuZGxlcihcInJlYWR5XCIpLCBMKEUpLm9mZihcInJlYWR5XCIpKSkpIH0gfSksIEwucmVhZHkucHJvbWlzZSA9IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIFkgfHwgKFkgPSBMLkRlZmVycmVkKCksIFwiY29tcGxldGVcIiA9PT0gRS5yZWFkeVN0YXRlID8gc2V0VGltZW91dChMLnJlYWR5KSA6IChFLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGEsICExKSwgZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBhLCAhMSkpKSwgWS5wcm9taXNlKHQpIH0sIEwucmVhZHkucHJvbWlzZSgpOyB2YXIgSyA9IEwuYWNjZXNzID0gZnVuY3Rpb24oZSwgdCwgbiwgciwgaSwgbywgYSkgeyB2YXIgcyA9IDAsXG4gICAgICAgICAgICB1ID0gZS5sZW5ndGgsXG4gICAgICAgICAgICBjID0gbnVsbCA9PSBuOyBpZiAoXCJvYmplY3RcIiA9PT0gTC50eXBlKG4pKSB7IGkgPSAhMDsgZm9yIChzIGluIG4pIEwuYWNjZXNzKGUsIHQsIHMsIG5bc10sICEwLCBvLCBhKSB9IGVsc2UgaWYgKHZvaWQgMCAhPT0gciAmJiAoaSA9ICEwLCBMLmlzRnVuY3Rpb24ocikgfHwgKGEgPSAhMCksIGMgJiYgKGEgPyAodC5jYWxsKGUsIHIpLCB0ID0gbnVsbCkgOiAoYyA9IHQsIHQgPSBmdW5jdGlvbihlLCB0LCBuKSB7IHJldHVybiBjLmNhbGwoTChlKSwgbikgfSkpLCB0KSlcbiAgICAgICAgICAgIGZvciAoOyBzIDwgdTsgcysrKSB0KGVbc10sIG4sIGEgPyByIDogci5jYWxsKGVbc10sIHMsIHQoZVtzXSwgbikpKTsgcmV0dXJuIGkgPyBlIDogYyA/IHQuY2FsbChlKSA6IHUgPyB0KGVbMF0sIG4pIDogbyB9O1xuICAgIEwuYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIDEgPT09IGUubm9kZVR5cGUgfHwgOSA9PT0gZS5ub2RlVHlwZSB8fCAhK2Uubm9kZVR5cGUgfSwgcy51aWQgPSAxLCBzLmFjY2VwdHMgPSBMLmFjY2VwdERhdGEsIHMucHJvdG90eXBlID0geyBrZXk6IGZ1bmN0aW9uKGUpIHsgaWYgKCFzLmFjY2VwdHMoZSkpIHJldHVybiAwOyB2YXIgdCA9IHt9LFxuICAgICAgICAgICAgICAgIG4gPSBlW3RoaXMuZXhwYW5kb107IGlmICghbikgeyBuID0gcy51aWQrKzsgdHJ5IHsgdFt0aGlzLmV4cGFuZG9dID0geyB2YWx1ZTogbiB9LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCB0KSB9IGNhdGNoIChyKSB7IHRbdGhpcy5leHBhbmRvXSA9IG4sIEwuZXh0ZW5kKGUsIHQpIH0gfSByZXR1cm4gdGhpcy5jYWNoZVtuXSB8fCAodGhpcy5jYWNoZVtuXSA9IHt9KSwgbiB9LCBzZXQ6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgdmFyIHIsIGkgPSB0aGlzLmtleShlKSxcbiAgICAgICAgICAgICAgICBvID0gdGhpcy5jYWNoZVtpXTsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQpIG9bdF0gPSBuO1xuICAgICAgICAgICAgZWxzZSBpZiAoTC5pc0VtcHR5T2JqZWN0KG8pKSBMLmV4dGVuZCh0aGlzLmNhY2hlW2ldLCB0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmb3IgKHIgaW4gdCkgb1tyXSA9IHRbcl07IHJldHVybiBvIH0sIGdldDogZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiA9IHRoaXMuY2FjaGVbdGhpcy5rZXkoZSldOyByZXR1cm4gdm9pZCAwID09PSB0ID8gbiA6IG5bdF0gfSwgYWNjZXNzOiBmdW5jdGlvbihlLCB0LCBuKSB7IHZhciByOyByZXR1cm4gdm9pZCAwID09PSB0IHx8IHQgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCAmJiB2b2lkIDAgPT09IG4gPyAociA9IHRoaXMuZ2V0KGUsIHQpLCB2b2lkIDAgIT09IHIgPyByIDogdGhpcy5nZXQoZSwgTC5jYW1lbENhc2UodCkpKSA6ICh0aGlzLnNldChlLCB0LCBuKSwgdm9pZCAwICE9PSBuID8gbiA6IHQpIH0sIHJlbW92ZTogZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiwgciwgaSwgbyA9IHRoaXMua2V5KGUpLFxuICAgICAgICAgICAgICAgIGEgPSB0aGlzLmNhY2hlW29dOyBpZiAodm9pZCAwID09PSB0KSB0aGlzLmNhY2hlW29dID0ge307XG4gICAgICAgICAgICBlbHNlIHsgTC5pc0FycmF5KHQpID8gciA9IHQuY29uY2F0KHQubWFwKEwuY2FtZWxDYXNlKSkgOiAoaSA9IEwuY2FtZWxDYXNlKHQpLCByID0gdCBpbiBhID8gW3QsIGldIDogKHIgPSBpKSBpbiBhID8gW3JdIDogci5tYXRjaChRKSB8fCBbXSksIG4gPSByLmxlbmd0aDsgZm9yICg7IG4tLTspIGRlbGV0ZSBhW3Jbbl1dIH0gfSwgaGFzRGF0YTogZnVuY3Rpb24oZSkgeyByZXR1cm4gIUwuaXNFbXB0eU9iamVjdCh0aGlzLmNhY2hlW2VbdGhpcy5leHBhbmRvXV0gfHwge30pIH0sIGRpc2NhcmQ6IGZ1bmN0aW9uKGUpIHsgZVt0aGlzLmV4cGFuZG9dICYmIGRlbGV0ZSB0aGlzLmNhY2hlW2VbdGhpcy5leHBhbmRvXV0gfSB9OyB2YXIgSiA9IG5ldyBzLFxuICAgICAgICBHID0gbmV3IHMsXG4gICAgICAgIFogPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG4gICAgICAgIGVlID0gLyhbQS1aXSkvZztcbiAgICBMLmV4dGVuZCh7IGhhc0RhdGE6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIEcuaGFzRGF0YShlKSB8fCBKLmhhc0RhdGEoZSkgfSwgZGF0YTogZnVuY3Rpb24oZSwgdCwgbikgeyByZXR1cm4gRy5hY2Nlc3MoZSwgdCwgbikgfSwgcmVtb3ZlRGF0YTogZnVuY3Rpb24oZSwgdCkgeyBHLnJlbW92ZShlLCB0KSB9LCBfZGF0YTogZnVuY3Rpb24oZSwgdCwgbikgeyByZXR1cm4gSi5hY2Nlc3MoZSwgdCwgbikgfSwgX3JlbW92ZURhdGE6IGZ1bmN0aW9uKGUsIHQpIHsgSi5yZW1vdmUoZSwgdCkgfSB9KSwgTC5mbi5leHRlbmQoeyBkYXRhOiBmdW5jdGlvbihlLCB0KSB7IHZhciBuLCByLCBpLCBvID0gdGhpc1swXSxcbiAgICAgICAgICAgICAgICBhID0gbyAmJiBvLmF0dHJpYnV0ZXM7IGlmICh2b2lkIDAgPT09IGUpIHsgaWYgKHRoaXMubGVuZ3RoICYmIChpID0gRy5nZXQobyksIDEgPT09IG8ubm9kZVR5cGUgJiYgIUouZ2V0KG8sIFwiaGFzRGF0YUF0dHJzXCIpKSkgeyBmb3IgKG4gPSBhLmxlbmd0aDsgbi0tOykgYVtuXSAmJiAwID09PSAociA9IGFbbl0ubmFtZSkuaW5kZXhPZihcImRhdGEtXCIpICYmIChyID0gTC5jYW1lbENhc2Uoci5zbGljZSg1KSksIHUobywgciwgaVtyXSkpO1xuICAgICAgICAgICAgICAgICAgICBKLnNldChvLCBcImhhc0RhdGFBdHRyc1wiLCAhMCkgfSByZXR1cm4gaSB9IHJldHVybiBcIm9iamVjdFwiID09IHR5cGVvZiBlID8gdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyBHLnNldCh0aGlzLCBlKSB9KSA6IEsodGhpcywgZnVuY3Rpb24odCkgeyB2YXIgbiwgciA9IEwuY2FtZWxDYXNlKGUpOyBpZiAobyAmJiB2b2lkIDAgPT09IHQpIHsgaWYgKHZvaWQgMCAhPT0gKG4gPSBHLmdldChvLCBlKSkpIHJldHVybiBuOyBpZiAodm9pZCAwICE9PSAobiA9IEcuZ2V0KG8sIHIpKSkgcmV0dXJuIG47IGlmICh2b2lkIDAgIT09IChuID0gdShvLCByLCB2b2lkIDApKSkgcmV0dXJuIG4gfSBlbHNlIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgdmFyIG4gPSBHLmdldCh0aGlzLCByKTtcbiAgICAgICAgICAgICAgICAgICAgRy5zZXQodGhpcywgciwgdCksIC0xICE9PSBlLmluZGV4T2YoXCItXCIpICYmIHZvaWQgMCAhPT0gbiAmJiBHLnNldCh0aGlzLCBlLCB0KSB9KSB9LCBudWxsLCB0LCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgITApIH0sIHJlbW92ZURhdGE6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgRy5yZW1vdmUodGhpcywgZSkgfSkgfSB9KSwgTC5leHRlbmQoeyBxdWV1ZTogZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgcjsgaWYgKGUpIHJldHVybiB0ID0gKHQgfHwgXCJmeFwiKSArIFwicXVldWVcIiwgciA9IEouZ2V0KGUsIHQpLCBuICYmICghciB8fCBMLmlzQXJyYXkobikgPyByID0gSi5hY2Nlc3MoZSwgdCwgTC5tYWtlQXJyYXkobikpIDogci5wdXNoKG4pKSwgciB8fCBbXSB9LCBkZXF1ZXVlOiBmdW5jdGlvbihlLCB0KSB7IHQgPSB0IHx8IFwiZnhcIjsgdmFyIG4gPSBMLnF1ZXVlKGUsIHQpLFxuICAgICAgICAgICAgICAgIHIgPSBuLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpID0gbi5zaGlmdCgpLFxuICAgICAgICAgICAgICAgIG8gPSBMLl9xdWV1ZUhvb2tzKGUsIHQpLFxuICAgICAgICAgICAgICAgIGEgPSBmdW5jdGlvbigpIHsgTC5kZXF1ZXVlKGUsIHQpIH07IFwiaW5wcm9ncmVzc1wiID09PSBpICYmIChpID0gbi5zaGlmdCgpLCByLS0pLCBpICYmIChcImZ4XCIgPT09IHQgJiYgbi51bnNoaWZ0KFwiaW5wcm9ncmVzc1wiKSwgZGVsZXRlIG8uc3RvcCwgaS5jYWxsKGUsIGEsIG8pKSwgIXIgJiYgbyAmJiBvLmVtcHR5LmZpcmUoKSB9LCBfcXVldWVIb29rczogZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiA9IHQgKyBcInF1ZXVlSG9va3NcIjsgcmV0dXJuIEouZ2V0KGUsIG4pIHx8IEouYWNjZXNzKGUsIG4sIHsgZW1wdHk6IEwuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uKCkgeyBKLnJlbW92ZShlLCBbdCArIFwicXVldWVcIiwgbl0pIH0pIH0pIH0gfSksIEwuZm4uZXh0ZW5kKHsgcXVldWU6IGZ1bmN0aW9uKGUsIHQpIHsgdmFyIG4gPSAyOyByZXR1cm4gXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSAmJiAodCA9IGUsIGUgPSBcImZ4XCIsIG4tLSksIGFyZ3VtZW50cy5sZW5ndGggPCBuID8gTC5xdWV1ZSh0aGlzWzBdLCBlKSA6IHZvaWQgMCA9PT0gdCA/IHRoaXMgOiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IHZhciBuID0gTC5xdWV1ZSh0aGlzLCBlLCB0KTtcbiAgICAgICAgICAgICAgICBMLl9xdWV1ZUhvb2tzKHRoaXMsIGUpLCBcImZ4XCIgPT09IGUgJiYgXCJpbnByb2dyZXNzXCIgIT09IG5bMF0gJiYgTC5kZXF1ZXVlKHRoaXMsIGUpIH0pIH0sIGRlcXVldWU6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgTC5kZXF1ZXVlKHRoaXMsIGUpIH0pIH0sIGNsZWFyUXVldWU6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHRoaXMucXVldWUoZSB8fCBcImZ4XCIsIFtdKSB9LCBwcm9taXNlOiBmdW5jdGlvbihlLCB0KSB7IHZhciBuLCByID0gMSxcbiAgICAgICAgICAgICAgICBpID0gTC5EZWZlcnJlZCgpLFxuICAgICAgICAgICAgICAgIG8gPSB0aGlzLFxuICAgICAgICAgICAgICAgIGEgPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBzID0gZnVuY3Rpb24oKSB7LS1yIHx8IGkucmVzb2x2ZVdpdGgobywgW29dKSB9OyBmb3IgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgJiYgKHQgPSBlLCBlID0gdm9pZCAwKSwgZSA9IGUgfHwgXCJmeFwiOyBhLS07KShuID0gSi5nZXQob1thXSwgZSArIFwicXVldWVIb29rc1wiKSkgJiYgbi5lbXB0eSAmJiAocisrLCBuLmVtcHR5LmFkZChzKSk7IHJldHVybiBzKCksIGkucHJvbWlzZSh0KSB9IH0pOyB2YXIgdGUgPSAvXig/OmNoZWNrYm94fHJhZGlvKSQvaTshIGZ1bmN0aW9uKCkgeyB2YXIgZSA9IEUuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLmFwcGVuZENoaWxkKEUuY3JlYXRlRWxlbWVudChcImRpdlwiKSksXG4gICAgICAgICAgICB0ID0gRS5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIHQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInJhZGlvXCIpLCB0LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIpLCB0LnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJ0XCIpLCBlLmFwcGVuZENoaWxkKHQpLCBBLmNoZWNrQ2xvbmUgPSBlLmNsb25lTm9kZSghMCkuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuY2hlY2tlZCwgZS5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIiwgQS5ub0Nsb25lQ2hlY2tlZCA9ICEhZS5jbG9uZU5vZGUoITApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWUgfSgpO1xuICAgIEEuZm9jdXNpbkJ1YmJsZXMgPSBcIm9uZm9jdXNpblwiIGluIGU7IHZhciBuZSA9IC9ea2V5LyxcbiAgICAgICAgcmUgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnUpfGNsaWNrLyxcbiAgICAgICAgaWUgPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG4gICAgICAgIG9lID0gL14oW14uXSopKD86XFwuKC4rKXwpJC87XG4gICAgTC5ldmVudCA9IHsgZ2xvYmFsOiB7fSwgYWRkOiBmdW5jdGlvbihlLCB0LCBuLCByLCBpKSB7IHZhciBvLCBhLCBzLCB1LCBjLCBsLCBmLCBkLCBwLCBoLCB2LCBnID0gSi5nZXQoZSk7IGlmIChnKVxuICAgICAgICAgICAgICAgIGZvciAobi5oYW5kbGVyICYmIChuID0gKG8gPSBuKS5oYW5kbGVyLCBpID0gby5zZWxlY3RvciksIG4uZ3VpZCB8fCAobi5ndWlkID0gTC5ndWlkKyspLCAodSA9IGcuZXZlbnRzKSB8fCAodSA9IGcuZXZlbnRzID0ge30pLCAoYSA9IGcuaGFuZGxlKSB8fCAoYSA9IGcuaGFuZGxlID0gZnVuY3Rpb24odCkgeyByZXR1cm4gdm9pZCAwICE9PSBMICYmIEwuZXZlbnQudHJpZ2dlcmVkICE9PSB0LnR5cGUgPyBMLmV2ZW50LmRpc3BhdGNoLmFwcGx5KGUsIGFyZ3VtZW50cykgOiB2b2lkIDAgfSksIGMgPSAodCA9ICh0IHx8IFwiXCIpLm1hdGNoKFEpIHx8IFtcIlwiXSkubGVuZ3RoOyBjLS07KSBwID0gdiA9IChzID0gb2UuZXhlYyh0W2NdKSB8fCBbXSlbMV0sIGggPSAoc1syXSB8fCBcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLCBwICYmIChmID0gTC5ldmVudC5zcGVjaWFsW3BdIHx8IHt9LCBwID0gKGkgPyBmLmRlbGVnYXRlVHlwZSA6IGYuYmluZFR5cGUpIHx8IHAsIGYgPSBMLmV2ZW50LnNwZWNpYWxbcF0gfHwge30sIGwgPSBMLmV4dGVuZCh7IHR5cGU6IHAsIG9yaWdUeXBlOiB2LCBkYXRhOiByLCBoYW5kbGVyOiBuLCBndWlkOiBuLmd1aWQsIHNlbGVjdG9yOiBpLCBuZWVkc0NvbnRleHQ6IGkgJiYgTC5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KGkpLCBuYW1lc3BhY2U6IGguam9pbihcIi5cIikgfSwgbyksIChkID0gdVtwXSkgfHwgKChkID0gdVtwXSA9IFtdKS5kZWxlZ2F0ZUNvdW50ID0gMCwgZi5zZXR1cCAmJiAhMSAhPT0gZi5zZXR1cC5jYWxsKGUsIHIsIGgsIGEpIHx8IGUuYWRkRXZlbnRMaXN0ZW5lciAmJiBlLmFkZEV2ZW50TGlzdGVuZXIocCwgYSwgITEpKSwgZi5hZGQgJiYgKGYuYWRkLmNhbGwoZSwgbCksIGwuaGFuZGxlci5ndWlkIHx8IChsLmhhbmRsZXIuZ3VpZCA9IG4uZ3VpZCkpLCBpID8gZC5zcGxpY2UoZC5kZWxlZ2F0ZUNvdW50KyssIDAsIGwpIDogZC5wdXNoKGwpLCBMLmV2ZW50Lmdsb2JhbFtwXSA9ICEwKSB9LCByZW1vdmU6IGZ1bmN0aW9uKGUsIHQsIG4sIHIsIGkpIHsgdmFyIG8sIGEsIHMsIHUsIGMsIGwsIGYsIGQsIHAsIGgsIHYsIGcgPSBKLmhhc0RhdGEoZSkgJiYgSi5nZXQoZSk7IGlmIChnICYmICh1ID0gZy5ldmVudHMpKSB7IGZvciAoYyA9ICh0ID0gKHQgfHwgXCJcIikubWF0Y2goUSkgfHwgW1wiXCJdKS5sZW5ndGg7IGMtLTspXG4gICAgICAgICAgICAgICAgICAgIGlmIChzID0gb2UuZXhlYyh0W2NdKSB8fCBbXSwgcCA9IHYgPSBzWzFdLCBoID0gKHNbMl0gfHwgXCJcIikuc3BsaXQoXCIuXCIpLnNvcnQoKSwgcCkgeyBmb3IgKGYgPSBMLmV2ZW50LnNwZWNpYWxbcF0gfHwge30sIGQgPSB1W3AgPSAociA/IGYuZGVsZWdhdGVUeXBlIDogZi5iaW5kVHlwZSkgfHwgcF0gfHwgW10sIHMgPSBzWzJdICYmIG5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIiArIGguam9pbihcIlxcXFwuKD86LipcXFxcLnwpXCIpICsgXCIoXFxcXC58JClcIiksIGEgPSBvID0gZC5sZW5ndGg7IG8tLTspIGwgPSBkW29dLCAhaSAmJiB2ICE9PSBsLm9yaWdUeXBlIHx8IG4gJiYgbi5ndWlkICE9PSBsLmd1aWQgfHwgcyAmJiAhcy50ZXN0KGwubmFtZXNwYWNlKSB8fCByICYmIHIgIT09IGwuc2VsZWN0b3IgJiYgKFwiKipcIiAhPT0gciB8fCAhbC5zZWxlY3RvcikgfHwgKGQuc3BsaWNlKG8sIDEpLCBsLnNlbGVjdG9yICYmIGQuZGVsZWdhdGVDb3VudC0tLCBmLnJlbW92ZSAmJiBmLnJlbW92ZS5jYWxsKGUsIGwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgJiYgIWQubGVuZ3RoICYmIChmLnRlYXJkb3duICYmICExICE9PSBmLnRlYXJkb3duLmNhbGwoZSwgaCwgZy5oYW5kbGUpIHx8IEwucmVtb3ZlRXZlbnQoZSwgcCwgZy5oYW5kbGUpLCBkZWxldGUgdVtwXSkgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHAgaW4gdSkgTC5ldmVudC5yZW1vdmUoZSwgcCArIHRbY10sIG4sIHIsICEwKTtcbiAgICAgICAgICAgICAgICBMLmlzRW1wdHlPYmplY3QodSkgJiYgKGRlbGV0ZSBnLmhhbmRsZSwgSi5yZW1vdmUoZSwgXCJldmVudHNcIikpIH0gfSwgdHJpZ2dlcjogZnVuY3Rpb24odCwgbiwgciwgaSkgeyB2YXIgbywgYSwgcywgdSwgYywgbCwgZiwgZCA9IFtyIHx8IEVdLFxuICAgICAgICAgICAgICAgIHAgPSBqLmNhbGwodCwgXCJ0eXBlXCIpID8gdC50eXBlIDogdCxcbiAgICAgICAgICAgICAgICBoID0gai5jYWxsKHQsIFwibmFtZXNwYWNlXCIpID8gdC5uYW1lc3BhY2Uuc3BsaXQoXCIuXCIpIDogW107IGlmIChhID0gcyA9IHIgPSByIHx8IEUsIDMgIT09IHIubm9kZVR5cGUgJiYgOCAhPT0gci5ub2RlVHlwZSAmJiAhaWUudGVzdChwICsgTC5ldmVudC50cmlnZ2VyZWQpICYmIChwLmluZGV4T2YoXCIuXCIpID49IDAgJiYgKHAgPSAoaCA9IHAuc3BsaXQoXCIuXCIpKS5zaGlmdCgpLCBoLnNvcnQoKSksIGMgPSBwLmluZGV4T2YoXCI6XCIpIDwgMCAmJiBcIm9uXCIgKyBwLCB0ID0gdFtMLmV4cGFuZG9dID8gdCA6IG5ldyBMLkV2ZW50KHAsIFwib2JqZWN0XCIgPT0gdHlwZW9mIHQgJiYgdCksIHQuaXNUcmlnZ2VyID0gaSA/IDIgOiAzLCB0Lm5hbWVzcGFjZSA9IGguam9pbihcIi5cIiksIHQubmFtZXNwYWNlX3JlID0gdC5uYW1lc3BhY2UgPyBuZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIgKyBoLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIpIDogbnVsbCwgdC5yZXN1bHQgPSB2b2lkIDAsIHQudGFyZ2V0IHx8ICh0LnRhcmdldCA9IHIpLCBuID0gbnVsbCA9PSBuID8gW3RdIDogTC5tYWtlQXJyYXkobiwgW3RdKSwgZiA9IEwuZXZlbnQuc3BlY2lhbFtwXSB8fCB7fSwgaSB8fCAhZi50cmlnZ2VyIHx8ICExICE9PSBmLnRyaWdnZXIuYXBwbHkociwgbikpKSB7IGlmICghaSAmJiAhZi5ub0J1YmJsZSAmJiAhTC5pc1dpbmRvdyhyKSkgeyBmb3IgKHUgPSBmLmRlbGVnYXRlVHlwZSB8fCBwLCBpZS50ZXN0KHUgKyBwKSB8fCAoYSA9IGEucGFyZW50Tm9kZSk7IGE7IGEgPSBhLnBhcmVudE5vZGUpIGQucHVzaChhKSwgcyA9IGE7XG4gICAgICAgICAgICAgICAgICAgIHMgPT09IChyLm93bmVyRG9jdW1lbnQgfHwgRSkgJiYgZC5wdXNoKHMuZGVmYXVsdFZpZXcgfHwgcy5wYXJlbnRXaW5kb3cgfHwgZSkgfSBmb3IgKG8gPSAwO1xuICAgICAgICAgICAgICAgICAgICAoYSA9IGRbbysrXSkgJiYgIXQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTspIHQudHlwZSA9IG8gPiAxID8gdSA6IGYuYmluZFR5cGUgfHwgcCwgKGwgPSAoSi5nZXQoYSwgXCJldmVudHNcIikgfHwge30pW3QudHlwZV0gJiYgSi5nZXQoYSwgXCJoYW5kbGVcIikpICYmIGwuYXBwbHkoYSwgbiksIChsID0gYyAmJiBhW2NdKSAmJiBsLmFwcGx5ICYmIEwuYWNjZXB0RGF0YShhKSAmJiAodC5yZXN1bHQgPSBsLmFwcGx5KGEsIG4pLCAhMSA9PT0gdC5yZXN1bHQgJiYgdC5wcmV2ZW50RGVmYXVsdCgpKTsgcmV0dXJuIHQudHlwZSA9IHAsIGkgfHwgdC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSB8fCBmLl9kZWZhdWx0ICYmICExICE9PSBmLl9kZWZhdWx0LmFwcGx5KGQucG9wKCksIG4pIHx8ICFMLmFjY2VwdERhdGEocikgfHwgYyAmJiBMLmlzRnVuY3Rpb24ocltwXSkgJiYgIUwuaXNXaW5kb3cocikgJiYgKChzID0gcltjXSkgJiYgKHJbY10gPSBudWxsKSwgTC5ldmVudC50cmlnZ2VyZWQgPSBwLCByW3BdKCksIEwuZXZlbnQudHJpZ2dlcmVkID0gdm9pZCAwLCBzICYmIChyW2NdID0gcykpLCB0LnJlc3VsdCB9IH0sIGRpc3BhdGNoOiBmdW5jdGlvbihlKSB7IGUgPSBMLmV2ZW50LmZpeChlKTsgdmFyIHQsIG4sIHIsIGksIG8sIGEgPSBbXSxcbiAgICAgICAgICAgICAgICBzID0gay5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgdSA9IChKLmdldCh0aGlzLCBcImV2ZW50c1wiKSB8fCB7fSlbZS50eXBlXSB8fCBbXSxcbiAgICAgICAgICAgICAgICBjID0gTC5ldmVudC5zcGVjaWFsW2UudHlwZV0gfHwge307IGlmIChzWzBdID0gZSwgZS5kZWxlZ2F0ZVRhcmdldCA9IHRoaXMsICFjLnByZURpc3BhdGNoIHx8ICExICE9PSBjLnByZURpc3BhdGNoLmNhbGwodGhpcywgZSkpIHsgZm9yIChhID0gTC5ldmVudC5oYW5kbGVycy5jYWxsKHRoaXMsIGUsIHUpLCB0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgKGkgPSBhW3QrK10pICYmICFlLmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7KVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGUuY3VycmVudFRhcmdldCA9IGkuZWxlbSwgbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAobyA9IGkuaGFuZGxlcnNbbisrXSkgJiYgIWUuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKTspIGUubmFtZXNwYWNlX3JlICYmICFlLm5hbWVzcGFjZV9yZS50ZXN0KG8ubmFtZXNwYWNlKSB8fCAoZS5oYW5kbGVPYmogPSBvLCBlLmRhdGEgPSBvLmRhdGEsIHZvaWQgMCAhPT0gKHIgPSAoKEwuZXZlbnQuc3BlY2lhbFtvLm9yaWdUeXBlXSB8fCB7fSkuaGFuZGxlIHx8IG8uaGFuZGxlcikuYXBwbHkoaS5lbGVtLCBzKSkgJiYgITEgPT09IChlLnJlc3VsdCA9IHIpICYmIChlLnByZXZlbnREZWZhdWx0KCksIGUuc3RvcFByb3BhZ2F0aW9uKCkpKTsgcmV0dXJuIGMucG9zdERpc3BhdGNoICYmIGMucG9zdERpc3BhdGNoLmNhbGwodGhpcywgZSksIGUucmVzdWx0IH0gfSwgaGFuZGxlcnM6IGZ1bmN0aW9uKGUsIHQpIHsgdmFyIG4sIHIsIGksIG8sIGEgPSBbXSxcbiAgICAgICAgICAgICAgICBzID0gdC5kZWxlZ2F0ZUNvdW50LFxuICAgICAgICAgICAgICAgIHUgPSBlLnRhcmdldDsgaWYgKHMgJiYgdS5ub2RlVHlwZSAmJiAoIWUuYnV0dG9uIHx8IFwiY2xpY2tcIiAhPT0gZS50eXBlKSlcbiAgICAgICAgICAgICAgICBmb3IgKDsgdSAhPT0gdGhpczsgdSA9IHUucGFyZW50Tm9kZSB8fCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICBpZiAoITAgIT09IHUuZGlzYWJsZWQgfHwgXCJjbGlja1wiICE9PSBlLnR5cGUpIHsgZm9yIChyID0gW10sIG4gPSAwOyBuIDwgczsgbisrKSB2b2lkIDAgPT09IHJbaSA9IChvID0gdFtuXSkuc2VsZWN0b3IgKyBcIiBcIl0gJiYgKHJbaV0gPSBvLm5lZWRzQ29udGV4dCA/IEwoaSwgdGhpcykuaW5kZXgodSkgPj0gMCA6IEwuZmluZChpLCB0aGlzLCBudWxsLCBbdV0pLmxlbmd0aCksIHJbaV0gJiYgci5wdXNoKG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgci5sZW5ndGggJiYgYS5wdXNoKHsgZWxlbTogdSwgaGFuZGxlcnM6IHIgfSkgfSByZXR1cm4gcyA8IHQubGVuZ3RoICYmIGEucHVzaCh7IGVsZW06IHRoaXMsIGhhbmRsZXJzOiB0LnNsaWNlKHMpIH0pLCBhIH0sIHByb3BzOiBcImFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGV2ZW50UGhhc2UgbWV0YUtleSByZWxhdGVkVGFyZ2V0IHNoaWZ0S2V5IHRhcmdldCB0aW1lU3RhbXAgdmlldyB3aGljaFwiLnNwbGl0KFwiIFwiKSwgZml4SG9va3M6IHt9LCBrZXlIb29rczogeyBwcm9wczogXCJjaGFyIGNoYXJDb2RlIGtleSBrZXlDb2RlXCIuc3BsaXQoXCIgXCIpLCBmaWx0ZXI6IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIG51bGwgPT0gZS53aGljaCAmJiAoZS53aGljaCA9IG51bGwgIT0gdC5jaGFyQ29kZSA/IHQuY2hhckNvZGUgOiB0LmtleUNvZGUpLCBlIH0gfSwgbW91c2VIb29rczogeyBwcm9wczogXCJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIHNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIi5zcGxpdChcIiBcIiksIGZpbHRlcjogZnVuY3Rpb24oZSwgdCkgeyB2YXIgbiwgciwgaSwgbyA9IHQuYnV0dG9uOyByZXR1cm4gbnVsbCA9PSBlLnBhZ2VYICYmIG51bGwgIT0gdC5jbGllbnRYICYmIChyID0gKG4gPSBlLnRhcmdldC5vd25lckRvY3VtZW50IHx8IEUpLmRvY3VtZW50RWxlbWVudCwgaSA9IG4uYm9keSwgZS5wYWdlWCA9IHQuY2xpZW50WCArIChyICYmIHIuc2Nyb2xsTGVmdCB8fCBpICYmIGkuc2Nyb2xsTGVmdCB8fCAwKSAtIChyICYmIHIuY2xpZW50TGVmdCB8fCBpICYmIGkuY2xpZW50TGVmdCB8fCAwKSwgZS5wYWdlWSA9IHQuY2xpZW50WSArIChyICYmIHIuc2Nyb2xsVG9wIHx8IGkgJiYgaS5zY3JvbGxUb3AgfHwgMCkgLSAociAmJiByLmNsaWVudFRvcCB8fCBpICYmIGkuY2xpZW50VG9wIHx8IDApKSwgZS53aGljaCB8fCB2b2lkIDAgPT09IG8gfHwgKGUud2hpY2ggPSAxICYgbyA/IDEgOiAyICYgbyA/IDMgOiA0ICYgbyA/IDIgOiAwKSwgZSB9IH0sIGZpeDogZnVuY3Rpb24oZSkgeyBpZiAoZVtMLmV4cGFuZG9dKSByZXR1cm4gZTsgdmFyIHQsIG4sIHIsIGkgPSBlLnR5cGUsXG4gICAgICAgICAgICAgICAgbyA9IGUsXG4gICAgICAgICAgICAgICAgYSA9IHRoaXMuZml4SG9va3NbaV07IGZvciAoYSB8fCAodGhpcy5maXhIb29rc1tpXSA9IGEgPSByZS50ZXN0KGkpID8gdGhpcy5tb3VzZUhvb2tzIDogbmUudGVzdChpKSA/IHRoaXMua2V5SG9va3MgOiB7fSksIHIgPSBhLnByb3BzID8gdGhpcy5wcm9wcy5jb25jYXQoYS5wcm9wcykgOiB0aGlzLnByb3BzLCBlID0gbmV3IEwuRXZlbnQobyksIHQgPSByLmxlbmd0aDsgdC0tOykgZVtuID0gclt0XV0gPSBvW25dOyByZXR1cm4gZS50YXJnZXQgfHwgKGUudGFyZ2V0ID0gRSksIDMgPT09IGUudGFyZ2V0Lm5vZGVUeXBlICYmIChlLnRhcmdldCA9IGUudGFyZ2V0LnBhcmVudE5vZGUpLCBhLmZpbHRlciA/IGEuZmlsdGVyKGUsIG8pIDogZSB9LCBzcGVjaWFsOiB7IGxvYWQ6IHsgbm9CdWJibGU6ICEwIH0sIGZvY3VzOiB7IHRyaWdnZXI6IGZ1bmN0aW9uKCkgeyBpZiAodGhpcyAhPT0gZigpICYmIHRoaXMuZm9jdXMpIHJldHVybiB0aGlzLmZvY3VzKCksICExIH0sIGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCIgfSwgYmx1cjogeyB0cmlnZ2VyOiBmdW5jdGlvbigpIHsgaWYgKHRoaXMgPT09IGYoKSAmJiB0aGlzLmJsdXIpIHJldHVybiB0aGlzLmJsdXIoKSwgITEgfSwgZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCIgfSwgY2xpY2s6IHsgdHJpZ2dlcjogZnVuY3Rpb24oKSB7IGlmIChcImNoZWNrYm94XCIgPT09IHRoaXMudHlwZSAmJiB0aGlzLmNsaWNrICYmIEwubm9kZU5hbWUodGhpcywgXCJpbnB1dFwiKSkgcmV0dXJuIHRoaXMuY2xpY2soKSwgITEgfSwgX2RlZmF1bHQ6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIEwubm9kZU5hbWUoZS50YXJnZXQsIFwiYVwiKSB9IH0sIGJlZm9yZXVubG9hZDogeyBwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKGUpIHsgdm9pZCAwICE9PSBlLnJlc3VsdCAmJiBlLm9yaWdpbmFsRXZlbnQgJiYgKGUub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGUucmVzdWx0KSB9IH0gfSwgc2ltdWxhdGU6IGZ1bmN0aW9uKGUsIHQsIG4sIHIpIHsgdmFyIGkgPSBMLmV4dGVuZChuZXcgTC5FdmVudCwgbiwgeyB0eXBlOiBlLCBpc1NpbXVsYXRlZDogITAsIG9yaWdpbmFsRXZlbnQ6IHt9IH0pO1xuICAgICAgICAgICAgciA/IEwuZXZlbnQudHJpZ2dlcihpLCBudWxsLCB0KSA6IEwuZXZlbnQuZGlzcGF0Y2guY2FsbCh0LCBpKSwgaS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSAmJiBuLnByZXZlbnREZWZhdWx0KCkgfSB9LCBMLnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oZSwgdCwgbikgeyBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiYgZS5yZW1vdmVFdmVudExpc3RlbmVyKHQsIG4sICExKSB9LCBMLkV2ZW50ID0gZnVuY3Rpb24oZSwgdCkgeyBpZiAoISh0aGlzIGluc3RhbmNlb2YgTC5FdmVudCkpIHJldHVybiBuZXcgTC5FdmVudChlLCB0KTtcbiAgICAgICAgZSAmJiBlLnR5cGUgPyAodGhpcy5vcmlnaW5hbEV2ZW50ID0gZSwgdGhpcy50eXBlID0gZS50eXBlLCB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGUuZGVmYXVsdFByZXZlbnRlZCB8fCB2b2lkIDAgPT09IGUuZGVmYXVsdFByZXZlbnRlZCAmJiAhMSA9PT0gZS5yZXR1cm5WYWx1ZSA/IGMgOiBsKSA6IHRoaXMudHlwZSA9IGUsIHQgJiYgTC5leHRlbmQodGhpcywgdCksIHRoaXMudGltZVN0YW1wID0gZSAmJiBlLnRpbWVTdGFtcCB8fCBMLm5vdygpLCB0aGlzW0wuZXhwYW5kb10gPSAhMCB9LCBMLkV2ZW50LnByb3RvdHlwZSA9IHsgaXNEZWZhdWx0UHJldmVudGVkOiBsLCBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogbCwgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IGwsIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHsgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGMsIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCAmJiBlLnByZXZlbnREZWZhdWx0KCkgfSwgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHsgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gYywgZSAmJiBlLnN0b3BQcm9wYWdhdGlvbiAmJiBlLnN0b3BQcm9wYWdhdGlvbigpIH0sIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7IHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IGMsIGUgJiYgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gJiYgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgdGhpcy5zdG9wUHJvcGFnYXRpb24oKSB9IH0sIEwuZWFjaCh7IG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIiwgcG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsIHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCIgfSwgZnVuY3Rpb24oZSwgdCkgeyBMLmV2ZW50LnNwZWNpYWxbZV0gPSB7IGRlbGVnYXRlVHlwZTogdCwgYmluZFR5cGU6IHQsIGhhbmRsZTogZnVuY3Rpb24oZSkgeyB2YXIgbiwgciA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGkgPSBlLnJlbGF0ZWRUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIG8gPSBlLmhhbmRsZU9iajsgcmV0dXJuIGkgJiYgKGkgPT09IHIgfHwgTC5jb250YWlucyhyLCBpKSkgfHwgKGUudHlwZSA9IG8ub3JpZ1R5cGUsIG4gPSBvLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgZS50eXBlID0gdCksIG4gfSB9IH0pLCBBLmZvY3VzaW5CdWJibGVzIHx8IEwuZWFjaCh7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKGUsIHQpIHsgdmFyIG4gPSBmdW5jdGlvbihlKSB7IEwuZXZlbnQuc2ltdWxhdGUodCwgZS50YXJnZXQsIEwuZXZlbnQuZml4KGUpLCAhMCkgfTtcbiAgICAgICAgTC5ldmVudC5zcGVjaWFsW3RdID0geyBzZXR1cDogZnVuY3Rpb24oKSB7IHZhciByID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGkgPSBKLmFjY2VzcyhyLCB0KTtcbiAgICAgICAgICAgICAgICBpIHx8IHIuYWRkRXZlbnRMaXN0ZW5lcihlLCBuLCAhMCksIEouYWNjZXNzKHIsIHQsIChpIHx8IDApICsgMSkgfSwgdGVhcmRvd246IGZ1bmN0aW9uKCkgeyB2YXIgciA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBpID0gSi5hY2Nlc3MociwgdCkgLSAxO1xuICAgICAgICAgICAgICAgIGkgPyBKLmFjY2VzcyhyLCB0LCBpKSA6IChyLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgbiwgITApLCBKLnJlbW92ZShyLCB0KSkgfSB9IH0pLCBMLmZuLmV4dGVuZCh7IG9uOiBmdW5jdGlvbihlLCB0LCBuLCByLCBpKSB7IHZhciBvLCBhOyBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSkgeyBcInN0cmluZ1wiICE9IHR5cGVvZiB0ICYmIChuID0gbiB8fCB0LCB0ID0gdm9pZCAwKTsgZm9yIChhIGluIGUpIHRoaXMub24oYSwgdCwgbiwgZVthXSwgaSk7IHJldHVybiB0aGlzIH0gaWYgKG51bGwgPT0gbiAmJiBudWxsID09IHIgPyAociA9IHQsIG4gPSB0ID0gdm9pZCAwKSA6IG51bGwgPT0gciAmJiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCA/IChyID0gbiwgbiA9IHZvaWQgMCkgOiAociA9IG4sIG4gPSB0LCB0ID0gdm9pZCAwKSksICExID09PSByKSByID0gbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFyKSByZXR1cm4gdGhpczsgcmV0dXJuIDEgPT09IGkgJiYgKG8gPSByLCAociA9IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIEwoKS5vZmYoZSksIG8uYXBwbHkodGhpcywgYXJndW1lbnRzKSB9KS5ndWlkID0gby5ndWlkIHx8IChvLmd1aWQgPSBMLmd1aWQrKykpLCB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IEwuZXZlbnQuYWRkKHRoaXMsIGUsIHIsIG4sIHQpIH0pIH0sIG9uZTogZnVuY3Rpb24oZSwgdCwgbiwgcikgeyByZXR1cm4gdGhpcy5vbihlLCB0LCBuLCByLCAxKSB9LCBvZmY6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgdmFyIHIsIGk7IGlmIChlICYmIGUucHJldmVudERlZmF1bHQgJiYgZS5oYW5kbGVPYmopIHJldHVybiByID0gZS5oYW5kbGVPYmosIEwoZS5kZWxlZ2F0ZVRhcmdldCkub2ZmKHIubmFtZXNwYWNlID8gci5vcmlnVHlwZSArIFwiLlwiICsgci5uYW1lc3BhY2UgOiByLm9yaWdUeXBlLCByLnNlbGVjdG9yLCByLmhhbmRsZXIpLCB0aGlzOyBpZiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSkgeyBmb3IgKGkgaW4gZSkgdGhpcy5vZmYoaSwgdCwgZVtpXSk7IHJldHVybiB0aGlzIH0gcmV0dXJuICExICE9PSB0ICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgdCB8fCAobiA9IHQsIHQgPSB2b2lkIDApLCAhMSA9PT0gbiAmJiAobiA9IGwpLCB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IEwuZXZlbnQucmVtb3ZlKHRoaXMsIGUsIG4sIHQpIH0pIH0sIHRyaWdnZXI6IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgTC5ldmVudC50cmlnZ2VyKGUsIHQsIHRoaXMpIH0pIH0sIHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbihlLCB0KSB7IHZhciBuID0gdGhpc1swXTsgaWYgKG4pIHJldHVybiBMLmV2ZW50LnRyaWdnZXIoZSwgdCwgbiwgITApIH0gfSk7IHZhciBhZSA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcXHc6XSspW14+XSopXFwvPi9naSxcbiAgICAgICAgc2UgPSAvPChbXFx3Ol0rKS8sXG4gICAgICAgIHVlID0gLzx8JiM/XFx3KzsvLFxuICAgICAgICBjZSA9IC88KD86c2NyaXB0fHN0eWxlfGxpbmspL2ksXG4gICAgICAgIGxlID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcbiAgICAgICAgZmUgPSAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pLFxuICAgICAgICBkZSA9IC9edHJ1ZVxcLyguKikvLFxuICAgICAgICBwZSA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZyxcbiAgICAgICAgaGUgPSB7IG9wdGlvbjogWzEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiXSwgdGhlYWQ6IFsxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiXSwgY29sOiBbMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIl0sIHRyOiBbMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIl0sIHRkOiBbMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIl0sIF9kZWZhdWx0OiBbMCwgXCJcIiwgXCJcIl0gfTtcbiAgICBoZS5vcHRncm91cCA9IGhlLm9wdGlvbiwgaGUudGJvZHkgPSBoZS50Zm9vdCA9IGhlLmNvbGdyb3VwID0gaGUuY2FwdGlvbiA9IGhlLnRoZWFkLCBoZS50aCA9IGhlLnRkLCBMLmV4dGVuZCh7IGNsb25lOiBmdW5jdGlvbihlLCB0LCBuKSB7IHZhciByLCBpLCBvLCBhLCBzID0gZS5jbG9uZU5vZGUoITApLFxuICAgICAgICAgICAgICAgICAgICB1ID0gTC5jb250YWlucyhlLm93bmVyRG9jdW1lbnQsIGUpOyBpZiAoIShBLm5vQ2xvbmVDaGVja2VkIHx8IDEgIT09IGUubm9kZVR5cGUgJiYgMTEgIT09IGUubm9kZVR5cGUgfHwgTC5pc1hNTERvYyhlKSkpXG4gICAgICAgICAgICAgICAgICAgIGZvciAoYSA9IG0ocyksIHIgPSAwLCBpID0gKG8gPSBtKGUpKS5sZW5ndGg7IHIgPCBpOyByKyspIHkob1tyXSwgYVtyXSk7IGlmICh0KVxuICAgICAgICAgICAgICAgICAgICBpZiAobilcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobyA9IG8gfHwgbShlKSwgYSA9IGEgfHwgbShzKSwgciA9IDAsIGkgPSBvLmxlbmd0aDsgciA8IGk7IHIrKykgZyhvW3JdLCBhW3JdKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBnKGUsIHMpOyByZXR1cm4gKGEgPSBtKHMsIFwic2NyaXB0XCIpKS5sZW5ndGggPiAwICYmIHYoYSwgIXUgJiYgbShlLCBcInNjcmlwdFwiKSksIHMgfSwgYnVpbGRGcmFnbWVudDogZnVuY3Rpb24oZSwgdCwgbiwgcikgeyBmb3IgKHZhciBpLCBvLCBhLCBzLCB1LCBjLCBsID0gdC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIGYgPSBbXSwgZCA9IDAsIHAgPSBlLmxlbmd0aDsgZCA8IHA7IGQrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKChpID0gZVtkXSkgfHwgMCA9PT0gaSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSBMLnR5cGUoaSkpIEwubWVyZ2UoZiwgaS5ub2RlVHlwZSA/IFtpXSA6IGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodWUudGVzdChpKSkgeyBmb3IgKG8gPSBvIHx8IGwuYXBwZW5kQ2hpbGQodC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSwgYSA9IChzZS5leGVjKGkpIHx8IFtcIlwiLCBcIlwiXSlbMV0udG9Mb3dlckNhc2UoKSwgcyA9IGhlW2FdIHx8IGhlLl9kZWZhdWx0LCBvLmlubmVySFRNTCA9IHNbMV0gKyBpLnJlcGxhY2UoYWUsIFwiPCQxPjwvJDI+XCIpICsgc1syXSwgYyA9IHNbMF07IGMtLTspIG8gPSBvLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgTC5tZXJnZShmLCBvLmNoaWxkTm9kZXMpLCAobyA9IGwuZmlyc3RDaGlsZCkudGV4dENvbnRlbnQgPSBcIlwiIH0gZWxzZSBmLnB1c2godC5jcmVhdGVUZXh0Tm9kZShpKSk7IGZvciAobC50ZXh0Q29udGVudCA9IFwiXCIsIGQgPSAwOyBpID0gZltkKytdOylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCghciB8fCAtMSA9PT0gTC5pbkFycmF5KGksIHIpKSAmJiAodSA9IEwuY29udGFpbnMoaS5vd25lckRvY3VtZW50LCBpKSwgbyA9IG0obC5hcHBlbmRDaGlsZChpKSwgXCJzY3JpcHRcIiksIHUgJiYgdihvKSwgbikpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGMgPSAwOyBpID0gb1tjKytdOykgZmUudGVzdChpLnR5cGUgfHwgXCJcIikgJiYgbi5wdXNoKGkpOyByZXR1cm4gbCB9LCBjbGVhbkRhdGE6IGZ1bmN0aW9uKGUpIHsgZm9yICh2YXIgdCwgbiwgciwgaSwgbyA9IEwuZXZlbnQuc3BlY2lhbCwgYSA9IDA7IHZvaWQgMCAhPT0gKG4gPSBlW2FdKTsgYSsrKSB7IGlmIChMLmFjY2VwdERhdGEobikgJiYgKGkgPSBuW0ouZXhwYW5kb10pICYmICh0ID0gSi5jYWNoZVtpXSkpIHsgaWYgKHQuZXZlbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAociBpbiB0LmV2ZW50cykgb1tyXSA/IEwuZXZlbnQucmVtb3ZlKG4sIHIpIDogTC5yZW1vdmVFdmVudChuLCByLCB0LmhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBKLmNhY2hlW2ldICYmIGRlbGV0ZSBKLmNhY2hlW2ldIH0gZGVsZXRlIEcuY2FjaGVbbltHLmV4cGFuZG9dXSB9IH0gfSksIEwuZm4uZXh0ZW5kKHsgdGV4dDogZnVuY3Rpb24oZSkgeyByZXR1cm4gSyh0aGlzLCBmdW5jdGlvbihlKSB7IHJldHVybiB2b2lkIDAgPT09IGUgPyBMLnRleHQodGhpcykgOiB0aGlzLmVtcHR5KCkuZWFjaChmdW5jdGlvbigpIHsgMSAhPT0gdGhpcy5ub2RlVHlwZSAmJiAxMSAhPT0gdGhpcy5ub2RlVHlwZSAmJiA5ICE9PSB0aGlzLm5vZGVUeXBlIHx8ICh0aGlzLnRleHRDb250ZW50ID0gZSkgfSkgfSwgbnVsbCwgZSwgYXJndW1lbnRzLmxlbmd0aCkgfSwgYXBwZW5kOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmdW5jdGlvbihlKSB7IDEgIT09IHRoaXMubm9kZVR5cGUgJiYgMTEgIT09IHRoaXMubm9kZVR5cGUgJiYgOSAhPT0gdGhpcy5ub2RlVHlwZSB8fCBkKHRoaXMsIGUpLmFwcGVuZENoaWxkKGUpIH0pIH0sIHByZXBlbmQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIGZ1bmN0aW9uKGUpIHsgaWYgKDEgPT09IHRoaXMubm9kZVR5cGUgfHwgMTEgPT09IHRoaXMubm9kZVR5cGUgfHwgOSA9PT0gdGhpcy5ub2RlVHlwZSkgeyB2YXIgdCA9IGQodGhpcywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0Lmluc2VydEJlZm9yZShlLCB0LmZpcnN0Q2hpbGQpIH0gfSkgfSwgYmVmb3JlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmdW5jdGlvbihlKSB7IHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsIHRoaXMpIH0pIH0sIGFmdGVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmdW5jdGlvbihlKSB7IHRoaXMucGFyZW50Tm9kZSAmJiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGUsIHRoaXMubmV4dFNpYmxpbmcpIH0pIH0sIHJlbW92ZTogZnVuY3Rpb24oZSwgdCkgeyBmb3IgKHZhciBuLCByID0gZSA/IEwuZmlsdGVyKGUsIHRoaXMpIDogdGhpcywgaSA9IDA7IG51bGwgIT0gKG4gPSByW2ldKTsgaSsrKSB0IHx8IDEgIT09IG4ubm9kZVR5cGUgfHwgTC5jbGVhbkRhdGEobShuKSksIG4ucGFyZW50Tm9kZSAmJiAodCAmJiBMLmNvbnRhaW5zKG4ub3duZXJEb2N1bWVudCwgbikgJiYgdihtKG4sIFwic2NyaXB0XCIpKSwgbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG4pKTsgcmV0dXJuIHRoaXMgfSwgZW1wdHk6IGZ1bmN0aW9uKCkgeyBmb3IgKHZhciBlLCB0ID0gMDsgbnVsbCAhPSAoZSA9IHRoaXNbdF0pOyB0KyspIDEgPT09IGUubm9kZVR5cGUgJiYgKEwuY2xlYW5EYXRhKG0oZSwgITEpKSwgZS50ZXh0Q29udGVudCA9IFwiXCIpOyByZXR1cm4gdGhpcyB9LCBjbG9uZTogZnVuY3Rpb24oZSwgdCkgeyByZXR1cm4gZSA9IG51bGwgIT0gZSAmJiBlLCB0ID0gbnVsbCA9PSB0ID8gZSA6IHQsIHRoaXMubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gTC5jbG9uZSh0aGlzLCBlLCB0KSB9KSB9LCBodG1sOiBmdW5jdGlvbihlKSB7IHJldHVybiBLKHRoaXMsIGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSB0aGlzWzBdIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gdGhpcy5sZW5ndGg7IGlmICh2b2lkIDAgPT09IGUgJiYgMSA9PT0gdC5ub2RlVHlwZSkgcmV0dXJuIHQuaW5uZXJIVE1MOyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSAmJiAhY2UudGVzdChlKSAmJiAhaGVbKHNlLmV4ZWMoZSkgfHwgW1wiXCIsIFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpXSkgeyBlID0gZS5yZXBsYWNlKGFlLCBcIjwkMT48LyQyPlwiKTsgdHJ5IHsgZm9yICg7IG4gPCByOyBuKyspIDEgPT09ICh0ID0gdGhpc1tuXSB8fCB7fSkubm9kZVR5cGUgJiYgKEwuY2xlYW5EYXRhKG0odCwgITEpKSwgdC5pbm5lckhUTUwgPSBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gMCB9IGNhdGNoIChlKSB7fSB9IHQgJiYgdGhpcy5lbXB0eSgpLmFwcGVuZChlKSB9LCBudWxsLCBlLCBhcmd1bWVudHMubGVuZ3RoKSB9LCByZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7IHZhciBlID0gYXJndW1lbnRzWzBdOyByZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIGZ1bmN0aW9uKHQpIHsgZSA9IHRoaXMucGFyZW50Tm9kZSwgTC5jbGVhbkRhdGEobSh0aGlzKSksIGUgJiYgZS5yZXBsYWNlQ2hpbGQodCwgdGhpcykgfSksIGUgJiYgKGUubGVuZ3RoIHx8IGUubm9kZVR5cGUpID8gdGhpcyA6IHRoaXMucmVtb3ZlKCkgfSwgZGV0YWNoOiBmdW5jdGlvbihlKSB7IHJldHVybiB0aGlzLnJlbW92ZShlLCAhMCkgfSwgZG9tTWFuaXA6IGZ1bmN0aW9uKGUsIHQpIHsgZSA9IFQuYXBwbHkoW10sIGUpOyB2YXIgbiwgciwgaSwgbywgYSwgcywgdSA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGMgPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgbCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGYgPSBjIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgZCA9IGVbMF0sXG4gICAgICAgICAgICAgICAgICAgIHYgPSBMLmlzRnVuY3Rpb24oZCk7IGlmICh2IHx8IGMgPiAxICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGQgJiYgIUEuY2hlY2tDbG9uZSAmJiBsZS50ZXN0KGQpKSByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKG4pIHsgdmFyIHIgPSBsLmVxKG4pO1xuICAgICAgICAgICAgICAgICAgICB2ICYmIChlWzBdID0gZC5jYWxsKHRoaXMsIG4sIHIuaHRtbCgpKSksIHIuZG9tTWFuaXAoZSwgdCkgfSk7IGlmIChjICYmIChuID0gTC5idWlsZEZyYWdtZW50KGUsIHRoaXNbMF0ub3duZXJEb2N1bWVudCwgITEsIHRoaXMpLCByID0gbi5maXJzdENoaWxkLCAxID09PSBuLmNoaWxkTm9kZXMubGVuZ3RoICYmIChuID0gciksIHIpKSB7IGZvciAobyA9IChpID0gTC5tYXAobShuLCBcInNjcmlwdFwiKSwgcCkpLmxlbmd0aDsgdSA8IGM7IHUrKykgYSA9IG4sIHUgIT09IGYgJiYgKGEgPSBMLmNsb25lKGEsICEwLCAhMCksIG8gJiYgTC5tZXJnZShpLCBtKGEsIFwic2NyaXB0XCIpKSksIHQuY2FsbCh0aGlzW3VdLCBhLCB1KTsgaWYgKG8pXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHMgPSBpW2kubGVuZ3RoIC0gMV0ub3duZXJEb2N1bWVudCwgTC5tYXAoaSwgaCksIHUgPSAwOyB1IDwgbzsgdSsrKSBhID0gaVt1XSwgZmUudGVzdChhLnR5cGUgfHwgXCJcIikgJiYgIUouYWNjZXNzKGEsIFwiZ2xvYmFsRXZhbFwiKSAmJiBMLmNvbnRhaW5zKHMsIGEpICYmIChhLnNyYyA/IEwuX2V2YWxVcmwgJiYgTC5fZXZhbFVybChhLnNyYykgOiBMLmdsb2JhbEV2YWwoYS50ZXh0Q29udGVudC5yZXBsYWNlKHBlLCBcIlwiKSkpIH0gcmV0dXJuIHRoaXMgfSB9KSwgTC5lYWNoKHsgYXBwZW5kVG86IFwiYXBwZW5kXCIsIHByZXBlbmRUbzogXCJwcmVwZW5kXCIsIGluc2VydEJlZm9yZTogXCJiZWZvcmVcIiwgaW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIiwgcmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiIH0sIGZ1bmN0aW9uKGUsIHQpIHsgTC5mbltlXSA9IGZ1bmN0aW9uKGUpIHsgZm9yICh2YXIgbiwgciA9IFtdLCBpID0gTChlKSwgbyA9IGkubGVuZ3RoIC0gMSwgYSA9IDA7IGEgPD0gbzsgYSsrKSBuID0gYSA9PT0gbyA/IHRoaXMgOiB0aGlzLmNsb25lKCEwKSwgTChpW2FdKVt0XShuKSwgQy5hcHBseShyLCBuLmdldCgpKTsgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHIpIH0gfSksIEwuZm4uZGVsYXkgPSBmdW5jdGlvbihlLCB0KSB7IHJldHVybiBlID0gTC5meCA/IEwuZnguc3BlZWRzW2VdIHx8IGUgOiBlLCB0ID0gdCB8fCBcImZ4XCIsIHRoaXMucXVldWUodCwgZnVuY3Rpb24odCwgbikgeyB2YXIgciA9IHNldFRpbWVvdXQodCwgZSk7XG4gICAgICAgICAgICAgICAgbi5zdG9wID0gZnVuY3Rpb24oKSB7IGNsZWFyVGltZW91dChyKSB9IH0pIH0sXG4gICAgICAgIGZ1bmN0aW9uKCkgeyB2YXIgZSA9IEUuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLFxuICAgICAgICAgICAgICAgIHQgPSBFLmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiksXG4gICAgICAgICAgICAgICAgbiA9IHQuYXBwZW5kQ2hpbGQoRS5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpKTtcbiAgICAgICAgICAgIGUudHlwZSA9IFwiY2hlY2tib3hcIiwgQS5jaGVja09uID0gXCJcIiAhPT0gZS52YWx1ZSwgQS5vcHRTZWxlY3RlZCA9IG4uc2VsZWN0ZWQsIHQuZGlzYWJsZWQgPSAhMCwgQS5vcHREaXNhYmxlZCA9ICFuLmRpc2FibGVkLCAoZSA9IEUuY3JlYXRlRWxlbWVudChcImlucHV0XCIpKS52YWx1ZSA9IFwidFwiLCBlLnR5cGUgPSBcInJhZGlvXCIsIEEucmFkaW9WYWx1ZSA9IFwidFwiID09PSBlLnZhbHVlIH0oKTsgdmFyIHZlLCBnZSA9IEwuZXhwci5hdHRySGFuZGxlO1xuICAgIEwuZm4uZXh0ZW5kKHsgYXR0cjogZnVuY3Rpb24oZSwgdCkgeyByZXR1cm4gSyh0aGlzLCBMLmF0dHIsIGUsIHQsIGFyZ3VtZW50cy5sZW5ndGggPiAxKSB9LCByZW1vdmVBdHRyOiBmdW5jdGlvbihlKSB7IHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IEwucmVtb3ZlQXR0cih0aGlzLCBlKSB9KSB9IH0pLCBMLmV4dGVuZCh7IGF0dHI6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgdmFyIHIsIGksIG8gPSBlLm5vZGVUeXBlOyBpZiAoZSAmJiAzICE9PSBvICYmIDggIT09IG8gJiYgMiAhPT0gbykgcmV0dXJuIHZvaWQgMCA9PT0gZS5nZXRBdHRyaWJ1dGUgPyBMLnByb3AoZSwgdCwgbikgOiAoMSA9PT0gbyAmJiBMLmlzWE1MRG9jKGUpIHx8ICh0ID0gdC50b0xvd2VyQ2FzZSgpLCByID0gTC5hdHRySG9va3NbdF0gfHwgKEwuZXhwci5tYXRjaC5ib29sLnRlc3QodCkgPyB2ZSA6IHZvaWQgMCkpLCB2b2lkIDAgPT09IG4gPyByICYmIFwiZ2V0XCIgaW4gciAmJiBudWxsICE9PSAoaSA9IHIuZ2V0KGUsIHQpKSA/IGkgOiAoaSA9IEwuZmluZC5hdHRyKGUsIHQpLCBudWxsID09IGkgPyB2b2lkIDAgOiBpKSA6IG51bGwgIT09IG4gPyByICYmIFwic2V0XCIgaW4gciAmJiB2b2lkIDAgIT09IChpID0gci5zZXQoZSwgbiwgdCkpID8gaSA6IChlLnNldEF0dHJpYnV0ZSh0LCBuICsgXCJcIiksIG4pIDogdm9pZCBMLnJlbW92ZUF0dHIoZSwgdCkpIH0sIHJlbW92ZUF0dHI6IGZ1bmN0aW9uKGUsIHQpIHsgdmFyIG4sIHIsIGkgPSAwLFxuICAgICAgICAgICAgICAgIG8gPSB0ICYmIHQubWF0Y2goUSk7IGlmIChvICYmIDEgPT09IGUubm9kZVR5cGUpXG4gICAgICAgICAgICAgICAgZm9yICg7IG4gPSBvW2krK107KSByID0gTC5wcm9wRml4W25dIHx8IG4sIEwuZXhwci5tYXRjaC5ib29sLnRlc3QobikgJiYgKGVbcl0gPSAhMSksIGUucmVtb3ZlQXR0cmlidXRlKG4pIH0sIGF0dHJIb29rczogeyB0eXBlOiB7IHNldDogZnVuY3Rpb24oZSwgdCkgeyBpZiAoIUEucmFkaW9WYWx1ZSAmJiBcInJhZGlvXCIgPT09IHQgJiYgTC5ub2RlTmFtZShlLCBcImlucHV0XCIpKSB7IHZhciBuID0gZS52YWx1ZTsgcmV0dXJuIGUuc2V0QXR0cmlidXRlKFwidHlwZVwiLCB0KSwgbiAmJiAoZS52YWx1ZSA9IG4pLCB0IH0gfSB9IH0gfSksIHZlID0geyBzZXQ6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgcmV0dXJuICExID09PSB0ID8gTC5yZW1vdmVBdHRyKGUsIG4pIDogZS5zZXRBdHRyaWJ1dGUobiwgbiksIG4gfSB9LCBMLmVhY2goTC5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKC9cXHcrL2cpLCBmdW5jdGlvbihlLCB0KSB7IHZhciBuID0gZ2VbdF0gfHwgTC5maW5kLmF0dHI7XG4gICAgICAgIGdlW3RdID0gZnVuY3Rpb24oZSwgdCwgcikgeyB2YXIgaSwgbzsgcmV0dXJuIHIgfHwgKG8gPSBnZVt0XSwgZ2VbdF0gPSBpLCBpID0gbnVsbCAhPSBuKGUsIHQsIHIpID8gdC50b0xvd2VyQ2FzZSgpIDogbnVsbCwgZ2VbdF0gPSBvKSwgaSB9IH0pOyB2YXIgbWUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pO1xuICAgIEwuZm4uZXh0ZW5kKHsgcHJvcDogZnVuY3Rpb24oZSwgdCkgeyByZXR1cm4gSyh0aGlzLCBMLnByb3AsIGUsIHQsIGFyZ3VtZW50cy5sZW5ndGggPiAxKSB9LCByZW1vdmVQcm9wOiBmdW5jdGlvbihlKSB7IHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IGRlbGV0ZSB0aGlzW0wucHJvcEZpeFtlXSB8fCBlXSB9KSB9IH0pLCBMLmV4dGVuZCh7IHByb3BGaXg6IHsgZm9yOiBcImh0bWxGb3JcIiwgY2xhc3M6IFwiY2xhc3NOYW1lXCIgfSwgcHJvcDogZnVuY3Rpb24oZSwgdCwgbikgeyB2YXIgciwgaSwgbyA9IGUubm9kZVR5cGU7IGlmIChlICYmIDMgIT09IG8gJiYgOCAhPT0gbyAmJiAyICE9PSBvKSByZXR1cm4gKDEgIT09IG8gfHwgIUwuaXNYTUxEb2MoZSkpICYmICh0ID0gTC5wcm9wRml4W3RdIHx8IHQsIGkgPSBMLnByb3BIb29rc1t0XSksIHZvaWQgMCAhPT0gbiA/IGkgJiYgXCJzZXRcIiBpbiBpICYmIHZvaWQgMCAhPT0gKHIgPSBpLnNldChlLCBuLCB0KSkgPyByIDogZVt0XSA9IG4gOiBpICYmIFwiZ2V0XCIgaW4gaSAmJiBudWxsICE9PSAociA9IGkuZ2V0KGUsIHQpKSA/IHIgOiBlW3RdIH0sIHByb3BIb29rczogeyB0YWJJbmRleDogeyBnZXQ6IGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUuaGFzQXR0cmlidXRlKFwidGFiaW5kZXhcIikgfHwgbWUudGVzdChlLm5vZGVOYW1lKSB8fCBlLmhyZWYgPyBlLnRhYkluZGV4IDogLTEgfSB9IH0gfSksIEEub3B0U2VsZWN0ZWQgfHwgKEwucHJvcEhvb2tzLnNlbGVjdGVkID0geyBnZXQ6IGZ1bmN0aW9uKGUpIHsgdmFyIHQgPSBlLnBhcmVudE5vZGU7IHJldHVybiB0ICYmIHQucGFyZW50Tm9kZSAmJiB0LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCwgbnVsbCB9IH0pLCBMLmVhY2goW1widGFiSW5kZXhcIiwgXCJyZWFkT25seVwiLCBcIm1heExlbmd0aFwiLCBcImNlbGxTcGFjaW5nXCIsIFwiY2VsbFBhZGRpbmdcIiwgXCJyb3dTcGFuXCIsIFwiY29sU3BhblwiLCBcInVzZU1hcFwiLCBcImZyYW1lQm9yZGVyXCIsIFwiY29udGVudEVkaXRhYmxlXCJdLCBmdW5jdGlvbigpIHsgTC5wcm9wRml4W3RoaXMudG9Mb3dlckNhc2UoKV0gPSB0aGlzIH0pOyB2YXIgeWUgPSAvW1xcdFxcclxcblxcZl0vZztcbiAgICBMLmZuLmV4dGVuZCh7IGFkZENsYXNzOiBmdW5jdGlvbihlKSB7IHZhciB0LCBuLCByLCBpLCBvLCBhLCBzID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSAmJiBlLFxuICAgICAgICAgICAgICAgIHUgPSAwLFxuICAgICAgICAgICAgICAgIGMgPSB0aGlzLmxlbmd0aDsgaWYgKEwuaXNGdW5jdGlvbihlKSkgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbih0KSB7IEwodGhpcykuYWRkQ2xhc3MoZS5jYWxsKHRoaXMsIHQsIHRoaXMuY2xhc3NOYW1lKSkgfSk7IGlmIChzKVxuICAgICAgICAgICAgICAgIGZvciAodCA9IChlIHx8IFwiXCIpLm1hdGNoKFEpIHx8IFtdOyB1IDwgYzsgdSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAobiA9IHRoaXNbdV0sIHIgPSAxID09PSBuLm5vZGVUeXBlICYmIChuLmNsYXNzTmFtZSA/IChcIiBcIiArIG4uY2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UoeWUsIFwiIFwiKSA6IFwiIFwiKSkgeyBmb3IgKG8gPSAwOyBpID0gdFtvKytdOykgci5pbmRleE9mKFwiIFwiICsgaSArIFwiIFwiKSA8IDAgJiYgKHIgKz0gaSArIFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBMLnRyaW0ociksIG4uY2xhc3NOYW1lICE9PSBhICYmIChuLmNsYXNzTmFtZSA9IGEpIH0gcmV0dXJuIHRoaXMgfSwgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKGUpIHsgdmFyIHQsIG4sIHIsIGksIG8sIGEsIHMgPSAwID09PSBhcmd1bWVudHMubGVuZ3RoIHx8IFwic3RyaW5nXCIgPT0gdHlwZW9mIGUgJiYgZSxcbiAgICAgICAgICAgICAgICB1ID0gMCxcbiAgICAgICAgICAgICAgICBjID0gdGhpcy5sZW5ndGg7IGlmIChMLmlzRnVuY3Rpb24oZSkpIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24odCkgeyBMKHRoaXMpLnJlbW92ZUNsYXNzKGUuY2FsbCh0aGlzLCB0LCB0aGlzLmNsYXNzTmFtZSkpIH0pOyBpZiAocylcbiAgICAgICAgICAgICAgICBmb3IgKHQgPSAoZSB8fCBcIlwiKS5tYXRjaChRKSB8fCBbXTsgdSA8IGM7IHUrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPSB0aGlzW3VdLCByID0gMSA9PT0gbi5ub2RlVHlwZSAmJiAobi5jbGFzc05hbWUgPyAoXCIgXCIgKyBuLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKHllLCBcIiBcIikgOiBcIlwiKSkgeyBmb3IgKG8gPSAwOyBpID0gdFtvKytdOylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgci5pbmRleE9mKFwiIFwiICsgaSArIFwiIFwiKSA+PSAwOykgciA9IHIucmVwbGFjZShcIiBcIiArIGkgKyBcIiBcIiwgXCIgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGUgPyBMLnRyaW0ocikgOiBcIlwiLCBuLmNsYXNzTmFtZSAhPT0gYSAmJiAobi5jbGFzc05hbWUgPSBhKSB9IHJldHVybiB0aGlzIH0sIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbihlLCB0KSB7IHZhciBuID0gdHlwZW9mIGU7IHJldHVybiBcImJvb2xlYW5cIiA9PSB0eXBlb2YgdCAmJiBcInN0cmluZ1wiID09PSBuID8gdCA/IHRoaXMuYWRkQ2xhc3MoZSkgOiB0aGlzLnJlbW92ZUNsYXNzKGUpIDogTC5pc0Z1bmN0aW9uKGUpID8gdGhpcy5lYWNoKGZ1bmN0aW9uKG4pIHsgTCh0aGlzKS50b2dnbGVDbGFzcyhlLmNhbGwodGhpcywgbiwgdGhpcy5jbGFzc05hbWUsIHQpLCB0KSB9KSA6IHRoaXMuZWFjaChmdW5jdGlvbigpIHsgaWYgKFwic3RyaW5nXCIgPT09IG4pXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQsIHIgPSAwLCBpID0gTCh0aGlzKSwgbyA9IGUubWF0Y2goUSkgfHwgW107IHQgPSBvW3IrK107KSBpLmhhc0NsYXNzKHQpID8gaS5yZW1vdmVDbGFzcyh0KSA6IGkuYWRkQ2xhc3ModCk7XG4gICAgICAgICAgICAgICAgZWxzZSBcInVuZGVmaW5lZFwiICE9PSBuICYmIFwiYm9vbGVhblwiICE9PSBuIHx8ICh0aGlzLmNsYXNzTmFtZSAmJiBKLnNldCh0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgdGhpcy5jbGFzc05hbWUpLCB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lIHx8ICExID09PSBlID8gXCJcIiA6IEouZ2V0KHRoaXMsIFwiX19jbGFzc05hbWVfX1wiKSB8fCBcIlwiKSB9KSB9LCBoYXNDbGFzczogZnVuY3Rpb24oZSkgeyBmb3IgKHZhciB0ID0gXCIgXCIgKyBlICsgXCIgXCIsIG4gPSAwLCByID0gdGhpcy5sZW5ndGg7IG4gPCByOyBuKyspXG4gICAgICAgICAgICAgICAgaWYgKDEgPT09IHRoaXNbbl0ubm9kZVR5cGUgJiYgKFwiIFwiICsgdGhpc1tuXS5jbGFzc05hbWUgKyBcIiBcIikucmVwbGFjZSh5ZSwgXCIgXCIpLmluZGV4T2YodCkgPj0gMCkgcmV0dXJuICEwOyByZXR1cm4gITEgfSB9KTsgdmFyIGJlID0gL1xcci9nO1xuICAgIEwuZm4uZXh0ZW5kKHsgdmFsOiBmdW5jdGlvbihlKSB7IHZhciB0LCBuLCByLCBpID0gdGhpc1swXTsgeyBpZiAoYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHIgPSBMLmlzRnVuY3Rpb24oZSksIHRoaXMuZWFjaChmdW5jdGlvbihuKSB7IHZhciBpO1xuICAgICAgICAgICAgICAgICAgICAxID09PSB0aGlzLm5vZGVUeXBlICYmIChudWxsID09IChpID0gciA/IGUuY2FsbCh0aGlzLCBuLCBMKHRoaXMpLnZhbCgpKSA6IGUpID8gaSA9IFwiXCIgOiBcIm51bWJlclwiID09IHR5cGVvZiBpID8gaSArPSBcIlwiIDogTC5pc0FycmF5KGkpICYmIChpID0gTC5tYXAoaSwgZnVuY3Rpb24oZSkgeyByZXR1cm4gbnVsbCA9PSBlID8gXCJcIiA6IGUgKyBcIlwiIH0pKSwgKHQgPSBMLnZhbEhvb2tzW3RoaXMudHlwZV0gfHwgTC52YWxIb29rc1t0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSAmJiBcInNldFwiIGluIHQgJiYgdm9pZCAwICE9PSB0LnNldCh0aGlzLCBpLCBcInZhbHVlXCIpIHx8ICh0aGlzLnZhbHVlID0gaSkpIH0pOyBpZiAoaSkgcmV0dXJuICh0ID0gTC52YWxIb29rc1tpLnR5cGVdIHx8IEwudmFsSG9va3NbaS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSkgJiYgXCJnZXRcIiBpbiB0ICYmIHZvaWQgMCAhPT0gKG4gPSB0LmdldChpLCBcInZhbHVlXCIpKSA/IG4gOiAobiA9IGkudmFsdWUsIFwic3RyaW5nXCIgPT0gdHlwZW9mIG4gPyBuLnJlcGxhY2UoYmUsIFwiXCIpIDogbnVsbCA9PSBuID8gXCJcIiA6IG4pIH0gfSB9KSwgTC5leHRlbmQoeyB2YWxIb29rczogeyBvcHRpb246IHsgZ2V0OiBmdW5jdGlvbihlKSB7IHZhciB0ID0gTC5maW5kLmF0dHIoZSwgXCJ2YWx1ZVwiKTsgcmV0dXJuIG51bGwgIT0gdCA/IHQgOiBMLnRyaW0oTC50ZXh0KGUpKSB9IH0sIHNlbGVjdDogeyBnZXQ6IGZ1bmN0aW9uKGUpIHsgZm9yICh2YXIgdCwgbiwgciA9IGUub3B0aW9ucywgaSA9IGUuc2VsZWN0ZWRJbmRleCwgbyA9IFwic2VsZWN0LW9uZVwiID09PSBlLnR5cGUgfHwgaSA8IDAsIGEgPSBvID8gbnVsbCA6IFtdLCBzID0gbyA/IGkgKyAxIDogci5sZW5ndGgsIHUgPSBpIDwgMCA/IHMgOiBvID8gaSA6IDA7IHUgPCBzOyB1KyspXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChuID0gclt1XSkuc2VsZWN0ZWQgfHwgdSA9PT0gaSkgJiYgKEEub3B0RGlzYWJsZWQgPyAhbi5kaXNhYmxlZCA6IG51bGwgPT09IG4uZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikpICYmICghbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8ICFMLm5vZGVOYW1lKG4ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiKSkpIHsgaWYgKHQgPSBMKG4pLnZhbCgpLCBvKSByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2godCkgfSByZXR1cm4gYSB9LCBzZXQ6IGZ1bmN0aW9uKGUsIHQpIHsgZm9yICh2YXIgbiwgciwgaSA9IGUub3B0aW9ucywgbyA9IEwubWFrZUFycmF5KHQpLCBhID0gaS5sZW5ndGg7IGEtLTspKChyID0gaVthXSkuc2VsZWN0ZWQgPSBMLmluQXJyYXkoci52YWx1ZSwgbykgPj0gMCkgJiYgKG4gPSAhMCk7IHJldHVybiBuIHx8IChlLnNlbGVjdGVkSW5kZXggPSAtMSksIG8gfSB9IH0gfSksIEwuZWFjaChbXCJyYWRpb1wiLCBcImNoZWNrYm94XCJdLCBmdW5jdGlvbigpIHsgTC52YWxIb29rc1t0aGlzXSA9IHsgc2V0OiBmdW5jdGlvbihlLCB0KSB7IGlmIChMLmlzQXJyYXkodCkpIHJldHVybiBlLmNoZWNrZWQgPSBMLmluQXJyYXkoTChlKS52YWwoKSwgdCkgPj0gMCB9IH0sIEEuY2hlY2tPbiB8fCAoTC52YWxIb29rc1t0aGlzXS5nZXQgPSBmdW5jdGlvbihlKSB7IHJldHVybiBudWxsID09PSBlLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID8gXCJvblwiIDogZS52YWx1ZSB9KSB9KSwgTC5lYWNoKFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oZSwgdCkgeyBMLmZuW3RdID0gZnVuY3Rpb24oZSwgbikgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgPyB0aGlzLm9uKHQsIG51bGwsIGUsIG4pIDogdGhpcy50cmlnZ2VyKHQpIH0gfSksIEwuZm4uZXh0ZW5kKHsgaG92ZXI6IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIHRoaXMubW91c2VlbnRlcihlKS5tb3VzZWxlYXZlKHQgfHwgZSkgfSwgYmluZDogZnVuY3Rpb24oZSwgdCwgbikgeyByZXR1cm4gdGhpcy5vbihlLCBudWxsLCB0LCBuKSB9LCB1bmJpbmQ6IGZ1bmN0aW9uKGUsIHQpIHsgcmV0dXJuIHRoaXMub2ZmKGUsIG51bGwsIHQpIH0sIGRlbGVnYXRlOiBmdW5jdGlvbihlLCB0LCBuLCByKSB7IHJldHVybiB0aGlzLm9uKHQsIGUsIG4sIHIpIH0sIHVuZGVsZWdhdGU6IGZ1bmN0aW9uKGUsIHQsIG4pIHsgcmV0dXJuIDEgPT09IGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLm9mZihlLCBcIioqXCIpIDogdGhpcy5vZmYodCwgZSB8fCBcIioqXCIsIG4pIH0gfSk7IHZhciB4ZSA9IC8lMjAvZyxcbiAgICAgICAga2UgPSAvXFxbXFxdJC8sXG4gICAgICAgIFRlID0gL1xccj9cXG4vZyxcbiAgICAgICAgQ2UgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG4gICAgICAgIHdlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuICAgIEwucGFyYW0gPSBmdW5jdGlvbihlLCB0KSB7IHZhciBuLCByID0gW10sXG4gICAgICAgICAgICBpID0gZnVuY3Rpb24oZSwgdCkgeyB0ID0gTC5pc0Z1bmN0aW9uKHQpID8gdCgpIDogbnVsbCA9PSB0ID8gXCJcIiA6IHQsIHJbci5sZW5ndGhdID0gZW5jb2RlVVJJQ29tcG9uZW50KGUpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQodCkgfTsgaWYgKHZvaWQgMCA9PT0gdCAmJiAodCA9IEwuYWpheFNldHRpbmdzICYmIEwuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsKSwgTC5pc0FycmF5KGUpIHx8IGUuanF1ZXJ5ICYmICFMLmlzUGxhaW5PYmplY3QoZSkpIEwuZWFjaChlLCBmdW5jdGlvbigpIHsgaSh0aGlzLm5hbWUsIHRoaXMudmFsdWUpIH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKG4gaW4gZSkgYihuLCBlW25dLCB0LCBpKTsgcmV0dXJuIHIuam9pbihcIiZcIikucmVwbGFjZSh4ZSwgXCIrXCIpIH0sIEwuZm4uZXh0ZW5kKHsgc2VyaWFsaXplOiBmdW5jdGlvbigpIHsgcmV0dXJuIEwucGFyYW0odGhpcy5zZXJpYWxpemVBcnJheSgpKSB9LCBzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHsgdmFyIGUgPSBMLnByb3AodGhpcywgXCJlbGVtZW50c1wiKTsgcmV0dXJuIGUgPyBMLm1ha2VBcnJheShlKSA6IHRoaXMgfSkuZmlsdGVyKGZ1bmN0aW9uKCkgeyB2YXIgZSA9IHRoaXMudHlwZTsgcmV0dXJuIHRoaXMubmFtZSAmJiAhTCh0aGlzKS5pcyhcIjpkaXNhYmxlZFwiKSAmJiB3ZS50ZXN0KHRoaXMubm9kZU5hbWUpICYmICFDZS50ZXN0KGUpICYmICh0aGlzLmNoZWNrZWQgfHwgIXRlLnRlc3QoZSkpIH0pLm1hcChmdW5jdGlvbihlLCB0KSB7IHZhciBuID0gTCh0aGlzKS52YWwoKTsgcmV0dXJuIG51bGwgPT0gbiA/IG51bGwgOiBMLmlzQXJyYXkobikgPyBMLm1hcChuLCBmdW5jdGlvbihlKSB7IHJldHVybiB7IG5hbWU6IHQubmFtZSwgdmFsdWU6IGUucmVwbGFjZShUZSwgXCJcXHJcXG5cIikgfSB9KSA6IHsgbmFtZTogdC5uYW1lLCB2YWx1ZTogbi5yZXBsYWNlKFRlLCBcIlxcclxcblwiKSB9IH0pLmdldCgpIH0gfSksIEwucGFyc2VIVE1MID0gZnVuY3Rpb24oZSwgdCwgbikgeyBpZiAoIWUgfHwgXCJzdHJpbmdcIiAhPSB0eXBlb2YgZSkgcmV0dXJuIG51bGw7IFwiYm9vbGVhblwiID09IHR5cGVvZiB0ICYmIChuID0gdCwgdCA9ICExKSwgdCA9IHQgfHwgRTsgdmFyIHIgPSBJLmV4ZWMoZSksXG4gICAgICAgICAgICBpID0gIW4gJiYgW107IHJldHVybiByID8gW3QuY3JlYXRlRWxlbWVudChyWzFdKV0gOiAociA9IEwuYnVpbGRGcmFnbWVudChbZV0sIHQsIGkpLCBpICYmIGkubGVuZ3RoICYmIEwoaSkucmVtb3ZlKCksIEwubWVyZ2UoW10sIHIuY2hpbGROb2RlcykpIH0sIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgJiYgZGVmaW5lKFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIEwgfSk7IHZhciBEZSA9IGUualF1ZXJ5LFxuICAgICAgICBOZSA9IGUuJDsgcmV0dXJuIEwubm9Db25mbGljdCA9IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIGUuJCA9PT0gTCAmJiAoZS4kID0gTmUpLCB0ICYmIGUualF1ZXJ5ID09PSBMICYmIChlLmpRdWVyeSA9IERlKSwgTCB9LCB2b2lkIDAgPT09IHQgJiYgKGUualF1ZXJ5ID0gZS4kID0gTCksIEwgfSk7Il0sImZpbGUiOiJqcXVlcnktZWZmZWN0cy5qcyJ9
